This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
examples/
  web-ui/
    app.js
    index.html
    styles.css
src/
  channel/
    isolation.rs
    manager.rs
    mod.rs
    validation.rs
  cli/
    commands.rs
    forward.rs
    handlers.rs
    message_converter.rs
    mod.rs
  mode/
    detection.rs
    mod.rs
    operation_mode.rs
  models/
    authorization.rs
    configuration.rs
    message.rs
    mod.rs
  parser/
    cursor.rs
    jsonl.rs
    mod.rs
  server/
    api.rs
    broadcast.rs
    history.rs
    mod.rs
    queue.rs
    server.rs
    terminal.rs
    websocket.rs
  services/
    interaction.rs
    logging.rs
    mod.rs
  transport/
    factory.rs
    file.rs
    mod.rs
    websocket.rs
  lib.rs
  main.rs
.gitignore
.repomixignore
Cargo.toml
repomix.config.json
rustfmt.toml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="examples/web-ui/app.js">
/**
 * ailoop Web UI Client
 * Provides real-time monitoring of agent messages via WebSocket and HTTP API
 */

class AiloopWebUI {
    constructor() {
        this.ws = null;
        this.currentChannel = null;
        this.channels = new Map();
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectDelay = 1000;

        this.init();
    }

    init() {
        this.bindElements();
        this.connectWebSocket();
        this.loadChannels();
        this.loadStats();
    }

    bindElements() {
        this.connectionStatus = document.getElementById('connection-status');
        this.channelsList = document.getElementById('channels-list');
        this.currentChannelHeader = document.getElementById('current-channel');
        this.messagesContainer = document.getElementById('messages-container');
        this.statsInfo = document.getElementById('stats-info');

        document.getElementById('refresh-btn').addEventListener('click', () => {
            this.loadChannels();
            this.loadStats();
            if (this.currentChannel) {
                this.loadMessages(this.currentChannel);
            }
        });

        document.getElementById('clear-btn').addEventListener('click', () => {
            this.messagesContainer.innerHTML = '';
        });
    }

    connectWebSocket() {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}`;

        this.updateConnectionStatus('connecting', 'Connecting...');

        try {
            this.ws = new WebSocket(wsUrl);

            this.ws.onopen = () => {
                this.updateConnectionStatus('connected', 'Connected');
                this.reconnectAttempts = 0;
                console.log('WebSocket connected');

                // Subscribe to all channels for monitoring
                this.sendWebSocketMessage({
                    type: 'subscribe',
                    channel: '*'
                });
            };

            this.ws.onmessage = (event) => {
                this.handleWebSocketMessage(event.data);
            };

            this.ws.onclose = () => {
                this.updateConnectionStatus('disconnected', 'Disconnected');
                this.handleReconnect();
            };

            this.ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                this.updateConnectionStatus('disconnected', 'Connection Error');
            };

        } catch (error) {
            console.error('Failed to create WebSocket connection:', error);
            this.updateConnectionStatus('disconnected', 'Failed to Connect');
            this.handleReconnect();
        }
    }

    handleReconnect() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);

            setTimeout(() => {
                this.connectWebSocket();
            }, this.reconnectDelay * this.reconnectAttempts);
        } else {
            console.error('Max reconnection attempts reached');
            this.updateConnectionStatus('disconnected', 'Failed to Reconnect');
        }
    }

    sendWebSocketMessage(message) {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify(message));
        } else {
            console.warn('WebSocket not connected, cannot send message:', message);
        }
    }

    handleWebSocketMessage(data) {
        try {
            const message = JSON.parse(data);
            this.displayMessage(message);
        } catch (error) {
            console.error('Failed to parse WebSocket message:', error, data);
        }
    }

    updateConnectionStatus(status, text) {
        this.connectionStatus.className = `status ${status}`;
        this.connectionStatus.textContent = text;
    }

    async loadChannels() {
        try {
            const response = await fetch('/api/channels');
            const data = await response.json();
            this.updateChannelsList(data.channels);
        } catch (error) {
            console.error('Failed to load channels:', error);
            this.channelsList.innerHTML = '<div class="error">Failed to load channels</div>';
        }
    }

    async loadStats() {
        try {
            const response = await fetch('/api/stats');
            const stats = await response.json();
            this.updateStats(stats);
        } catch (error) {
            console.error('Failed to load stats:', error);
            this.statsInfo.textContent = 'Failed to load stats';
        }
    }

    async loadMessages(channel) {
        try {
            const response = await fetch(`/api/channels/${encodeURIComponent(channel)}/messages?limit=50`);
            const data = await response.json();
            this.displayChannelMessages(channel, data.messages);
        } catch (error) {
            console.error('Failed to load messages:', error);
        }
    }

    updateChannelsList(channels) {
        this.channelsList.innerHTML = '';

        if (channels.length === 0) {
            this.channelsList.innerHTML = '<div class="channel-item">No active channels</div>';
            return;
        }

        channels.forEach(channel => {
            const channelElement = document.createElement('div');
            channelElement.className = 'channel-item';
            if (this.currentChannel === channel.name) {
                channelElement.classList.add('active');
            }

            channelElement.innerHTML = `
                <div class="channel-name">${this.escapeHtml(channel.name)}</div>
                <div class="message-count">${channel.message_count}</div>
            `;

            channelElement.addEventListener('click', () => {
                this.selectChannel(channel.name);
            });

            this.channelsList.appendChild(channelElement);
            this.channels.set(channel.name, channel);
        });
    }

    updateStats(stats) {
        this.statsInfo.innerHTML = `
            <div>Total Viewers: ${stats.total_viewers}</div>
            <div>Agent Connections: ${stats.agent_connections}</div>
            <div>Viewer Connections: ${stats.viewer_connections}</div>
            <div>Active Channels: ${stats.active_channels}</div>
        `;
    }

    selectChannel(channelName) {
        this.currentChannel = channelName;
        this.currentChannelHeader.textContent = `Channel: ${channelName}`;
        this.updateChannelSelection();
        this.loadMessages(channelName);
    }

    updateChannelSelection() {
        document.querySelectorAll('.channel-item').forEach(item => {
            item.classList.remove('active');
        });

        const activeItem = Array.from(document.querySelectorAll('.channel-item')).find(item => {
            return item.querySelector('.channel-name').textContent === this.currentChannel;
        });

        if (activeItem) {
            activeItem.classList.add('active');
        }
    }

    displayChannelMessages(channel, messages) {
        this.messagesContainer.innerHTML = '';

        if (messages.length === 0) {
            this.messagesContainer.innerHTML = '<div class="message">No messages in this channel yet</div>';
            return;
        }

        messages.reverse().forEach(message => {
            this.displayMessage(message);
        });
    }

    displayMessage(message) {
        const messageElement = document.createElement('div');
        messageElement.className = `message ${this.getMessageClass(message)}`;

        const timestamp = message.timestamp ? new Date(message.timestamp).toLocaleTimeString() : 'Unknown';
        const agentType = message.metadata && message.metadata.agent_type ? message.metadata.agent_type : 'unknown';

        messageElement.innerHTML = `
            <div class="message-header">
                <span class="message-agent">[${this.escapeHtml(agentType)}]</span>
                <span class="message-timestamp">${timestamp}</span>
            </div>
            <div class="message-content">${this.formatMessageContent(message)}</div>
        `;

        this.messagesContainer.appendChild(messageElement);

        // Auto-scroll to bottom
        this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
    }

    getMessageClass(message) {
        if (!message.content) return '';

        switch (message.content.type) {
            case 'notification':
                if (message.content.priority === 'urgent') return 'error';
                if (message.content.priority === 'high') return 'warning';
                return 'agent';
            case 'question':
                return 'agent';
            case 'authorization':
                return 'warning';
            case 'response':
                return 'system';
            default:
                return 'agent';
        }
    }

    formatMessageContent(message) {
        if (!message.content) return 'No content';

        switch (message.content.type) {
            case 'notification':
                return this.escapeHtml(message.content.text || 'No text');
            case 'question':
                return `â“ ${this.escapeHtml(message.content.text || 'No question')}`;
            case 'authorization':
                return `ðŸ” Authorization: ${this.escapeHtml(message.content.action || 'Unknown action')}`;
            case 'response':
                const answer = message.content.answer || '(no answer)';
                return `ðŸ“¤ Response: ${this.escapeHtml(answer)}`;
            default:
                return JSON.stringify(message.content, null, 2);
        }
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
}

// Initialize the web UI when the page loads
document.addEventListener('DOMContentLoaded', () => {
    new AiloopWebUI();
});
</file>

<file path="examples/web-ui/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ailoop - Agent Message Streaming</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>ailoop Agent Monitor</h1>
            <div id="connection-status" class="status disconnected">Disconnected</div>
        </header>

        <div class="main-content">
            <aside class="sidebar">
                <h2>Channels</h2>
                <div id="channels-list" class="channels-list">
                    <!-- Channels will be populated here -->
                </div>
                <div class="stats">
                    <div id="stats-info">Loading...</div>
                </div>
            </aside>

            <main class="message-panel">
                <div class="channel-header">
                    <h2 id="current-channel">Select a Channel</h2>
                    <div class="channel-controls">
                        <button id="refresh-btn" class="btn">Refresh</button>
                        <button id="clear-btn" class="btn">Clear</button>
                    </div>
                </div>

                <div id="messages-container" class="messages-container">
                    <!-- Messages will be displayed here -->
                </div>
            </main>
        </div>
    </div>

    <script src="app.js"></script>
</body>
</html>
</file>

<file path="examples/web-ui/styles.css">
/* ailoop Web UI Styles */

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    background-color: #1a1a1a;
    color: #e0e0e0;
    line-height: 1.6;
    overflow: hidden;
}

.container {
    height: 100vh;
    display: flex;
    flex-direction: column;
}

header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem 2rem;
    background-color: #2a2a2a;
    border-bottom: 1px solid #404040;
}

header h1 {
    color: #00d4aa;
    font-size: 1.5rem;
    font-weight: 600;
}

.status {
    padding: 0.25rem 0.75rem;
    border-radius: 4px;
    font-size: 0.875rem;
    font-weight: 500;
    text-transform: uppercase;
}

.status.connected {
    background-color: #00d4aa;
    color: #1a1a1a;
}

.status.disconnected {
    background-color: #d9534f;
    color: white;
}

.status.connecting {
    background-color: #f0ad4e;
    color: #1a1a1a;
}

.main-content {
    flex: 1;
    display: flex;
    overflow: hidden;
}

.sidebar {
    width: 300px;
    background-color: #252525;
    border-right: 1px solid #404040;
    display: flex;
    flex-direction: column;
}

.sidebar h2 {
    padding: 1rem;
    font-size: 1.125rem;
    color: #00d4aa;
    border-bottom: 1px solid #404040;
}

.channels-list {
    flex: 1;
    overflow-y: auto;
    padding: 0.5rem;
}

.channel-item {
    display: flex;
    align-items: center;
    padding: 0.75rem 1rem;
    margin: 0.25rem 0;
    background-color: #2a2a2a;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s;
}

.channel-item:hover {
    background-color: #3a3a3a;
}

.channel-item.active {
    background-color: #00d4aa;
    color: #1a1a1a;
}

.channel-item .channel-name {
    flex: 1;
    font-weight: 500;
}

.channel-item .message-count {
    background-color: #404040;
    padding: 0.125rem 0.5rem;
    border-radius: 10px;
    font-size: 0.75rem;
    color: #b0b0b0;
}

.stats {
    padding: 1rem;
    border-top: 1px solid #404040;
    font-size: 0.875rem;
    color: #a0a0a0;
}

.message-panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    background-color: #1a1a1a;
}

.channel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem 2rem;
    background-color: #2a2a2a;
    border-bottom: 1px solid #404040;
}

.channel-header h2 {
    color: #00d4aa;
    font-size: 1.25rem;
}

.channel-controls {
    display: flex;
    gap: 0.5rem;
}

.btn {
    padding: 0.5rem 1rem;
    background-color: #404040;
    color: #e0e0e0;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.875rem;
    transition: background-color 0.2s;
}

.btn:hover {
    background-color: #505050;
}

.messages-container {
    flex: 1;
    overflow-y: auto;
    padding: 1rem 2rem;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 0.875rem;
}

.message {
    margin-bottom: 1rem;
    padding: 0.75rem;
    background-color: #252525;
    border-radius: 4px;
    border-left: 4px solid #00d4aa;
    white-space: pre-wrap;
    word-wrap: break-word;
}

.message.error {
    border-left-color: #d9534f;
}

.message.warning {
    border-left-color: #f0ad4e;
}

.message.agent {
    border-left-color: #5bc0de;
}

.message.system {
    border-left-color: #777;
}

.message-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
    font-size: 0.75rem;
    color: #a0a0a0;
}

.message-agent {
    font-weight: 600;
    color: #00d4aa;
}

.message-timestamp {
    color: #777;
}

.message-content {
    color: #e0e0e0;
    line-height: 1.4;
}

/* Scrollbar styling */
.channels-list::-webkit-scrollbar,
.messages-container::-webkit-scrollbar {
    width: 8px;
}

.channels-list::-webkit-scrollbar-track,
.messages-container::-webkit-scrollbar-track {
    background: #1a1a1a;
}

.channels-list::-webkit-scrollbar-thumb,
.messages-container::-webkit-scrollbar-thumb {
    background: #404040;
    border-radius: 4px;
}

.channels-list::-webkit-scrollbar-thumb:hover,
.messages-container::-webkit-scrollbar-thumb:hover {
    background: #505050;
}

/* Responsive design */
@media (max-width: 768px) {
    .sidebar {
        width: 250px;
    }

    header {
        padding: 1rem;
    }

    .channel-header {
        padding: 1rem;
        flex-direction: column;
        gap: 1rem;
        align-items: stretch;
    }

    .channel-controls {
        justify-content: center;
    }

    .messages-container {
        padding: 1rem;
    }
}

/* Loading animation */
@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
}

.loading {
    animation: pulse 1.5s ease-in-out infinite;
}
</file>

<file path="src/channel/isolation.rs">
//! Channel isolation mechanisms

use crate::models::Message;
use crate::channel::manager::ChannelManager;
use std::sync::{Arc, Mutex};

/// Thread-safe channel isolation wrapper
pub struct ChannelIsolation {
    manager: Arc<Mutex<ChannelManager>>,
}

impl ChannelIsolation {
    /// Create a new channel isolation wrapper
    pub fn new(default_channel: String) -> Self {
        Self {
            manager: Arc::new(Mutex::new(ChannelManager::new(default_channel))),
        }
    }

    /// Enqueue a message in a specific channel
    pub fn enqueue_message(&self, channel_name: &str, message: Message) {
        if let Ok(mut manager) = self.manager.lock() {
            manager.enqueue_message(channel_name, message);
        } else {
            eprintln!("Failed to acquire channel manager lock");
        }
    }

    /// Dequeue a message from a specific channel
    pub fn dequeue_message(&self, channel_name: &str) -> Option<Message> {
        if let Ok(mut manager) = self.manager.lock() {
            manager.dequeue_message(channel_name)
        } else {
            eprintln!("Failed to acquire channel manager lock");
            None
        }
    }

    /// Get queue size for a specific channel
    pub fn get_queue_size(&self, channel_name: &str) -> usize {
        if let Ok(manager) = self.manager.lock() {
            manager.get_queue_size(channel_name)
        } else {
            eprintln!("Failed to acquire channel manager lock");
            0
        }
    }

    /// Add a connection to a specific channel
    pub fn add_connection(&self, channel_name: &str) {
        if let Ok(mut manager) = self.manager.lock() {
            manager.add_connection(channel_name);
        } else {
            eprintln!("Failed to acquire channel manager lock");
        }
    }

    /// Remove a connection from a specific channel
    pub fn remove_connection(&self, channel_name: &str) {
        if let Ok(mut manager) = self.manager.lock() {
            manager.remove_connection(channel_name);
        } else {
            eprintln!("Failed to acquire channel manager lock");
        }
    }

    /// Get connection count for a specific channel
    pub fn get_connection_count(&self, channel_name: &str) -> usize {
        if let Ok(manager) = self.manager.lock() {
            manager.get_connection_count(channel_name)
        } else {
            eprintln!("Failed to acquire channel manager lock");
            0
        }
    }

    /// Clean up inactive channels
    pub fn cleanup_inactive_channels(&self) {
        if let Ok(mut manager) = self.manager.lock() {
            manager.cleanup_inactive_channels();
        } else {
            eprintln!("Failed to acquire channel manager lock");
        }
    }

    /// Get all active channels
    pub fn get_active_channels(&self) -> Vec<String> {
        if let Ok(manager) = self.manager.lock() {
            manager.get_active_channels().into_iter().cloned().collect()
        } else {
            eprintln!("Failed to acquire channel manager lock");
            Vec::new()
        }
    }
}

impl Default for ChannelIsolation {
    fn default() -> Self {
        Self::new("public".to_string())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::models::{Message, SenderType, MessageContent};

    #[test]
    fn test_channel_isolation_creation() {
        let isolation = ChannelIsolation::new("test-default".to_string());
        let channels = isolation.get_active_channels();
        assert!(channels.contains(&"test-default".to_string()));
    }

    #[test]
    fn test_thread_safe_operations() {
        let isolation = ChannelIsolation::default();

        // Test basic operations
        isolation.add_connection("test-channel");
        assert_eq!(isolation.get_connection_count("test-channel"), 1);

        let content = MessageContent::Question {
            text: "Thread safety test".to_string(),
            timeout_seconds: 30,
        };

        let message = Message::new("test-channel".to_string(), SenderType::Agent, content);
        isolation.enqueue_message("test-channel", message);
        assert_eq!(isolation.get_queue_size("test-channel"), 1);

        let dequeued = isolation.dequeue_message("test-channel");
        assert!(dequeued.is_some());
        assert_eq!(isolation.get_queue_size("test-channel"), 0);
    }

    #[test]
    fn test_channel_isolation_between_channels() {
        let isolation = ChannelIsolation::default();

        // Add message to channel A
        let content_a = MessageContent::Question {
            text: "Channel A message".to_string(),
            timeout_seconds: 30,
        };
        let message_a = Message::new("channel-a".to_string(), SenderType::Agent, content_a);
        isolation.enqueue_message("channel-a", message_a);

        // Add message to channel B
        let content_b = MessageContent::Question {
            text: "Channel B message".to_string(),
            timeout_seconds: 30,
        };
        let message_b = Message::new("channel-b".to_string(), SenderType::Agent, content_b);
        isolation.enqueue_message("channel-b", message_b);

        // Verify isolation - each channel has its own message
        assert_eq!(isolation.get_queue_size("channel-a"), 1);
        assert_eq!(isolation.get_queue_size("channel-b"), 1);

        // Dequeue from channel A should not affect channel B
        let _ = isolation.dequeue_message("channel-a");
        assert_eq!(isolation.get_queue_size("channel-a"), 0);
        assert_eq!(isolation.get_queue_size("channel-b"), 1);
    }
}
</file>

<file path="src/channel/manager.rs">
//! Channel lifecycle management

use crate::models::Message;
use crate::server::MessageQueue;
use std::collections::HashMap;

/// Channel manager for handling multiple communication channels
pub struct ChannelManager {
    channels: HashMap<String, ChannelState>,
    default_channel: String,
}

pub(crate) struct ChannelState {
    queue: MessageQueue,
    active_connections: usize,
    created_at: chrono::DateTime<chrono::Utc>,
}

impl ChannelManager {
    /// Create a new channel manager
    pub fn new(default_channel: String) -> Self {
        let mut channels = HashMap::new();

        // Create default channel
        channels.insert(default_channel.clone(), ChannelState {
            queue: MessageQueue::default(),
            active_connections: 0,
            created_at: chrono::Utc::now(),
        });

        Self {
            channels,
            default_channel,
        }
    }

    /// Get or create a channel
    pub fn get_or_create_channel(&mut self, channel_name: &str) -> &mut ChannelState {
        self.channels.entry(channel_name.to_string()).or_insert_with(|| {
            println!("Creating new channel: {}", channel_name);
            ChannelState {
                queue: MessageQueue::default(),
                active_connections: 0,
                created_at: chrono::Utc::now(),
            }
        })
    }

    /// Add a message to a channel
    pub fn enqueue_message(&mut self, channel_name: &str, message: Message) {
        let channel = self.get_or_create_channel(channel_name);
        channel.queue.enqueue(message);
        println!("Message queued in channel '{}', queue size: {}", channel_name, channel.queue.len());
    }

    /// Get the next message from a channel
    pub fn dequeue_message(&mut self, channel_name: &str) -> Option<Message> {
        if let Some(channel) = self.channels.get_mut(channel_name) {
            channel.queue.dequeue()
        } else {
            None
        }
    }

    /// Get queue size for a channel
    pub fn get_queue_size(&self, channel_name: &str) -> usize {
        self.channels
            .get(channel_name)
            .map(|channel| channel.queue.len())
            .unwrap_or(0)
    }

    /// Add a connection to a channel
    pub fn add_connection(&mut self, channel_name: &str) {
        let channel = self.get_or_create_channel(channel_name);
        channel.active_connections += 1;
    }

    /// Remove a connection from a channel
    pub fn remove_connection(&mut self, channel_name: &str) {
        if let Some(channel) = self.channels.get_mut(channel_name) {
            if channel.active_connections > 0 {
                channel.active_connections -= 1;
            }
        }
    }

    /// Get active connection count for a channel
    pub fn get_connection_count(&self, channel_name: &str) -> usize {
        self.channels
            .get(channel_name)
            .map(|channel| channel.active_connections)
            .unwrap_or(0)
    }

    /// Clean up inactive channels (no connections and empty queue)
    pub fn cleanup_inactive_channels(&mut self) {
        let channels_to_remove: Vec<String> = self.channels
            .iter()
            .filter(|(name, state)| {
                name != &&self.default_channel && // Don't remove default channel
                state.active_connections == 0 &&
                state.queue.is_empty()
            })
            .map(|(name, _)| name.clone())
            .collect();

        for channel_name in channels_to_remove {
            self.channels.remove(&channel_name);
            println!("Cleaned up inactive channel: {}", channel_name);
        }
    }

    /// Get all active channels
    pub fn get_active_channels(&self) -> Vec<&String> {
        self.channels.keys().collect()
    }
}

impl Default for ChannelManager {
    fn default() -> Self {
        Self::new("public".to_string())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::models::{Message, SenderType, MessageContent};

    #[test]
    fn test_channel_manager_creation() {
        let manager = ChannelManager::new("test-default".to_string());
        assert_eq!(manager.default_channel, "test-default");
        assert!(manager.channels.contains_key("test-default"));
    }

    #[test]
    fn test_channel_creation_on_demand() {
        let mut manager = ChannelManager::default();

        // Channel should be created when first accessed
        let channel = manager.get_or_create_channel("new-channel");
        assert_eq!(channel.active_connections, 0);
        assert!(channel.queue.is_empty());

        // Should be in channels map
        assert!(manager.channels.contains_key("new-channel"));
    }

    #[test]
    fn test_message_enqueue_dequeue() {
        let mut manager = ChannelManager::default();

        let content = MessageContent::Question {
            text: "Test question".to_string(),
            timeout_seconds: 30,
        };

        let message = Message::new("test-channel".to_string(), SenderType::Agent, content);

        manager.enqueue_message("test-channel", message.clone());
        assert_eq!(manager.get_queue_size("test-channel"), 1);

        let dequeued = manager.dequeue_message("test-channel");
        assert!(dequeued.is_some());
        assert_eq!(dequeued.unwrap().channel, message.channel);
        assert_eq!(manager.get_queue_size("test-channel"), 0);
    }

    #[test]
    fn test_connection_management() {
        let mut manager = ChannelManager::default();

        manager.add_connection("test-channel");
        assert_eq!(manager.get_connection_count("test-channel"), 1);

        manager.add_connection("test-channel");
        assert_eq!(manager.get_connection_count("test-channel"), 2);

        manager.remove_connection("test-channel");
        assert_eq!(manager.get_connection_count("test-channel"), 1);
    }

    #[test]
    fn test_channel_cleanup() {
        let mut manager = ChannelManager::default();

        // Create a non-default channel with no connections and empty queue
        let _ = manager.get_or_create_channel("temp-channel");
        assert!(manager.channels.contains_key("temp-channel"));

        // Cleanup should remove it
        manager.cleanup_inactive_channels();
        assert!(!manager.channels.contains_key("temp-channel"));

        // Default channel should remain
        assert!(manager.channels.contains_key("public"));
    }
}
</file>

<file path="src/channel/mod.rs">
//! Channel management and isolation

pub mod manager;
pub mod isolation;
pub mod validation;

pub use manager::ChannelManager;
pub use isolation::ChannelIsolation;
pub use validation::*;
</file>

<file path="src/cli/commands.rs">
//! CLI command definitions (placeholder for now)

// This module will contain any shared command logic
// Currently commands are defined directly in main.rs with clap

#[cfg(test)]
mod tests {
    #[test]
    fn test_placeholder() {
        // Placeholder test
        assert!(true);
    }
}
</file>

<file path="src/cli/forward.rs">
//! Forward command for streaming agent output to ailoop server

use crate::cli::message_converter::MessageConverter;
use crate::parser::{create_parser, InputFormat};
use crate::transport::factory::{create_transport, TransportConfig, TransportType};
use anyhow::{Context, Result};
use std::io::{self, BufRead, BufReader};
use std::path::PathBuf;
use tokio::io::AsyncBufReadExt;

/// Forward command configuration
pub struct ForwardConfig {
    pub channel: String,
    pub agent_type: Option<String>,
    pub format: InputFormat,
    pub transport_type: TransportType,
    pub url: Option<String>,
    pub file_path: Option<PathBuf>,
    pub client_id: Option<String>,
    pub input_file: Option<PathBuf>,
}

/// Execute the forward command
pub async fn execute_forward(config: ForwardConfig) -> Result<()> {
    // Validate channel name
    crate::channel::validation::validate_channel_name(&config.channel)
        .map_err(|e| anyhow::anyhow!("Invalid channel name: {}", e))?;

    // Create parser
    let mut parser = create_parser(config.agent_type.clone(), config.format)
        .context("Failed to create parser")?;

    // Create message converter
    let mut converter = MessageConverter::new(
        config.channel.clone(),
        config.client_id.clone(),
        parser.agent_type().to_string(),
    );

    // Create transport
    let transport_config = TransportConfig {
        transport_type: config.transport_type.clone(),
        url: config.url.clone(),
        file_path: config.file_path.clone().map(|p| p.to_string_lossy().to_string()),
        channel: config.channel.clone(),
        client_id: config.client_id.clone(),
    };
    let mut transport = create_transport(transport_config)
        .context("Failed to create transport")?;

    // Determine input source
    if let Some(input_file) = config.input_file {
        // Read from file
        process_file_input(&mut *parser, &mut converter, &mut *transport, input_file).await?;
    } else {
        // Read from stdin
        process_stdin_input(&mut *parser, &mut converter, &mut *transport).await?;
    }

    // Flush and close transport
    transport.flush().await.context("Failed to flush transport")?;
    transport.close().await.context("Failed to close transport")?;

    Ok(())
}

/// Process input from stdin
async fn process_stdin_input(
    parser: &mut dyn crate::parser::AgentParser,
    converter: &mut MessageConverter,
    transport: &mut dyn crate::transport::Transport,
) -> Result<()> {
    let stdin = io::stdin();
    let reader = BufReader::new(stdin.lock());

    for line_result in reader.lines() {
        let line = line_result.context("Failed to read line from stdin")?;

        // Parse line (skip malformed lines with warning)
        match parser.parse_line(&line).await {
            Ok(Some(event)) => {
                // Convert event to messages
                let messages = converter.convert(event);

                // Send each message through transport
                for message in messages {
                    if let Err(e) = transport.send(message).await {
                        eprintln!("Warning: Failed to send message: {}", e);
                        // Continue processing despite transport errors
                    }
                }
            }
            Ok(None) => {
                // Line was skipped (empty or comment)
            }
            Err(e) => {
                // Malformed line - log warning and continue
                eprintln!("Warning: Failed to parse line (skipping): {}", e);
                eprintln!("  Line: {}", line);
            }
        }
    }

    Ok(())
}

/// Process input from file
async fn process_file_input(
    parser: &mut dyn crate::parser::AgentParser,
    converter: &mut MessageConverter,
    transport: &mut dyn crate::transport::Transport,
    file_path: PathBuf,
) -> Result<()> {
    let file = tokio::fs::File::open(&file_path)
        .await
        .with_context(|| format!("Failed to open file: {:?}", file_path))?;

    let mut reader = tokio::io::BufReader::new(file);
    let mut line = String::new();

    while reader.read_line(&mut line).await? > 0 {
        let line_trimmed = line.trim_end();

        // Parse line (skip malformed lines with warning)
        match parser.parse_line(line_trimmed).await {
            Ok(Some(event)) => {
                // Convert event to messages
                let messages = converter.convert(event);

                // Send each message through transport
                for message in messages {
                    if let Err(e) = transport.send(message).await {
                        eprintln!("Warning: Failed to send message: {}", e);
                        // Continue processing despite transport errors
                    }
                }
            }
            Ok(None) => {
                // Line was skipped (empty or comment)
            }
            Err(e) => {
                // Malformed line - log warning and continue
                eprintln!("Warning: Failed to parse line (skipping): {}", e);
                eprintln!("  Line: {}", line_trimmed);
            }
        }

        line.clear();
    }

    Ok(())
}
</file>

<file path="src/mode/detection.rs">
//! Mode detection implementation (IF-001: DetermineOperationMode)
//!
//! Determines operation mode based on command-line arguments and environment variables.
//! Implements REQ-001, REQ-002, REQ-003.

use super::{ModeDetectionError, OperationMode, PrecedenceSource};
use std::env;
use std::time::Instant;

/// Determine operation mode based on command-line arguments and environment variables
///
/// Implements interface IF-001: DetermineOperationMode
///
/// # Arguments
/// * `server_flag` - Optional server URL from --server flag
///
/// # Returns
/// * `Ok(OperationMode)` - Determined operation mode
/// * `Err(ModeDetectionError::InvalidServerUrl)` - If server URL format is invalid
///
/// # Behavior
/// 1. AILOOP_SERVER environment variable takes precedence over --server flag (REQ-003, REQ-004)
/// 2. If AILOOP_SERVER is set, use server mode with that URL
/// 3. If --server flag is provided (and AILOOP_SERVER is not set), use server mode with flag URL
/// 4. If neither is present, use direct mode (REQ-002)
/// 5. Must complete within 100ms (QC-001)
pub fn determine_operation_mode(
    server_flag: Option<String>,
) -> Result<OperationMode, ModeDetectionError> {
    let start = Instant::now();

    // Check AILOOP_SERVER environment variable first (takes precedence)
    let env_server = env::var("AILOOP_SERVER").ok();

    let result = if let Some(env_url) = env_server {
        // AILOOP_SERVER takes precedence (REQ-003, REQ-004)
        let server_url = convert_to_websocket_url(&env_url)?;
        OperationMode::server(server_url, PrecedenceSource::AiloopServer)
    } else if let Some(flag_url) = server_flag {
        // --server flag is used when AILOOP_SERVER is not set
        let server_url = convert_to_websocket_url(&flag_url)?;
        OperationMode::server(server_url, PrecedenceSource::ServerFlag)
    } else {
        // Default to direct mode (REQ-002)
        OperationMode::direct(PrecedenceSource::Default)
    };

    // Verify completion within 100ms (QC-001)
    let elapsed = start.elapsed();
    if elapsed.as_millis() > 100 {
        // Log warning but don't fail - this is a quality contract, not a hard requirement
        eprintln!(
            "Warning: Mode detection took {}ms, exceeding 100ms threshold",
            elapsed.as_millis()
        );
    }

    Ok(result)
}

/// Convert HTTP/HTTPS URL to WebSocket URL
///
/// Converts http:// to ws:// and https:// to wss://
/// If URL already starts with ws:// or wss://, returns it as-is.
/// If URL is invalid, returns an error.
fn convert_to_websocket_url(url: &str) -> Result<String, ModeDetectionError> {
    let trimmed = url.trim();

    // Validate URL format (basic validation)
    if trimmed.is_empty() {
        return Err(ModeDetectionError::InvalidServerUrl(
            "URL cannot be empty".to_string(),
        ));
    }

    // Check if already a WebSocket URL
    if trimmed.starts_with("ws://") || trimmed.starts_with("wss://") {
        // Validate the URL structure
        if url::Url::parse(trimmed).is_err() {
            return Err(ModeDetectionError::InvalidServerUrl(format!(
                "Invalid WebSocket URL format: {}",
                trimmed
            )));
        }
        return Ok(trimmed.to_string());
    }

    // Convert HTTP/HTTPS to WebSocket
    if trimmed.starts_with("http://") {
        let ws_url = trimmed.replacen("http://", "ws://", 1);
        // Validate the converted URL
        if url::Url::parse(&ws_url).is_err() {
            return Err(ModeDetectionError::InvalidServerUrl(format!(
                "Invalid URL format after conversion: {}",
                ws_url
            )));
        }
        return Ok(ws_url);
    }

    if trimmed.starts_with("https://") {
        let wss_url = trimmed.replacen("https://", "wss://", 1);
        // Validate the converted URL
        if url::Url::parse(&wss_url).is_err() {
            return Err(ModeDetectionError::InvalidServerUrl(format!(
                "Invalid URL format after conversion: {}",
                wss_url
            )));
        }
        return Ok(wss_url);
    }

    // If URL doesn't start with http://, https://, ws://, or wss://, treat as invalid
    Err(ModeDetectionError::InvalidServerUrl(format!(
        "URL must start with http://, https://, ws://, or wss://: {}",
        trimmed
    )))
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::env;

    fn clear_env() {
        env::remove_var("AILOOP_SERVER");
    }

    /// TC-REQ-001-01: Verify direct mode detection when AILOOP_SERVER is absent
    ///
    /// Given: AILOOP_SERVER environment variable is not set
    /// When: Execute 'ailoop ask "test"' command
    /// Then:
    ///   - System determines operation_mode = 'direct'
    ///   - Mode detection completes within 100ms
    ///   - Question is displayed in local terminal (not WebSocket connection attempted)
    #[test]
    fn test_tc_req_001_01_direct_mode_when_env_not_set() {
        // Given: AILOOP_SERVER environment variable is not set
        clear_env();
        
        // When: Execute mode detection (simulating 'ailoop ask "test"' command)
        let start = Instant::now();
        let mode = determine_operation_mode(None).unwrap();
        let elapsed = start.elapsed();
        
        // Then: System determines operation_mode = 'direct'
        assert!(mode.is_direct(), "Mode should be direct when no env var or flag is set");
        assert_eq!(mode.precedence_source, PrecedenceSource::Default);
        assert_eq!(mode.server_url, None);
        
        // Then: Mode detection completes within 100ms
        assert!(elapsed.as_millis() < 100, "Mode detection took {}ms, exceeding 100ms threshold", elapsed.as_millis());
        
        // Clean up after test
        clear_env();
    }

    #[test]
    fn test_server_mode_from_flag() {
        // Ensure env is cleared before test
        clear_env();
        let mode = determine_operation_mode(Some("http://localhost:8080".to_string())).unwrap();
        assert!(mode.is_server(), "Mode should be server when --server flag is provided");
        assert_eq!(mode.precedence_source, PrecedenceSource::ServerFlag);
        assert!(mode.server_url.is_some());
        assert!(mode.server_url.unwrap().starts_with("ws://"));
        // Clean up after test
        clear_env();
    }

    /// TC-REQ-001-02: Verify server mode detection when AILOOP_SERVER is present
    ///
    /// Given: AILOOP_SERVER=http://localhost:8080 environment variable is set
    /// When: Execute 'ailoop ask "test"' command
    /// Then:
    ///   - System determines operation_mode = 'server'
    ///   - Mode detection completes within 100ms
    ///   - System attempts WebSocket connection (no local terminal prompt)
    #[test]
    fn test_tc_req_001_02_server_mode_when_env_set() {
        // Given: AILOOP_SERVER=http://localhost:8080 environment variable is set
        clear_env();
        env::set_var("AILOOP_SERVER", "http://localhost:8080");
        
        // When: Execute mode detection (simulating 'ailoop ask "test"' command)
        let start = Instant::now();
        let mode = determine_operation_mode(None).unwrap();
        let elapsed = start.elapsed();
        
        // Then: System determines operation_mode = 'server'
        assert!(mode.is_server(), "Mode should be server when AILOOP_SERVER env var is set");
        assert_eq!(mode.precedence_source, PrecedenceSource::AiloopServer);
        
        // Then: System attempts WebSocket connection (URL converted correctly)
        assert!(mode.server_url.is_some(), "Server URL should be present in server mode");
        let server_url = mode.server_url.unwrap();
        assert_eq!(server_url, "ws://localhost:8080", "URL should be converted from http:// to ws://");
        
        // Then: Mode detection completes within 100ms
        assert!(elapsed.as_millis() < 100, "Mode detection took {}ms, exceeding 100ms threshold", elapsed.as_millis());
        
        // Clean up after test
        clear_env();
    }

    /// TC-REQ-003-01: Verify server mode activation with AILOOP_SERVER
    ///
    /// Given: AILOOP_SERVER=http://localhost:8080 environment variable is set
    /// When: Execute 'ailoop ask "test question"' command
    /// Then:
    ///   - System attempts WebSocket connection to ws://localhost:8080
    ///   - No local terminal prompt is displayed (mode is server, not direct)
    ///   - Message is sent via WebSocket connection (mode detection enables this)
    ///
    /// Note: This test verifies mode detection component behavior. Actual WebSocket connection
    /// and message sending are handled by other components (COMP-003, COMP-004).
    #[test]
    fn test_tc_req_003_01_server_mode_activation_with_ailoop_server() {
        // Given: AILOOP_SERVER=http://localhost:8080 environment variable is set
        clear_env();
        env::set_var("AILOOP_SERVER", "http://localhost:8080");
        
        // When: Execute mode detection (simulating 'ailoop ask "test question"' command)
        let mode = determine_operation_mode(None).unwrap();
        
        // Then: System attempts WebSocket connection to ws://localhost:8080
        assert!(mode.is_server(), "Mode should be server when AILOOP_SERVER is set");
        assert_eq!(mode.precedence_source, PrecedenceSource::AiloopServer);
        let server_url = mode.server_url.as_ref().expect("Server URL must be present in server mode");
        assert_eq!(server_url, "ws://localhost:8080", "WebSocket URL should be ws://localhost:8080");
        
        // Then: No local terminal prompt is displayed (mode is server, not direct)
        assert!(!mode.is_direct(), "Mode should not be direct when AILOOP_SERVER is set");
        
        // Then: Message is sent via WebSocket connection (mode detection enables this)
        // Note: Actual message sending is tested in integration tests. This test verifies
        // that mode detection correctly enables server mode, which allows WebSocket communication.
        assert!(mode.is_server(), "Server mode must be enabled for WebSocket message sending");
        
        // Clean up after test
        clear_env();
    }

    #[test]
    fn test_env_takes_precedence_over_flag() {
        // Ensure env is cleared before test
        clear_env();
        env::set_var("AILOOP_SERVER", "http://env-server:8080");
        let mode = determine_operation_mode(Some("http://flag-server:8080".to_string())).unwrap();
        assert!(mode.is_server(), "Mode should be server when AILOOP_SERVER env var is set");
        assert_eq!(mode.precedence_source, PrecedenceSource::AiloopServer, "AILOOP_SERVER should take precedence");
        let server_url = mode.server_url.unwrap();
        assert!(server_url.contains("env-server"), "Server URL should come from env var, not flag. Got: {}", server_url);
        // Clean up after test
        clear_env();
    }

    #[test]
    fn test_url_conversion_http_to_ws() {
        let result = convert_to_websocket_url("http://localhost:8080").unwrap();
        assert_eq!(result, "ws://localhost:8080");
    }

    #[test]
    fn test_url_conversion_https_to_wss() {
        let result = convert_to_websocket_url("https://example.com:443").unwrap();
        assert_eq!(result, "wss://example.com:443");
    }

    #[test]
    fn test_url_already_websocket() {
        let result = convert_to_websocket_url("ws://localhost:8080").unwrap();
        assert_eq!(result, "ws://localhost:8080");

        let result = convert_to_websocket_url("wss://example.com:443").unwrap();
        assert_eq!(result, "wss://example.com:443");
    }

    #[test]
    fn test_invalid_url_empty() {
        let result = convert_to_websocket_url("");
        assert!(result.is_err());
        assert!(matches!(result, Err(ModeDetectionError::InvalidServerUrl(_))));
    }

    #[test]
    fn test_invalid_url_format() {
        let result = convert_to_websocket_url("not-a-url");
        assert!(result.is_err());
        assert!(matches!(result, Err(ModeDetectionError::InvalidServerUrl(_))));
    }

    #[test]
    fn test_performance_requirement() {
        clear_env();
        let start = Instant::now();
        let _mode = determine_operation_mode(None).unwrap();
        let elapsed = start.elapsed();
        // Should complete well within 100ms
        assert!(elapsed.as_millis() < 100, "Mode detection took {}ms", elapsed.as_millis());
        // Clean up after test
        clear_env();
    }
}
</file>

<file path="src/mode/mod.rs">
//! Mode detection component (COMP-001)
//!
//! Determines whether CLI commands should operate in direct mode or server mode
//! based on command-line arguments and environment variables.
//!
//! Implements interface IF-001: DetermineOperationMode
//! Manages entity ENTITY-008: OperationMode

mod detection;
mod operation_mode;

pub use detection::determine_operation_mode;
pub use operation_mode::{OperationMode, PrecedenceSource};

use thiserror::Error;

/// Error types for mode detection
#[derive(Debug, Error)]
pub enum ModeDetectionError {
    #[error("Invalid server URL format: {0}")]
    InvalidServerUrl(String),
}
</file>

<file path="src/mode/operation_mode.rs">
//! OperationMode entity (ENTITY-008)
//!
//! Represents the determined operation mode (direct or server) for a CLI command execution.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

/// Operation mode type
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Mode {
    /// Direct mode: operate locally in terminal
    Direct,
    /// Server mode: operate via WebSocket connection
    Server,
}

/// Source that determined the operation mode
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum PrecedenceSource {
    /// AILOOP_SERVER environment variable was used
    AiloopServer,
    /// --server flag was used
    ServerFlag,
    /// Default (neither AILOOP_SERVER nor --server flag present)
    Default,
}

/// OperationMode entity (ENTITY-008)
///
/// Represents the determined operation mode with all required attributes.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OperationMode {
    /// Determined operation mode
    pub mode: Mode,
    /// Server URL to use (only present when mode is 'server')
    #[serde(skip_serializing_if = "Option::is_none")]
    pub server_url: Option<String>,
    /// Which source was used to determine mode
    pub precedence_source: PrecedenceSource,
    /// Timestamp when mode was determined
    pub determined_at: DateTime<Utc>,
}

impl OperationMode {
    /// Create a new OperationMode instance
    pub fn new(
        mode: Mode,
        server_url: Option<String>,
        precedence_source: PrecedenceSource,
    ) -> Self {
        Self {
            mode,
            server_url,
            precedence_source,
            determined_at: Utc::now(),
        }
    }

    /// Create a direct mode instance
    pub fn direct(precedence_source: PrecedenceSource) -> Self {
        Self::new(Mode::Direct, None, precedence_source)
    }

    /// Create a server mode instance
    pub fn server(server_url: String, precedence_source: PrecedenceSource) -> Self {
        Self::new(Mode::Server, Some(server_url), precedence_source)
    }

    /// Check if mode is direct
    pub fn is_direct(&self) -> bool {
        self.mode == Mode::Direct
    }

    /// Check if mode is server
    pub fn is_server(&self) -> bool {
        self.mode == Mode::Server
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_operation_mode_direct() {
        let mode = OperationMode::direct(PrecedenceSource::Default);
        assert!(mode.is_direct());
        assert!(!mode.is_server());
        assert_eq!(mode.server_url, None);
        assert_eq!(mode.precedence_source, PrecedenceSource::Default);
    }

    #[test]
    fn test_operation_mode_server() {
        let url = "ws://localhost:8080".to_string();
        let mode = OperationMode::server(url.clone(), PrecedenceSource::AiloopServer);
        assert!(!mode.is_direct());
        assert!(mode.is_server());
        assert_eq!(mode.server_url, Some(url));
        assert_eq!(mode.precedence_source, PrecedenceSource::AiloopServer);
    }

    #[test]
    fn test_operation_mode_invariants() {
        // Direct mode must not have server_url
        let direct = OperationMode::direct(PrecedenceSource::Default);
        assert_eq!(direct.server_url, None);

        // Server mode must have server_url
        let server = OperationMode::server(
            "ws://localhost:8080".to_string(),
            PrecedenceSource::ServerFlag,
        );
        assert!(server.server_url.is_some());
    }
}
</file>

<file path="src/models/authorization.rs">
//! Authorization data structures

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// Authorization decision states
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AuthorizationDecision {
    #[serde(rename = "approved")]
    Approved,
    #[serde(rename = "denied")]
    Denied,
    #[serde(rename = "timeout")]
    Timeout,
}

/// Authorization record structure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationRecord {
    /// Unique authorization identifier
    pub id: Uuid,
    /// Channel context
    pub channel: String,
    /// Description of action requiring approval
    pub action: String,
    /// AI agent identifier that requested authorization
    pub requester: String,
    /// Final decision
    pub decision: AuthorizationDecision,
    /// Human user who made the decision (if applicable)
    pub human_user: Option<String>,
    /// When authorization was requested
    pub request_timestamp: DateTime<Utc>,
    /// When decision was made
    pub decision_timestamp: DateTime<Utc>,
    /// Additional context for the decision
    pub metadata: serde_json::Value,
}

impl AuthorizationRecord {
    /// Create a new authorization request
    pub fn new(channel: String, action: String, requester: String) -> Self {
        Self {
            id: Uuid::new_v4(),
            channel,
            action,
            requester,
            decision: AuthorizationDecision::Timeout, // Will be updated
            human_user: None,
            request_timestamp: Utc::now(),
            decision_timestamp: Utc::now(),
            metadata: serde_json::Value::Object(serde_json::Map::new()),
        }
    }

    /// Record a decision
    pub fn record_decision(
        mut self,
        decision: AuthorizationDecision,
        human_user: Option<String>,
        metadata: Option<serde_json::Value>,
    ) -> Self {
        self.decision = decision;
        self.human_user = human_user;
        self.decision_timestamp = Utc::now();
        if let Some(meta) = metadata {
            self.metadata = meta;
        }
        self
    }

    /// Check if authorization is approved
    pub fn is_approved(&self) -> bool {
        matches!(self.decision, AuthorizationDecision::Approved)
    }

    /// Check if authorization is denied
    pub fn is_denied(&self) -> bool {
        matches!(self.decision, AuthorizationDecision::Denied)
    }

    /// Check if authorization timed out
    pub fn is_timeout(&self) -> bool {
        matches!(self.decision, AuthorizationDecision::Timeout)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_authorization_creation() {
        let auth = AuthorizationRecord::new(
            "admin".to_string(),
            "Deploy to production".to_string(),
            "agent-123".to_string(),
        );

        assert_eq!(auth.channel, "admin");
        assert_eq!(auth.action, "Deploy to production");
        assert_eq!(auth.requester, "agent-123");
        assert!(auth.is_timeout()); // Default state
        assert!(auth.human_user.is_none());
    }

    #[test]
    fn test_authorization_decision() {
        let auth = AuthorizationRecord::new(
            "admin".to_string(),
            "Delete database".to_string(),
            "agent-456".to_string(),
        );

        let decided_auth = auth.record_decision(
            AuthorizationDecision::Approved,
            Some("admin-user".to_string()),
            None,
        );

        assert!(decided_auth.is_approved());
        assert_eq!(decided_auth.human_user, Some("admin-user".to_string()));
    }
}
</file>

<file path="src/models/mod.rs">
//! Data models for ailoop

pub mod message;
pub mod authorization;
pub mod configuration;

pub use message::*;
pub use authorization::*;
pub use configuration::*;
</file>

<file path="src/parser/cursor.rs">
//! Cursor CLI output parser

use crate::parser::{AgentEvent, EventType, InputFormat, AgentParser};
use anyhow::{Context, Result};
use async_trait::async_trait;
use chrono::Utc;
use std::collections::HashMap;

/// Parser for Cursor CLI output formats
pub struct CursorParser {
    format: InputFormat,
}

impl CursorParser {
    /// Create a new Cursor parser
    pub fn new(format: InputFormat) -> Result<Self> {
        Ok(Self { format })
    }

    /// Parse Cursor stream-json format (NDJSON)
    fn parse_stream_json(&self, line: &str) -> Result<Option<AgentEvent>> {
        let json: serde_json::Value = serde_json::from_str(line)
            .context("Failed to parse JSON line")?;

        let event_type = self.detect_event_type(&json);
        let mut metadata = HashMap::new();

        // Extract Cursor-specific metadata
        if let Some(session_id) = json.get("session_id").and_then(|v| v.as_str()) {
            metadata.insert("session_id".to_string(), session_id.to_string());
        }
        if let Some(request_id) = json.get("request_id").and_then(|v| v.as_str()) {
            metadata.insert("request_id".to_string(), request_id.to_string());
        }

        Ok(Some(AgentEvent {
            agent_type: "cursor".to_string(),
            event_type,
            content: json,
            metadata,
            timestamp: Some(Utc::now()),
        }))
    }

    /// Parse Cursor json format (single JSON object)
    fn parse_json(&self, line: &str) -> Result<Option<AgentEvent>> {
        self.parse_stream_json(line)
    }

    /// Parse Cursor text format (plain text output)
    fn parse_text(&self, line: &str) -> Result<Option<AgentEvent>> {
        if line.trim().is_empty() {
            return Ok(None);
        }

        let content = serde_json::json!({
            "text": line,
            "format": "text"
        });

        Ok(Some(AgentEvent {
            agent_type: "cursor".to_string(),
            event_type: EventType::Assistant,
            content,
            metadata: HashMap::new(),
            timestamp: Some(Utc::now()),
        }))
    }

    /// Detect event type from Cursor JSON structure
    fn detect_event_type(&self, json: &serde_json::Value) -> EventType {
        if let Some(typ) = json.get("type").and_then(|v| v.as_str()) {
            match typ {
                "system" => EventType::System,
                "user" => EventType::User,
                "assistant" => EventType::Assistant,
                "tool_call" => EventType::ToolCall,
                "result" => EventType::Result,
                "error" => EventType::Error,
                other => EventType::Custom(other.to_string()),
            }
        } else {
            EventType::Assistant // Default for Cursor output
        }
    }
}

#[async_trait]
impl AgentParser for CursorParser {
    async fn parse_line(&mut self, line: &str) -> Result<Option<AgentEvent>> {
        match self.format {
            InputFormat::StreamJson => self.parse_stream_json(line),
            InputFormat::Json => self.parse_json(line),
            InputFormat::Text => self.parse_text(line),
        }
    }

    fn agent_type(&self) -> &str {
        "cursor"
    }

    fn supported_formats(&self) -> Vec<InputFormat> {
        vec![InputFormat::StreamJson, InputFormat::Json, InputFormat::Text]
    }
}
</file>

<file path="src/parser/jsonl.rs">
//! Generic JSONL parser for any agent output

use crate::parser::{AgentEvent, EventType, InputFormat, AgentParser};
use anyhow::{Context, Result};
use async_trait::async_trait;
use chrono::Utc;
use std::collections::HashMap;

/// Generic JSONL parser that can handle any agent output with agent_type tags
pub struct JsonlParser {
    format: InputFormat,
}

impl JsonlParser {
    /// Create a new JSONL parser
    pub fn new(format: InputFormat) -> Result<Self> {
        Ok(Self { format })
    }

    /// Parse a JSONL line with agent_type field
    fn parse_jsonl_line(&self, line: &str) -> Result<Option<AgentEvent>> {
        if line.trim().is_empty() {
            return Ok(None);
        }

        let json: serde_json::Value = serde_json::from_str(line)
            .context("Failed to parse JSONL line")?;

        // Extract agent_type (required for generic parser)
        let agent_type = json
            .get("agent_type")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string())
            .unwrap_or_else(|| "unknown".to_string());

        let event_type = self.detect_event_type(&json);
        let mut metadata = HashMap::new();

        // Extract common metadata fields
        if let Some(session_id) = json.get("session_id").and_then(|v| v.as_str()) {
            metadata.insert("session_id".to_string(), session_id.to_string());
        }
        if let Some(client_id) = json.get("client_id").and_then(|v| v.as_str()) {
            metadata.insert("client_id".to_string(), client_id.to_string());
        }
        if let Some(timestamp) = json.get("timestamp").and_then(|v| v.as_str()) {
            metadata.insert("timestamp".to_string(), timestamp.to_string());
        }

        // Extract timestamp if available
        let timestamp = json
            .get("timestamp")
            .and_then(|v| {
                chrono::DateTime::parse_from_rfc3339(v.as_str()?)
                    .ok()
                    .map(|dt| dt.with_timezone(&Utc))
            })
            .or_else(|| Some(Utc::now()));

        Ok(Some(AgentEvent {
            agent_type,
            event_type,
            content: json,
            metadata,
            timestamp,
        }))
    }

    /// Detect event type from JSON structure
    fn detect_event_type(&self, json: &serde_json::Value) -> EventType {
        if let Some(typ) = json.get("type").and_then(|v| v.as_str()) {
            match typ {
                "system" => EventType::System,
                "user" => EventType::User,
                "assistant" => EventType::Assistant,
                "tool_call" => EventType::ToolCall,
                "result" => EventType::Result,
                "error" => EventType::Error,
                other => EventType::Custom(other.to_string()),
            }
        } else {
            EventType::Assistant // Default
        }
    }
}

#[async_trait]
impl AgentParser for JsonlParser {
    async fn parse_line(&mut self, line: &str) -> Result<Option<AgentEvent>> {
        match self.format {
            InputFormat::StreamJson | InputFormat::Json => self.parse_jsonl_line(line),
            InputFormat::Text => {
                // For text format, try to parse as JSONL first, fallback to plain text
                if line.trim().starts_with('{') {
                    self.parse_jsonl_line(line)
                } else {
                    Ok(None) // Skip non-JSON lines in text mode
                }
            }
        }
    }

    fn agent_type(&self) -> &str {
        "jsonl"
    }

    fn supported_formats(&self) -> Vec<InputFormat> {
        vec![InputFormat::StreamJson, InputFormat::Json]
    }
}
</file>

<file path="src/parser/mod.rs">
//! Agent event parser system
//!
//! This module provides an extensible parser system for converting agent output
//! (from Cursor CLI, Claude, GPT, etc.) into standardized AgentEvent structures
//! that can then be converted to ailoop Messages.

use anyhow::Result;
use async_trait::async_trait;
use chrono::{DateTime, Utc};
use std::collections::HashMap;

/// Input format types supported by parsers
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum InputFormat {
    Json,
    StreamJson, // NDJSON (newline-delimited JSON)
    Text,
}

/// Event type classification
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum EventType {
    System,
    User,
    Assistant,
    ToolCall,
    Result,
    Error,
    Custom(String),
}

/// Unified agent event structure
#[derive(Debug, Clone)]
pub struct AgentEvent {
    /// Agent type identifier (e.g., "cursor", "claude", "gpt")
    pub agent_type: String,
    /// Event type classification
    pub event_type: EventType,
    /// Agent-specific event data (preserved as JSON)
    pub content: serde_json::Value,
    /// Additional metadata (tags, session_id, request_id, etc.)
    pub metadata: HashMap<String, String>,
    /// Event timestamp (if available from agent)
    pub timestamp: Option<DateTime<Utc>>,
}

/// Parser trait for agent output
#[async_trait]
pub trait AgentParser: Send + Sync {
    /// Parse a single line/event from agent output
    ///
    /// Returns `Ok(Some(event))` if a valid event was parsed,
    /// `Ok(None)` if the line should be skipped (e.g., empty or comment),
    /// or `Err` if parsing failed and should be logged.
    async fn parse_line(&mut self, line: &str) -> Result<Option<AgentEvent>>;

    /// Get agent type identifier
    fn agent_type(&self) -> &str;

    /// Get supported input formats
    fn supported_formats(&self) -> Vec<InputFormat>;
}

/// Create a parser instance based on agent type and format
///
/// If `agent_type` is `None`, attempts to auto-detect from the format.
pub fn create_parser(
    agent_type: Option<String>,
    format: InputFormat,
) -> Result<Box<dyn AgentParser>> {
    match agent_type.as_deref() {
        Some("cursor") => {
            crate::parser::cursor::CursorParser::new(format)
                .map(|p| Box::new(p) as Box<dyn AgentParser>)
        }
        Some("jsonl") | None => {
            crate::parser::jsonl::JsonlParser::new(format)
                .map(|p| Box::new(p) as Box<dyn AgentParser>)
        }
        _ => anyhow::bail!("Unknown agent type: {:?}", agent_type),
    }
}

pub mod cursor;
pub mod jsonl;
</file>

<file path="src/server/broadcast.rs">
//! Broadcast manager for WebSocket viewer connections

use crate::models::Message;
use std::collections::{HashMap, HashSet};
use std::sync::Arc;
use tokio::sync::RwLock;
use tokio_tungstenite::tungstenite::Message as WsMessage;
use uuid::Uuid;

/// Connection type for WebSocket clients
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ConnectionType {
    Agent,
    Viewer,
}

/// Viewer connection information
#[derive(Debug, Clone)]
pub struct ViewerConnection {
    pub id: Uuid,
    pub connection_type: ConnectionType,
    pub subscribed_channels: HashSet<String>,
    pub sender: tokio::sync::mpsc::UnboundedSender<WsMessage>,
}

/// Broadcast manager for handling viewer connections and message distribution
#[derive(Clone)]
pub struct BroadcastManager {
    /// Active viewer connections: connection_id -> ViewerConnection
    viewers: Arc<RwLock<HashMap<Uuid, ViewerConnection>>>,
    /// Channel subscriptions: channel -> set of connection_ids
    channel_subscriptions: Arc<RwLock<HashMap<String, HashSet<Uuid>>>>,
}

impl BroadcastManager {
    /// Create a new broadcast manager
    pub fn new() -> Self {
        Self {
            viewers: Arc::new(RwLock::new(HashMap::new())),
            channel_subscriptions: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// Add a new viewer connection
    pub async fn add_viewer(
        &self,
        connection_type: ConnectionType,
        sender: tokio::sync::mpsc::UnboundedSender<WsMessage>,
    ) -> Uuid {
        let connection_id = Uuid::new_v4();
        let viewer = ViewerConnection {
            id: connection_id,
            connection_type,
            subscribed_channels: HashSet::new(),
            sender,
        };

        self.viewers.write().await.insert(connection_id, viewer);
        connection_id
    }

    /// Remove a viewer connection
    pub async fn remove_viewer(&self, connection_id: &Uuid) {
        // Get the viewer before removing
        if let Some(viewer) = self.viewers.write().await.remove(connection_id) {
            // Remove from all channel subscriptions
            let mut channel_subs = self.channel_subscriptions.write().await;
            for channel in &viewer.subscribed_channels {
                if let Some(subscribers) = channel_subs.get_mut(channel) {
                    subscribers.remove(connection_id);
                    // Clean up empty channel subscriptions
                    if subscribers.is_empty() {
                        channel_subs.remove(channel);
                    }
                }
            }
        }
    }

    /// Subscribe a viewer to a channel
    pub async fn subscribe_to_channel(&self, connection_id: &Uuid, channel: &str) -> Result<(), String> {
        let mut viewers = self.viewers.write().await;
        let viewer = viewers.get_mut(connection_id)
            .ok_or_else(|| format!("Viewer {} not found", connection_id))?;

        viewer.subscribed_channels.insert(channel.to_string());

        // Add to channel subscriptions
        let mut channel_subs = self.channel_subscriptions.write().await;
        channel_subs.entry(channel.to_string())
            .or_insert_with(HashSet::new)
            .insert(*connection_id);

        Ok(())
    }

    /// Unsubscribe a viewer from a channel
    pub async fn unsubscribe_from_channel(&self, connection_id: &Uuid, channel: &str) -> Result<(), String> {
        let mut viewers = self.viewers.write().await;
        let viewer = viewers.get_mut(connection_id)
            .ok_or_else(|| format!("Viewer {} not found", connection_id))?;

        viewer.subscribed_channels.remove(channel);

        // Remove from channel subscriptions
        let mut channel_subs = self.channel_subscriptions.write().await;
        if let Some(subscribers) = channel_subs.get_mut(channel) {
            subscribers.remove(connection_id);
            // Clean up empty channel subscriptions
            if subscribers.is_empty() {
                channel_subs.remove(channel);
            }
        }

        Ok(())
    }

    /// Subscribe a viewer to all channels
    pub async fn subscribe_to_all(&self, connection_id: &Uuid) -> Result<(), String> {
        let mut viewers = self.viewers.write().await;
        let viewer = viewers.get_mut(connection_id)
            .ok_or_else(|| format!("Viewer {} not found", connection_id))?;

        // Get all available channels (this would come from message history)
        // For now, we'll add a special marker for "all channels"
        viewer.subscribed_channels.insert("*".to_string());

        Ok(())
    }

    /// Broadcast a message to all subscribed viewers
    pub async fn broadcast_message(&self, message: &Message) {
        let channel = &message.channel;

        // Prepare JSON message
        let json_message = match serde_json::to_string(message) {
            Ok(json) => json,
            Err(e) => {
                eprintln!("Failed to serialize message for broadcast: {}", e);
                return;
            }
        };

        let ws_message = WsMessage::Text(json_message);

        // Get subscribers for this channel (and viewers subscribed to all channels)
        let mut all_subscribers = {
            let channel_subs = self.channel_subscriptions.read().await;
            channel_subs.get(channel).cloned().unwrap_or_default()
        };

        // Add viewers subscribed to all channels ("*")
        if let Some(all_channel_subs) = self.channel_subscriptions.read().await.get("*") {
            all_subscribers.extend(all_channel_subs);
        }

        // Send to all subscribers
        let viewers = self.viewers.read().await;
        for connection_id in all_subscribers {
            if let Some(viewer) = viewers.get(&connection_id) {
                if let Err(e) = viewer.sender.send(ws_message.clone()) {
                    eprintln!("Failed to send message to viewer {}: {}", connection_id, e);
                    // Note: In a real implementation, we might want to remove disconnected viewers
                }
            }
        }
    }

    /// Get statistics about viewer connections
    pub async fn get_stats(&self) -> BroadcastStats {
        let viewers = self.viewers.read().await;
        let channel_subs = self.channel_subscriptions.read().await;

        let total_viewers = viewers.len();
        let agent_connections = viewers.values()
            .filter(|v| matches!(v.connection_type, ConnectionType::Agent))
            .count();
        let viewer_connections = total_viewers - agent_connections;
        let active_channels = channel_subs.len();

        BroadcastStats {
            total_viewers,
            agent_connections,
            viewer_connections,
            active_channels,
        }
    }

    /// Get all channels with active subscriptions
    pub async fn get_active_channels(&self) -> Vec<String> {
        let channel_subs = self.channel_subscriptions.read().await;
        channel_subs.keys().cloned().collect()
    }
}

impl Default for BroadcastManager {
    fn default() -> Self {
        Self::new()
    }
}

/// Statistics about broadcast manager state
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BroadcastStats {
    pub total_viewers: usize,
    pub agent_connections: usize,
    pub viewer_connections: usize,
    pub active_channels: usize,
}

use serde::{Deserialize, Serialize};
</file>

<file path="src/server/history.rs">
//! Message history storage with per-channel FIFO eviction

use crate::models::Message;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;

/// Maximum number of messages to store per channel
const MAX_MESSAGES_PER_CHANNEL: usize = 1000;

/// Message history storage with per-channel FIFO eviction
#[derive(Clone)]
pub struct MessageHistory {
    inner: Arc<RwLock<HashMap<String, VecDeque<Message>>>>,
}

impl MessageHistory {
    /// Create a new message history
    pub fn new() -> Self {
        Self {
            inner: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// Add a message to the history for a channel
    pub async fn add_message(&self, channel: &str, message: Message) {
        let mut history = self.inner.write().await;
        let channel_messages = history.entry(channel.to_string()).or_insert_with(VecDeque::new);

        // Add message
        channel_messages.push_back(message);

        // Evict oldest messages if limit exceeded (FIFO)
        while channel_messages.len() > MAX_MESSAGES_PER_CHANNEL {
            channel_messages.pop_front();
        }
    }

    /// Get recent messages for a channel
    pub async fn get_messages(&self, channel: &str, limit: Option<usize>) -> Vec<Message> {
        let history = self.inner.read().await;
        if let Some(messages) = history.get(channel) {
            let limit = limit.unwrap_or(MAX_MESSAGES_PER_CHANNEL);
            messages
                .iter()
                .rev()
                .take(limit)
                .rev()
                .cloned()
                .collect()
        } else {
            vec![]
        }
    }

    /// Get all channels with messages
    pub async fn get_channels(&self) -> Vec<String> {
        let history = self.inner.read().await;
        history.keys().cloned().collect()
    }

    /// Get message count for a channel
    pub async fn get_message_count(&self, channel: &str) -> usize {
        let history = self.inner.read().await;
        history.get(channel).map(|v| v.len()).unwrap_or(0)
    }

    /// Get statistics for a channel
    pub async fn get_channel_stats(&self, channel: &str) -> ChannelStats {
        let history = self.inner.read().await;
        if let Some(messages) = history.get(channel) {
            ChannelStats {
                channel: channel.to_string(),
                message_count: messages.len(),
                oldest_message: messages.front().map(|m| m.timestamp),
                newest_message: messages.back().map(|m| m.timestamp),
            }
        } else {
            ChannelStats {
                channel: channel.to_string(),
                message_count: 0,
                oldest_message: None,
                newest_message: None,
            }
        }
    }
}

impl Default for MessageHistory {
    fn default() -> Self {
        Self::new()
    }
}

/// Statistics for a channel
#[derive(Debug, Clone)]
pub struct ChannelStats {
    pub channel: String,
    pub message_count: usize,
    pub oldest_message: Option<chrono::DateTime<chrono::Utc>>,
    pub newest_message: Option<chrono::DateTime<chrono::Utc>>,
}

use std::collections::VecDeque;
</file>

<file path="src/server/queue.rs">
//! Message queuing system

use crate::models::Message;
use std::collections::VecDeque;

/// Message queue for handling incoming messages
pub struct MessageQueue {
    queue: VecDeque<Message>,
    max_size: usize,
}

impl MessageQueue {
    /// Create a new message queue with maximum size
    pub fn new(max_size: usize) -> Self {
        Self {
            queue: VecDeque::new(),
            max_size,
        }
    }

    /// Add a message to the queue
    pub fn enqueue(&mut self, message: Message) {
        // If queue is full, remove oldest message
        if self.queue.len() >= self.max_size {
            self.queue.pop_front();
        }
        self.queue.push_back(message);
    }

    /// Remove and return the next message from the queue
    pub fn dequeue(&mut self) -> Option<Message> {
        self.queue.pop_front()
    }

    /// Check if the queue is empty
    pub fn is_empty(&self) -> bool {
        self.queue.is_empty()
    }

    /// Get the current queue size
    pub fn len(&self) -> usize {
        self.queue.len()
    }

    /// Clear all messages from the queue
    pub fn clear(&mut self) {
        self.queue.clear();
    }
}

impl Default for MessageQueue {
    fn default() -> Self {
        Self::new(1000) // Default max size of 1000 messages
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::models::{Message, SenderType, MessageContent};

    #[test]
    fn test_message_queue_creation() {
        let queue = MessageQueue::new(100);
        assert!(queue.is_empty());
        assert_eq!(queue.len(), 0);
    }

    #[test]
    fn test_message_enqueue_dequeue() {
        let mut queue = MessageQueue::new(10);

        let content = MessageContent::Question {
            text: "Test question".to_string(),
            timeout_seconds: 30,
        };

        let message = Message::new("test-channel".to_string(), SenderType::Agent, content);

        queue.enqueue(message.clone());
        assert_eq!(queue.len(), 1);
        assert!(!queue.is_empty());

        let dequeued = queue.dequeue();
        assert!(dequeued.is_some());
        assert_eq!(dequeued.unwrap().channel, message.channel);
        assert!(queue.is_empty());
    }

    #[test]
    fn test_message_queue_max_size() {
        let mut queue = MessageQueue::new(2);

        let content = MessageContent::Question {
            text: "Test question".to_string(),
            timeout_seconds: 30,
        };

        // Add 3 messages to a queue with max size 2
        for i in 0..3 {
            let mut message = Message::new(
                format!("channel-{}", i),
                SenderType::Agent,
                content.clone(),
            );
            queue.enqueue(message);
        }

        // Should only have 2 messages (oldest removed)
        assert_eq!(queue.len(), 2);

        // First dequeued should be the second message (oldest remaining)
        let first = queue.dequeue();
        assert!(first.is_some());
        assert_eq!(first.unwrap().channel, "channel-1");
    }
}
</file>

<file path="src/server/websocket.rs">
//! WebSocket server implementation

use tokio::net::TcpListener;
use tokio_tungstenite::accept_async;
use futures_util::stream::StreamExt;
use std::net::SocketAddr;

/// WebSocket server for handling ailoop connections
pub struct WebSocketServer {
    address: SocketAddr,
}

impl WebSocketServer {
    /// Create a new WebSocket server
    pub fn new(host: &str, port: u16) -> Result<Self, Box<dyn std::error::Error>> {
        let address = format!("{}:{}", host, port).parse()?;
        Ok(Self { address })
    }

    /// Start the WebSocket server
    pub async fn start(self) -> Result<(), Box<dyn std::error::Error>> {
        let listener = TcpListener::bind(self.address).await?;
        println!("WebSocket server listening on {}", self.address);

        while let Ok((stream, addr)) = listener.accept().await {
            tokio::spawn(async move {
                println!("New connection from: {}", addr);

                match accept_async(stream).await {
                    Ok(ws_stream) => {
                        println!("WebSocket connection established with {}", addr);

                        let (_write, mut read) = ws_stream.split();

                        // For now, just echo back messages
                        while let Some(message) = read.next().await {
                            match message {
                                Ok(msg) => {
                                    println!("Received message: {:?}", msg);
                                }
                                Err(e) => {
                                    println!("Error receiving message: {}", e);
                                    break;
                                }
                            }
                        }
                    }
                    Err(e) => {
                        println!("WebSocket handshake failed: {}", e);
                    }
                }
            });
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_websocket_server_creation() {
        let server = WebSocketServer::new("127.0.0.1", 8080);
        assert!(server.is_ok());
    }

    #[test]
    fn test_websocket_server_address() {
        let server = WebSocketServer::new("127.0.0.1", 8080).unwrap();
        assert_eq!(server.address.to_string(), "127.0.0.1:8080");
    }
}
</file>

<file path="src/services/interaction.rs">
//! Human interaction handling services

use crate::models::*;
use crate::channel::ChannelIsolation;
use crate::services::logging;
use anyhow::Result;

/// Human interaction service for handling questions and authorizations
pub struct InteractionService {
    channel_isolation: ChannelIsolation,
}

impl InteractionService {
    /// Create a new interaction service
    pub fn new(channel_isolation: ChannelIsolation) -> Self {
        Self { channel_isolation }
    }

    /// Handle a question interaction
    pub async fn handle_question(
        &self,
        question: String,
        channel: String,
        timeout_seconds: u32,
    ) -> Result<String> {
        logging::log_interaction("question_start", &channel, Some(&question));

        // Create question message
        let content = MessageContent::Question {
            text: question.clone(),
            timeout_seconds,
        };

        let message = Message::new(channel.clone(), SenderType::Agent, content);

        // Queue the message
        self.channel_isolation.enqueue_message(&channel, message);

        // For now, return a placeholder response
        // In a real implementation, this would wait for human response
        let response = format!("Question '{}' queued for channel '{}'. Awaiting human response...", question, channel);

        logging::log_interaction("question_queued", &channel, Some(&response));

        Ok(response)
    }

    /// Handle an authorization interaction
    pub async fn handle_authorization(
        &self,
        action: String,
        channel: String,
        timeout_seconds: u32,
    ) -> Result<String> {
        logging::log_interaction("authorization_start", &channel, Some(&action));

        // Create authorization message
        let content = MessageContent::Authorization {
            action: action.clone(),
            context: None,
            timeout_seconds,
        };

        let message = Message::new(channel.clone(), SenderType::Agent, content);

        // Queue the message
        self.channel_isolation.enqueue_message(&channel, message);

        // For now, return a placeholder response
        // In a real implementation, this would wait for human approval
        let response = format!("Authorization request for '{}' queued for channel '{}'. Awaiting human approval...", action, channel);

        logging::log_interaction("authorization_queued", &channel, Some(&response));

        Ok(response)
    }

    /// Handle a notification
    pub fn handle_notification(
        &self,
        message: String,
        channel: String,
        priority: String,
    ) -> Result<String> {
        logging::log_interaction("notification_send", &channel, Some(&message));

        // Create notification message
        let content = MessageContent::Notification {
            text: message.clone(),
            priority: match priority.as_str() {
                "low" => NotificationPriority::Low,
                "high" => NotificationPriority::High,
                "urgent" => NotificationPriority::Urgent,
                _ => NotificationPriority::Normal,
            },
        };

        let msg = Message::new(channel.clone(), SenderType::Agent, content);

        // Queue the message
        self.channel_isolation.enqueue_message(&channel, msg);

        let response = format!("Notification '{}' sent to channel '{}' with {} priority.",
                              message, channel, priority);

        Ok(response)
    }

    /// Get channel statistics
    pub fn get_channel_stats(&self, channel: &str) -> (usize, usize) {
        let queue_size = self.channel_isolation.get_queue_size(channel);
        let connections = self.channel_isolation.get_connection_count(channel);
        (queue_size, connections)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::channel::ChannelIsolation;

    #[tokio::test]
    async fn test_question_handling() {
        let isolation = ChannelIsolation::default();
        let service = InteractionService::new(isolation);

        let result = service.handle_question(
            "Test question".to_string(),
            "test-channel".to_string(),
            60,
        ).await;

        assert!(result.is_ok());
        let response = result.unwrap();
        assert!(response.contains("Test question"));
        assert!(response.contains("test-channel"));
    }

    #[tokio::test]
    async fn test_authorization_handling() {
        let isolation = ChannelIsolation::default();
        let service = InteractionService::new(isolation);

        let result = service.handle_authorization(
            "Deploy to production".to_string(),
            "admin-channel".to_string(),
            300,
        ).await;

        assert!(result.is_ok());
        let response = result.unwrap();
        assert!(response.contains("Deploy to production"));
        assert!(response.contains("admin-channel"));
    }

    #[test]
    fn test_notification_handling() {
        let isolation = ChannelIsolation::default();
        let service = InteractionService::new(isolation);

        let result = service.handle_notification(
            "Build completed".to_string(),
            "team-channel".to_string(),
            "high".to_string(),
        );

        assert!(result.is_ok());
        let response = result.unwrap();
        assert!(response.contains("Build completed"));
        assert!(response.contains("team-channel"));
        assert!(response.contains("high"));
    }

    #[test]
    fn test_channel_stats() {
        let isolation = ChannelIsolation::default();
        let service = InteractionService::new(isolation);

        let (queue_size, connections) = service.get_channel_stats("nonexistent");
        assert_eq!(queue_size, 0);
        assert_eq!(connections, 0);
    }
}
</file>

<file path="src/services/logging.rs">
//! Logging service

use crate::models::LogLevel;

/// Initialize logging with the specified level
pub fn init_logging(level: LogLevel) -> Result<(), Box<dyn std::error::Error>> {
    let filter = match level {
        LogLevel::Error => "ailoop=error",
        LogLevel::Warn => "ailoop=warn",
        LogLevel::Info => "ailoop=info",
        LogLevel::Debug => "ailoop=debug",
        LogLevel::Trace => "ailoop=trace",
    };

    tracing_subscriber::fmt()
        .with_env_filter(filter)
        .with_writer(std::io::stderr)
        .init();

    Ok(())
}

/// Log an interaction event
pub fn log_interaction(
    event_type: &str,
    channel: &str,
    details: Option<&str>,
) {
    tracing::info!(
        event_type = event_type,
        channel = channel,
        details = details.unwrap_or(""),
        "Interaction logged"
    );
}

/// Log a security event (always logged regardless of level)
pub fn log_security_event(
    event_type: &str,
    channel: &str,
    user: Option<&str>,
    details: &str,
) {
    tracing::warn!(
        event_type = event_type,
        channel = channel,
        user = user.unwrap_or("unknown"),
        details = details,
        "Security event"
    );
}

/// Log a system error
pub fn log_error(error: &str, context: Option<&str>) {
    tracing::error!(
        error = error,
        context = context.unwrap_or(""),
        "System error occurred"
    );
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::Once;

    static INIT: Once = Once::new();

    fn init_test_logging() {
        INIT.call_once(|| {
            let _ = init_logging(LogLevel::Info);
        });
    }

    #[test]
    fn test_logging_initialization() {
        // Just test that initialization doesn't panic
        let _ = init_logging(LogLevel::Info);
    }

    #[test]
    fn test_log_functions() {
        init_test_logging();

        // These should not panic
        log_interaction("test", "test-channel", Some("test details"));
        log_security_event("test", "test-channel", Some("test-user"), "test details");
        log_error("test error", Some("test context"));
    }
}
</file>

<file path="src/services/mod.rs">
//! Business logic services

pub mod interaction;
pub mod logging;

pub use logging::*;
</file>

<file path="src/transport/factory.rs">
//! Transport factory for creating transport instances

use crate::transport::{file::FileTransport, websocket::WebSocketTransport, Transport};
use anyhow::{Context, Result};

/// Transport type identifier
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum TransportType {
    WebSocket,
    File,
}

/// Configuration for creating a transport
#[derive(Debug, Clone)]
pub struct TransportConfig {
    pub transport_type: TransportType,
    pub url: Option<String>,
    pub file_path: Option<String>,
    pub channel: String,
    pub client_id: Option<String>,
}

/// Create a transport instance based on configuration
pub fn create_transport(config: TransportConfig) -> Result<Box<dyn Transport>> {
    match config.transport_type {
        TransportType::WebSocket => {
            let url = config.url.context("WebSocket transport requires URL")?;
            Ok(Box::new(WebSocketTransport::new(
                url,
                config.channel,
                config.client_id,
            )?))
        }
        TransportType::File => {
            let file_path = config
                .file_path
                .context("File transport requires file path")?;
            Ok(Box::new(FileTransport::new(file_path, config.channel)?))
        }
    }
}
</file>

<file path="src/transport/file.rs">
//! File transport implementation for testing and output

use crate::models::Message;
use crate::transport::Transport;
use anyhow::{Context, Result};
use async_trait::async_trait;
use std::fs::OpenOptions;
use std::io::Write;
use std::path::PathBuf;

/// File transport for writing messages to a file (useful for testing and debugging)
pub struct FileTransport {
    file_path: PathBuf,
    channel: String,
    file: Option<std::fs::File>,
}

impl FileTransport {
    /// Create a new file transport
    pub fn new(file_path: impl Into<PathBuf>, channel: String) -> Result<Self> {
        let path = file_path.into();
        Ok(Self {
            file_path: path,
            channel,
            file: None,
        })
    }

    /// Open or get the file handle
    fn get_file(&mut self) -> Result<&mut std::fs::File> {
        if self.file.is_none() {
            let file = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.file_path)
                .with_context(|| format!("Failed to open file: {:?}", self.file_path))?;
            self.file = Some(file);
        }
        Ok(self.file.as_mut().unwrap())
    }
}

#[async_trait]
impl Transport for FileTransport {
    async fn send(&mut self, message: Message) -> Result<()> {
        let json = serde_json::to_string(&message)
            .context("Failed to serialize message")?;
        
        let file_path = self.file_path.clone();
        let file = self.get_file()?;
        writeln!(file, "{}", json)
            .with_context(|| format!("Failed to write to file: {:?}", file_path))?;
        
        file.flush()
            .with_context(|| format!("Failed to flush file: {:?}", file_path))?;
        
        Ok(())
    }

    async fn flush(&mut self) -> Result<()> {
        if let Some(file) = &mut self.file {
            file.flush()
                .with_context(|| format!("Failed to flush file: {:?}", self.file_path))?;
        }
        Ok(())
    }

    async fn close(&mut self) -> Result<()> {
        self.flush().await?;
        self.file = None;
        Ok(())
    }

    fn name(&self) -> &str {
        "file"
    }
}
</file>

<file path="src/transport/mod.rs">
//! Transport abstraction for message delivery
//!
//! This module provides a trait-based transport system that allows messages
//! to be sent through various mechanisms (WebSocket, file, Kafka, Redis, etc.)
//! without the message converter needing to know implementation details.

use crate::models::Message;
use anyhow::Result;
use async_trait::async_trait;

/// Abstract transport interface for message delivery
#[async_trait]
pub trait Transport: Send + Sync {
    /// Send a message through the transport
    async fn send(&mut self, message: Message) -> Result<()>;

    /// Flush any buffered messages
    async fn flush(&mut self) -> Result<()>;

    /// Close the transport connection
    async fn close(&mut self) -> Result<()>;

    /// Get transport name for logging
    fn name(&self) -> &str;
}

pub mod factory;
pub mod file;
pub mod websocket;
</file>

<file path="src/transport/websocket.rs">
//! WebSocket transport implementation

use crate::models::Message;
use crate::transport::Transport;
use anyhow::{Context, Result};
use async_trait::async_trait;
use futures_util::SinkExt;
use std::collections::VecDeque;
use tokio::sync::Mutex;
use tokio_tungstenite::{connect_async, tungstenite::Message as WsMessage, WebSocketStream};
use url::Url;

/// WebSocket transport for sending messages to ailoop server
pub struct WebSocketTransport {
    url: String,
    channel: String,
    client_id: Option<String>,
    connection: Option<Mutex<WebSocketStream<tokio_tungstenite::MaybeTlsStream<tokio::net::TcpStream>>>>,
    buffer: VecDeque<Message>,
    max_buffer_size: usize,
}

impl WebSocketTransport {
    /// Create a new WebSocket transport
    pub fn new(url: String, channel: String, client_id: Option<String>) -> Result<Self> {
        Ok(Self {
            url,
            channel,
            client_id,
            connection: None,
            buffer: VecDeque::new(),
            max_buffer_size: 1000,
        })
    }

    /// Connect to the WebSocket server with retry logic and exponential backoff
    async fn connect_with_retry(&mut self) -> Result<()> {
        const MAX_RETRIES: u32 = 5;
        const INITIAL_DELAY_MS: u64 = 100;
        const MAX_DELAY_MS: u64 = 10000;
        const MAX_TIMEOUT_MS: u64 = 30000; // 30 seconds total timeout

        let url = Url::parse(&self.url)
            .with_context(|| format!("Invalid WebSocket URL: {}", self.url))?;

        let start_time = std::time::Instant::now();
        let mut delay = INITIAL_DELAY_MS;

        for attempt in 0..MAX_RETRIES {
            // Check if we've exceeded the maximum timeout
            if start_time.elapsed().as_millis() as u64 > MAX_TIMEOUT_MS {
                return Err(anyhow::anyhow!(
                    "Connection timeout: Failed to connect within {}ms",
                    MAX_TIMEOUT_MS
                ));
            }

            // Try to connect
            match connect_async(url.clone()).await {
                Ok((ws_stream, _)) => {
                    self.connection = Some(Mutex::new(ws_stream));
                    return Ok(());
                }
                Err(e) => {
                    if attempt == MAX_RETRIES - 1 {
                        // Last attempt failed
                        return Err(anyhow::anyhow!(
                            "Failed to connect after {} attempts: {}",
                            MAX_RETRIES,
                            e
                        ));
                    }
                    // Wait with exponential backoff before retrying
                    tokio::time::sleep(tokio::time::Duration::from_millis(delay)).await;
                    delay = std::cmp::min(delay * 2, MAX_DELAY_MS);
                }
            }
        }

        Err(anyhow::anyhow!("Failed to connect to WebSocket: {}", self.url))
    }

    /// Send buffered messages when connection is restored
    async fn flush_buffer(&mut self) -> Result<()> {
        // Try to reconnect if not connected
        if self.connection.is_none() && !self.buffer.is_empty() {
            if let Err(e) = self.connect_with_retry().await {
                // If reconnection fails, keep messages in buffer
                return Err(anyhow::anyhow!(
                    "Failed to reconnect, {} messages still buffered: {}",
                    self.buffer.len(),
                    e
                ));
            }
        }

        // Send all buffered messages
        while let Some(message) = self.buffer.pop_front() {
            match self.send_internal(message.clone()).await {
                Ok(()) => {
                    // Message sent successfully, continue
                }
                Err(e) => {
                    // Connection lost again, put message back and stop
                    self.connection = None;
                    self.buffer.push_front(message);
                    return Err(anyhow::anyhow!(
                        "Connection lost while flushing buffer: {}",
                        e
                    ));
                }
            }
        }

        Ok(())
    }

    /// Internal send method
    async fn send_internal(&mut self, message: Message) -> Result<()> {
        if self.connection.is_none() {
            self.connect_with_retry().await?;
        }

        let conn = self.connection.as_mut().unwrap();
        let mut stream = conn.lock().await;

        let json = serde_json::to_string(&message)
            .context("Failed to serialize message")?;

        stream
            .send(WsMessage::Text(json))
            .await
            .context("Failed to send message over WebSocket")?;

        Ok(())
    }
}

#[async_trait]
impl Transport for WebSocketTransport {
    async fn send(&mut self, message: Message) -> Result<()> {
        if self.connection.is_none() {
            // Try to connect, but buffer if connection fails
            if let Err(e) = self.connect_with_retry().await {
                // Buffer message for later delivery
                if self.buffer.len() >= self.max_buffer_size {
                    self.buffer.pop_front(); // FIFO eviction
                }
                self.buffer.push_back(message);
                return Err(e);
            }
        }

        // Try to send, buffer if connection lost
        match self.send_internal(message.clone()).await {
            Ok(()) => Ok(()),
            Err(e) => {
                // Connection lost, buffer message
                self.connection = None;
                if self.buffer.len() >= self.max_buffer_size {
                    self.buffer.pop_front();
                }
                self.buffer.push_back(message);
                Err(e)
            }
        }
    }

    async fn flush(&mut self) -> Result<()> {
        self.flush_buffer().await
    }

    async fn close(&mut self) -> Result<()> {
        if let Some(conn) = self.connection.take() {
            let mut stream = conn.lock().await;
            stream.close(None).await.context("Failed to close WebSocket")?;
        }
        Ok(())
    }

    fn name(&self) -> &str {
        "websocket"
    }
}
</file>

<file path=".gitignore">
# Rust build artifacts
/target/
**/*.rs.bk
*.pdb
Cargo.lock

# IDE files
.idea/
.vscode/
*.swp
*.swo
*~

# OS files
.DS_Store
Thumbs.db
*.tmp

# Logs
*.log
.env*

# Test coverage
coverage/
*.profraw

# ailoop specific
.ailoop/
*.toml.bak

**specify-rules.mdc
</file>

<file path=".repomixignore">
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/
.requirements
.specify
.cursor
.repomix
specs
LICENSE
*.md
</file>

<file path="repomix.config.json">
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 52428800
  },
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "compress": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "truncateBase64": false,
    "copyToClipboard": false,
    "includeFullDirectoryStructure": false,
    "tokenCountTree": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false,
      "includeLogs": false,
      "includeLogsCount": 50
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDotIgnore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
</file>

<file path="rustfmt.toml">
# rustfmt configuration for ailoop
# Constitution requirement: 100-character line limits

max_width = 100
hard_tabs = false
tab_spaces = 4
newline_style = "Unix"
use_small_heuristics = "Default"
indent_style = "Block"
width_heuristics = "Scaled"
single_line_if_else_max_width = 50
fn_args_layout = "Tall"
fn_params_layout = "Tall"
fn_single_line = false
where_single_line = false
struct_lit_single_line = false
array_width = 60
chain_width = 60
single_line_let_else_max_width = 50
reorder_impl_items = false
reorder_imports = true
remove_nested_parens = true
normalize_comments = true
format_code_in_doc_comments = true
format_strings = true
empty_item_single_line = true
imports_granularity = "Module"
imports_indent = "Block"
imports_layout = "Mixed"
group_imports = "StdExternalCrate"
use_field_init_shorthand = true
use_try_shorthand = true
use_await_macro = true
use_block_indent = true
</file>

<file path="src/channel/validation.rs">
//! Channel name validation component (COMP-007)
//!
//! Implements interface IF-018: ValidateChannelName
//! Manages entity ENTITY-004: Channel
//!
//! Validates channel names according to validation rules that must be identical
//! in both direct and server modes (REQ-020, REQ-033).

use thiserror::Error;

/// Errors that can occur during channel validation
#[derive(Error, Debug)]
pub enum ChannelValidationError {
    #[error("Channel name is empty")]
    Empty,

    #[error("Channel name is too long (max 64 characters)")]
    TooLong,

    #[error("Channel name must start with a letter or number")]
    InvalidStart,

    #[error("Channel name contains invalid characters (only letters, numbers, hyphens, and underscores allowed)")]
    InvalidCharacters,

    #[error("Channel name is reserved: {0}")]
    ReservedName(String),
}

/// Reserved channel names that cannot be used
const RESERVED_NAMES: &[&str] = &[
    "system",
    "admin",
    "internal",
    "reserved",
    "ailoop",
];

/// Validate a channel name according to the naming convention
pub fn validate_channel_name(name: &str) -> Result<(), ChannelValidationError> {
    // Check if empty
    if name.is_empty() {
        return Err(ChannelValidationError::Empty);
    }

    // Check length
    if name.len() > 64 {
        return Err(ChannelValidationError::TooLong);
    }

    // Check first character
    let first_char = name.chars().next().unwrap();
    if !first_char.is_ascii_alphabetic() && !first_char.is_ascii_digit() {
        return Err(ChannelValidationError::InvalidStart);
    }

    // Check for reserved names
    if RESERVED_NAMES.contains(&name.to_lowercase().as_str()) {
        return Err(ChannelValidationError::ReservedName(name.to_string()));
    }

    // Check all characters are valid
    for ch in name.chars() {
        if !ch.is_ascii_alphabetic() && !ch.is_ascii_digit() && ch != '-' && ch != '_' {
            return Err(ChannelValidationError::InvalidCharacters);
        }
    }

    Ok(())
}

/// Check if a channel name is valid (convenience function)
pub fn is_valid_channel_name(name: &str) -> bool {
    validate_channel_name(name).is_ok()
}

/// Channel validation result matching IF-018 interface contract
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ChannelValidationResult {
    /// Whether channel name is valid
    pub valid: bool,
    /// Error message if validation failed (None if valid)
    pub error_message: Option<String>,
}

/// Validate channel name according to IF-018 interface contract
///
/// Implements interface IF-018: ValidateChannelName
///
/// # Arguments
/// * `channel_name` - Channel name to validate
///
/// # Returns
/// * `ChannelValidationResult` with `valid` boolean and optional `error_message`
///
/// # Behavior
/// - Applies same validation rules regardless of operation mode (REQ-020, REQ-033)
/// - Idempotent: same channel name always returns same result
/// - Returns INVALID_CHANNEL error code (via error_message) when validation fails
///
/// # Validation Rules
/// - Channel name must not be empty
/// - Channel name must be <= 64 characters
/// - Channel name must start with letter or number
/// - Channel name can only contain letters, numbers, hyphens, and underscores
/// - Channel name must not be a reserved name (system, admin, internal, reserved, ailoop)
pub fn validate_channel_name_if018(channel_name: &str) -> ChannelValidationResult {
    match validate_channel_name(channel_name) {
        Ok(()) => ChannelValidationResult {
            valid: true,
            error_message: None,
        },
        Err(err) => ChannelValidationResult {
            valid: false,
            error_message: Some(format!("INVALID_CHANNEL: {}", err)),
        },
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_valid_channel_names() {
        assert!(is_valid_channel_name("valid-channel"));
        assert!(is_valid_channel_name("valid_channel"));
        assert!(is_valid_channel_name("channel123"));
        assert!(is_valid_channel_name("a"));
        assert!(is_valid_channel_name("Channel-123_Test"));
    }

    #[test]
    fn test_invalid_channel_names() {
        assert!(!is_valid_channel_name(""));
        assert!(!is_valid_channel_name("-invalid-start"));
        assert!(!is_valid_channel_name("_invalid-start"));
        assert!(!is_valid_channel_name("invalid space"));
        assert!(!is_valid_channel_name("invalid@symbol"));
        assert!(!is_valid_channel_name("system"));
        assert!(!is_valid_channel_name("admin"));

        // Test length limit
        let long_name = "a".repeat(65);
        assert!(!is_valid_channel_name(&long_name));
    }

    #[test]
    fn test_validation_error_messages() {
        match validate_channel_name("") {
            Err(ChannelValidationError::Empty) => (),
            _ => panic!("Expected Empty error"),
        }

        match validate_channel_name("-invalid") {
            Err(ChannelValidationError::InvalidStart) => (),
            _ => panic!("Expected InvalidStart error"),
        }

        match validate_channel_name("system") {
            Err(ChannelValidationError::ReservedName(name)) => assert_eq!(name, "system"),
            _ => panic!("Expected ReservedName error"),
        }

        match validate_channel_name("invalid@name") {
            Err(ChannelValidationError::InvalidCharacters) => (),
            _ => panic!("Expected InvalidCharacters error"),
        }
    }

    #[test]
    fn test_validate_channel_name_if018_valid() {
        let result = validate_channel_name_if018("valid-channel");
        assert!(result.valid);
        assert_eq!(result.error_message, None);
    }

    #[test]
    fn test_validate_channel_name_if018_invalid() {
        let result = validate_channel_name_if018("");
        assert!(!result.valid);
        assert!(result.error_message.is_some());
        assert!(result.error_message.unwrap().contains("INVALID_CHANNEL"));
    }

    #[test]
    fn test_validate_channel_name_if018_idempotent() {
        let result1 = validate_channel_name_if018("test-channel");
        let result2 = validate_channel_name_if018("test-channel");
        assert_eq!(result1, result2);
    }

    #[test]
    fn test_validate_channel_name_if018_consistency() {
        // Test that validation is consistent (same result for same input)
        let invalid_name = "invalid-channel!";
        let result1 = validate_channel_name_if018(invalid_name);
        let result2 = validate_channel_name_if018(invalid_name);
        assert_eq!(result1.valid, result2.valid);
        assert_eq!(result1.error_message, result2.error_message);
    }

    /// TC-REQ-020-01: Verify channel validation consistency between direct and server modes
    ///
    /// Given: Invalid channel name 'invalid-channel!'
    /// When: Execute command with --channel invalid-channel! in direct mode and server mode
    /// Then:
    ///   - Same channel validation error occurs in both modes
    ///   - Validation rules are identical in both modes
    ///
    /// Note: Since validation is mode-agnostic (no mode parameter), testing the same function
    /// with the same input proves it works identically in both modes.
    #[test]
    fn test_tc_req_020_01_channel_validation_consistency() {
        // Given: Invalid channel name 'invalid-channel!'
        let invalid_channel = "invalid-channel!";
        
        // When: Validate in "direct mode" (simulated by calling validation function)
        let direct_mode_result = validate_channel_name_if018(invalid_channel);
        
        // When: Validate in "server mode" (simulated by calling same validation function)
        let server_mode_result = validate_channel_name_if018(invalid_channel);
        
        // Then: Same channel validation error occurs in both modes
        assert_eq!(direct_mode_result.valid, server_mode_result.valid, "Validation result should be identical in both modes");
        assert_eq!(direct_mode_result.error_message, server_mode_result.error_message, "Error messages should be identical in both modes");
        
        // Then: Validation rules are identical in both modes
        assert!(!direct_mode_result.valid, "Invalid channel should be rejected");
        assert!(direct_mode_result.error_message.is_some(), "Error message should be present for invalid channel");
        assert!(direct_mode_result.error_message.as_ref().unwrap().contains("INVALID_CHANNEL"), "Error should contain INVALID_CHANNEL code");
        
        // Verify the validation is truly mode-independent by testing multiple invalid names
        let test_cases = vec!["invalid-channel!", "-invalid", "invalid space", "invalid@symbol"];
        for invalid_name in test_cases {
            let result1 = validate_channel_name_if018(invalid_name);
            let result2 = validate_channel_name_if018(invalid_name);
            assert_eq!(result1, result2, "Validation should be idempotent and mode-independent for: {}", invalid_name);
            assert!(!result1.valid, "Invalid channel '{}' should be rejected", invalid_name);
        }
    }

    /// TC-REQ-033-01: Verify channel validation in server mode (and consistency with direct mode)
    ///
    /// Given: Invalid and valid channel names
    /// When: Attempt to send messages with invalid and valid channel names in server mode
    /// Then:
    ///   - Channel validation error occurs for invalid channel name
    ///   - Message is accepted for valid channel name (validation passes)
    ///   - Channel validation is identical in both modes
    ///
    /// Note: This test verifies that validation prevents bypassing in server mode.
    /// Since the validation function is mode-agnostic, testing it directly proves
    /// it works identically in both modes.
    #[test]
    fn test_tc_req_033_01_channel_validation_bypass_prevention() {
        // Given: Invalid and valid channel names
        let invalid_channel = "invalid-channel!";
        let valid_channel = "valid-channel";
        
        // When: Attempt to validate invalid channel name (simulating server mode message)
        let invalid_result = validate_channel_name_if018(invalid_channel);
        
        // Then: Channel validation error occurs for invalid channel name
        assert!(!invalid_result.valid, "Invalid channel should be rejected");
        assert!(invalid_result.error_message.is_some(), "Error message should be present");
        let error_msg = invalid_result.error_message.as_ref().unwrap();
        assert!(error_msg.contains("INVALID_CHANNEL"), "Error should contain INVALID_CHANNEL code");
        assert!(error_msg.contains("invalid characters"), "Error should describe the validation failure");
        
        // When: Attempt to validate valid channel name (simulating server mode message)
        let valid_result = validate_channel_name_if018(valid_channel);
        
        // Then: Message is accepted for valid channel name
        assert!(valid_result.valid, "Valid channel should be accepted");
        assert_eq!(valid_result.error_message, None, "No error message for valid channel");
        
        // Then: Channel validation is identical in both modes
        // Test multiple valid channels to prove consistency
        let valid_channels = vec!["valid-channel", "valid_channel", "channel123", "public"];
        for channel in valid_channels {
            let direct_result = validate_channel_name_if018(channel);
            let server_result = validate_channel_name_if018(channel);
            assert_eq!(direct_result, server_result, "Validation should be identical in both modes for: {}", channel);
            assert!(direct_result.valid, "Valid channel '{}' should be accepted", channel);
        }
        
        // Test multiple invalid channels to prove consistency
        let invalid_channels = vec!["invalid-channel!", "-invalid", "invalid space", "system"];
        for channel in invalid_channels {
            let direct_result = validate_channel_name_if018(channel);
            let server_result = validate_channel_name_if018(channel);
            assert_eq!(direct_result, server_result, "Validation should be identical in both modes for: {}", channel);
            assert!(!direct_result.valid, "Invalid channel '{}' should be rejected", channel);
        }
    }
}
</file>

<file path="src/cli/handlers.rs">
//! CLI command handlers

use anyhow::{Result, Context};
use std::io::{self, Write};
use std::time::Duration;
use tokio::time::timeout;
use tokio::signal;

/// Handle the 'ask' command
pub async fn handle_ask(
    question: String,
    channel: String,
    timeout_secs: u32,
    _server: String,
    json: bool,
) -> Result<()> {
    // Validate channel name
    crate::channel::validation::validate_channel_name(&channel)
        .map_err(|e| anyhow::anyhow!("Invalid channel name: {}", e))?;

    // Display the question
    print!("â“ {}: ", question);
    io::stdout().flush().context("Failed to flush stdout")?;

    // Collect response with optional timeout and Ctrl+C handling
    let response = if timeout_secs > 0 {
        let timeout_duration = Duration::from_secs(timeout_secs as u64);
        tokio::select! {
            result = timeout(timeout_duration, read_user_input()) => {
                match result {
                    Ok(Ok(answer)) => answer,
                    Ok(Err(e)) => return Err(e),
                    Err(_) => {
                        // Timeout occurred
                        if json {
                            let error_response = serde_json::json!({
                                "error": "timeout",
                                "message": format!("Question timed out after {} seconds", timeout_secs),
                                "channel": channel,
                                "timestamp": chrono::Utc::now().to_rfc3339()
                            });
                            println!("\n{}", serde_json::to_string_pretty(&error_response)?);
                        } else {
                            println!("\nâ±ï¸  Timeout: No response received within {} seconds", timeout_secs);
                        }
                        std::process::exit(1);
                    }
                }
            }
            _ = signal::ctrl_c() => {
                if json {
                    let error_response = serde_json::json!({
                        "error": "cancelled",
                        "message": "Question cancelled by user (Ctrl+C)",
                        "channel": channel,
                        "timestamp": chrono::Utc::now().to_rfc3339()
                    });
                    println!("\n{}", serde_json::to_string_pretty(&error_response)?);
                } else {
                    println!("\nâš ï¸  Cancelled by user (Ctrl+C)");
                }
                std::process::exit(130); // Standard exit code for SIGINT
            }
        }
    } else {
        // No timeout - wait indefinitely, but still handle Ctrl+C
        tokio::select! {
            result = read_user_input() => {
                result.context("Failed to read user input")?
            }
            _ = signal::ctrl_c() => {
                if json {
                    let error_response = serde_json::json!({
                        "error": "cancelled",
                        "message": "Question cancelled by user (Ctrl+C)",
                        "channel": channel,
                        "timestamp": chrono::Utc::now().to_rfc3339()
                    });
                    println!("\n{}", serde_json::to_string_pretty(&error_response)?);
                } else {
                    println!("\nâš ï¸  Cancelled by user (Ctrl+C)");
                }
                std::process::exit(130);
            }
        }
    };

    // Return response
    if json {
        let json_response = serde_json::json!({
            "response": response.trim(),
            "channel": channel,
            "timestamp": chrono::Utc::now().to_rfc3339()
        });
        println!("{}", serde_json::to_string_pretty(&json_response)?);
    } else {
        println!("{}", response.trim());
    }

    Ok(())
}

/// Read user input from stdin (async wrapper)
async fn read_user_input() -> Result<String> {
    tokio::task::spawn_blocking(|| {
        let mut buffer = String::new();
        io::stdin().read_line(&mut buffer)?;
        Ok::<String, io::Error>(buffer)
    })
    .await
    .context("Failed to read user input")?
    .context("Failed to read from stdin")
}

/// Handle the 'authorize' command
pub async fn handle_authorize(
    action: String,
    channel: String,
    timeout_secs: u32,
    _server: String,
    json: bool,
) -> Result<()> {
    // Validate channel name
    crate::channel::validation::validate_channel_name(&channel)
        .map_err(|e| anyhow::anyhow!("Invalid channel name: {}", e))?;

    // Display authorization request
    println!("ðŸ” Authorization Request");
    println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    println!("Action: {}", action);
    println!("Channel: {}", channel);
    if timeout_secs > 0 {
        println!("Timeout: {} seconds", timeout_secs);
    }
    println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    print!("Authorize this action? (authorized/denied): ");
    io::stdout().flush().context("Failed to flush stdout")?;

    // Collect response with timeout (defaults to denial) and Ctrl+C handling
    let decision = if timeout_secs > 0 {
        let timeout_duration = Duration::from_secs(timeout_secs as u64);
        tokio::select! {
            result = timeout(timeout_duration, read_user_input()) => {
                match result {
                    Ok(Ok(answer)) => parse_authorization_response(&answer)?,
                    Ok(Err(_)) => {
                        // Read error - default to denial
                        AuthorizationDecision::Denied
                    }
                    Err(_) => {
                        // Timeout - default to denial for security
                        if json {
                            let error_response = serde_json::json!({
                                "authorized": false,
                                "action": action,
                                "channel": channel,
                                "reason": "timeout",
                                "timestamp": chrono::Utc::now().to_rfc3339()
                            });
                            println!("\n{}", serde_json::to_string_pretty(&error_response)?);
                        } else {
                            println!("\nâ±ï¸  Timeout: No response received. Defaulting to DENIED for security.");
                        }
                        std::process::exit(1);
                    }
                }
            }
            _ = signal::ctrl_c() => {
                // Ctrl+C - default to denial for security
                if json {
                    let error_response = serde_json::json!({
                        "authorized": false,
                        "action": action,
                        "channel": channel,
                        "reason": "cancelled",
                        "timestamp": chrono::Utc::now().to_rfc3339()
                    });
                    println!("\n{}", serde_json::to_string_pretty(&error_response)?);
                } else {
                    println!("\nâš ï¸  Cancelled by user (Ctrl+C). Defaulting to DENIED for security.");
                }
                std::process::exit(1);
            }
        }
    } else {
        // No timeout - wait for response, but handle Ctrl+C
        tokio::select! {
            result = read_user_input() => {
                let answer = result.context("Failed to read user input")?;
                parse_authorization_response(&answer)?
            }
            _ = signal::ctrl_c() => {
                // Ctrl+C - default to denial for security
                if json {
                    let error_response = serde_json::json!({
                        "authorized": false,
                        "action": action,
                        "channel": channel,
                        "reason": "cancelled",
                        "timestamp": chrono::Utc::now().to_rfc3339()
                    });
                    println!("\n{}", serde_json::to_string_pretty(&error_response)?);
                } else {
                    println!("\nâš ï¸  Cancelled by user (Ctrl+C). Defaulting to DENIED for security.");
                }
                std::process::exit(1);
            }
        }
    };

    // Return decision
    let authorized = matches!(decision, AuthorizationDecision::Approved);
    
    if json {
        let json_response = serde_json::json!({
            "authorized": authorized,
            "action": action,
            "channel": channel,
            "timestamp": chrono::Utc::now().to_rfc3339()
        });
        println!("{}", serde_json::to_string_pretty(&json_response)?);
    } else {
        if authorized {
            println!("âœ… Authorization GRANTED");
        } else {
            println!("âŒ Authorization DENIED");
        }
    }

    // Exit with appropriate code
    if authorized {
        Ok(())
    } else {
        std::process::exit(1);
    }
}

/// Authorization decision types
enum AuthorizationDecision {
    Approved,
    Denied,
}

/// Parse user input for authorization response
fn parse_authorization_response(input: &str) -> Result<AuthorizationDecision> {
    let normalized = input.trim().to_lowercase();
    
    match normalized.as_str() {
        "authorized" | "yes" | "y" | "approve" | "ok" => Ok(AuthorizationDecision::Approved),
        "denied" | "no" | "n" | "deny" | "reject" => Ok(AuthorizationDecision::Denied),
        _ => {
            // Invalid response - prompt again
            print!("Invalid response. Please enter 'authorized' or 'denied': ");
            io::stdout().flush().context("Failed to flush stdout")?;
            let retry = read_user_input_sync()?;
            parse_authorization_response(&retry)
        }
    }
}

/// Synchronous version for retry logic
fn read_user_input_sync() -> Result<String> {
    let mut buffer = String::new();
    io::stdin().read_line(&mut buffer).context("Failed to read from stdin")?;
    Ok(buffer)
}

/// Handle the 'say' command
pub async fn handle_say(
    message: String,
    channel: String,
    priority: String,
    _server: String,
) -> Result<()> {
    // Validate channel name
    crate::channel::validation::validate_channel_name(&channel)
        .map_err(|e| anyhow::anyhow!("Invalid channel name: {}", e))?;

    // Validate priority
    let priority_level = match priority.to_lowercase().as_str() {
        "low" => "low",
        "normal" => "normal",
        "high" => "high",
        "urgent" => "urgent",
        _ => {
            eprintln!("Warning: Invalid priority '{}', using 'normal'", priority);
            "normal"
        }
    };

    // Display notification
    let priority_icon = match priority_level {
        "urgent" => "ðŸš¨",
        "high" => "âš ï¸ ",
        "low" => "â„¹ï¸ ",
        _ => "ðŸ’¬",
    };

    println!("{} [{}] {}", priority_icon, priority_level.to_uppercase(), message);
    println!("ðŸ“º Channel: {}", channel);

    // In direct mode, notification is just displayed
    // In server mode, this would be sent to connected humans

    Ok(())
}

/// Handle the 'serve' command
pub async fn handle_serve(
    host: String,
    port: u16,
    channel: String,
) -> Result<()> {
    // Validate channel name
    crate::channel::validation::validate_channel_name(&channel)
        .map_err(|e| anyhow::anyhow!("Invalid channel name: {}", e))?;

    // Create and start server
    let server = crate::server::AiloopServer::new(host, port, channel);
    server.start().await
}

/// Handle the 'config' command
pub async fn handle_config_init(
    config_file: String,
) -> Result<()> {
    use crate::models::{Configuration, LogLevel};
    use std::path::PathBuf;

    println!("âš™ï¸  Initializing ailoop configuration");
    println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");

    // Resolve config file path
    let config_path = if config_file.starts_with("~/") {
        let home = std::env::var("HOME")
            .map_err(|_| anyhow::anyhow!("HOME environment variable not set"))?;
        PathBuf::from(config_file.replacen("~/", &format!("{}/", home), 1))
    } else if config_file == "~/.config/ailoop/config.toml" {
        // Use XDG default
        Configuration::default_config_path()
            .map_err(|e| anyhow::anyhow!("Failed to get default config path: {}", e))?
    } else {
        PathBuf::from(config_file)
    };

    println!("ðŸ“„ Config file: {}", config_path.display());

    // Check if config already exists
    let mut config = if config_path.exists() {
        println!("âš ï¸  Configuration file already exists. Loading existing values...");
        Configuration::load_from_file(&config_path)
            .map_err(|e| anyhow::anyhow!("Failed to load existing config: {}", e))?
    } else {
        println!("âœ¨ Creating new configuration with defaults...");
        Configuration::default()
    };

    // Interactive prompts
    println!("\nðŸ“ Please answer the following questions (press Enter to use default):\n");

    // Default timeout
    print!("Default timeout for questions in seconds [{}]: ", 
           config.timeout_seconds.unwrap_or(0));
    io::stdout().flush()?;
    let timeout_input = read_user_input_sync()?;
    if !timeout_input.trim().is_empty() {
        if let Ok(timeout) = timeout_input.trim().parse::<u32>() {
            config.timeout_seconds = Some(timeout);
        } else {
            println!("âš ï¸  Invalid timeout value, using default");
        }
    }

    // Default channel
    print!("Default channel name [{}]: ", config.default_channel);
    io::stdout().flush()?;
    let channel_input = read_user_input_sync()?;
    if !channel_input.trim().is_empty() {
        let channel = channel_input.trim().to_string();
        if crate::channel::validation::validate_channel_name(&channel).is_ok() {
            config.default_channel = channel;
        } else {
            println!("âš ï¸  Invalid channel name, using default");
        }
    }

    // Log level
    print!("Log level (error/warn/info/debug/trace) [{}]: ", 
           match config.log_level {
               LogLevel::Error => "error",
               LogLevel::Warn => "warn",
               LogLevel::Info => "info",
               LogLevel::Debug => "debug",
               LogLevel::Trace => "trace",
           });
    io::stdout().flush()?;
    let log_level_input = read_user_input_sync()?;
    if !log_level_input.trim().is_empty() {
        config.log_level = match log_level_input.trim().to_lowercase().as_str() {
            "error" => LogLevel::Error,
            "warn" => LogLevel::Warn,
            "info" => LogLevel::Info,
            "debug" => LogLevel::Debug,
            "trace" => LogLevel::Trace,
            _ => {
                println!("âš ï¸  Invalid log level, using default");
                config.log_level.clone()
            }
        };
    }

    // Server host
    print!("Server bind address [{}]: ", config.server_host);
    io::stdout().flush()?;
    let host_input = read_user_input_sync()?;
    if !host_input.trim().is_empty() {
        config.server_host = host_input.trim().to_string();
    }

    // Server port
    print!("Server port [{}]: ", config.server_port);
    io::stdout().flush()?;
    let port_input = read_user_input_sync()?;
    if !port_input.trim().is_empty() {
        if let Ok(port) = port_input.trim().parse::<u16>() {
            config.server_port = port;
        } else {
            println!("âš ï¸  Invalid port number, using default");
        }
    }

    // Validate configuration
    println!("\nðŸ” Validating configuration...");
    match config.validate() {
        Ok(()) => {
            println!("âœ… Configuration is valid");
        }
        Err(errors) => {
            println!("âŒ Configuration validation failed:");
            for error in &errors {
                println!("   - {}", error);
            }
            return Err(anyhow::anyhow!("Configuration validation failed"));
        }
    }

    // Save configuration
    println!("\nðŸ’¾ Saving configuration to {}...", config_path.display());
    config.save_to_file(&config_path)
        .map_err(|e| anyhow::anyhow!("Failed to save configuration: {}", e))?;

    println!("âœ… Configuration saved successfully!");
    println!("\nðŸ“‹ Configuration summary:");
    println!("   Default timeout: {} seconds", 
             config.timeout_seconds.map(|t| t.to_string()).unwrap_or_else(|| "disabled".to_string()));
    println!("   Default channel: {}", config.default_channel);
    println!("   Log level: {:?}", config.log_level);
    println!("   Server: {}:{}", config.server_host, config.server_port);

    Ok(())
}

/// Handle the 'image' command
pub async fn handle_image(
    image_path: String,
    channel: String,
    _server: String,
) -> Result<()> {
    // Validate channel name
    crate::channel::validation::validate_channel_name(&channel)
        .map_err(|e| anyhow::anyhow!("Invalid channel name: {}", e))?;

    // Check if it's a URL or file path
    let is_url = image_path.starts_with("http://") || image_path.starts_with("https://");

    if is_url {
        println!("ðŸ–¼ï¸  [{}] Image URL: {}", channel, image_path);
        println!("ðŸ’¡ Please open this URL in your browser to view the image:");
        println!("   {}", image_path);
    } else {
        // Check if file exists
        let path = std::path::Path::new(&image_path);
        if path.exists() {
            println!("ðŸ–¼ï¸  [{}] Image file: {}", channel, image_path);
            println!("ðŸ’¡ Image location: {}", path.canonicalize()?.display());
            
            // Try to determine image type
            if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
                let img_type = match ext.to_lowercase().as_str() {
                    "jpg" | "jpeg" => "JPEG",
                    "png" => "PNG",
                    "gif" => "GIF",
                    "webp" => "WebP",
                    "svg" => "SVG",
                    _ => "Unknown",
                };
                println!("ðŸ“‹ Image type: {}", img_type);
            }
            
            println!("ðŸ’¡ Please open this file in an image viewer to view it.");
        } else {
            return Err(anyhow::anyhow!("Image file not found: {}", image_path));
        }
    }

    // In server mode, this would be sent to connected humans
    // In direct mode, we just display the information

    Ok(())
}

/// Handle the 'navigate' command
pub async fn handle_navigate(
    url: String,
    channel: String,
    _server: String,
) -> Result<()> {
    // Validate channel name
    crate::channel::validation::validate_channel_name(&channel)
        .map_err(|e| anyhow::anyhow!("Invalid channel name: {}", e))?;

    // Validate URL format
    if !url.starts_with("http://") && !url.starts_with("https://") {
        return Err(anyhow::anyhow!("Invalid URL format. Must start with http:// or https://"));
    }

    println!("ðŸ§­ [{}] Navigation suggestion", channel);
    println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    println!("URL: {}", url);
    println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    println!("ðŸ’¡ Please navigate to this URL in your browser:");
    println!("   {}", url);

    // Try to open URL if possible (platform-specific)
    #[cfg(target_os = "linux")]
    {
        let _ = std::process::Command::new("xdg-open").arg(&url).spawn();
    }
    #[cfg(target_os = "windows")]
    {
        let _ = std::process::Command::new("cmd")
            .args(&["/C", "start", "", &url])
            .spawn();
    }
    #[cfg(target_os = "macos")]
    {
        let _ = std::process::Command::new("open").arg(&url).spawn();
    }

    // In server mode, this would be sent to connected humans
    // In direct mode, we display the information and attempt to open it

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_handle_ask_placeholder() {
        // This is just a placeholder test
        let result = handle_ask(
            "Test question".to_string(),
            "test-channel".to_string(),
            60,
            "http://localhost:8080".to_string(),
            false,
        ).await;

        assert!(result.is_ok());
    }
}

/// Handle the 'forward' command
pub async fn handle_forward(
    channel: String,
    agent_type: Option<String>,
    format: String,
    transport: String,
    url: Option<String>,
    output: Option<String>,
    client_id: Option<String>,
    input: Option<String>,
) -> Result<()> {
    use crate::cli::forward::{execute_forward, ForwardConfig};
    use crate::parser::InputFormat;
    use crate::transport::factory::TransportType;
    use std::path::PathBuf;

    // Validate channel name
    crate::channel::validation::validate_channel_name(&channel)
        .map_err(|e| anyhow::anyhow!("Invalid channel name: {}", e))?;

    // Parse input format
    let input_format = match format.as_str() {
        "json" => InputFormat::Json,
        "stream-json" => InputFormat::StreamJson,
        "text" => InputFormat::Text,
        _ => {
            return Err(anyhow::anyhow!(
                "Invalid format: {}. Must be one of: json, stream-json, text",
                format
            ));
        }
    };

    // Parse transport type
    let transport_type = match transport.as_str() {
        "websocket" => {
            if url.is_none() {
                return Err(anyhow::anyhow!(
                    "WebSocket transport requires --url option"
                ));
            }
            TransportType::WebSocket
        }
        "file" => {
            if output.is_none() {
                return Err(anyhow::anyhow!(
                    "File transport requires --output option"
                ));
            }
            TransportType::File
        }
        _ => {
            return Err(anyhow::anyhow!(
                "Invalid transport: {}. Must be one of: websocket, file",
                transport
            ));
        }
    };

    // Build forward config
    let config = ForwardConfig {
        channel,
        agent_type,
        format: input_format,
        transport_type,
        url,
        file_path: output.map(PathBuf::from),
        client_id,
        input_file: input.map(PathBuf::from),
    };

    // Execute forward command
    execute_forward(config).await
}
</file>

<file path="src/cli/message_converter.rs">
//! Message converter for transforming agent events to ailoop messages

use crate::models::{Message, MessageContent, NotificationPriority, SenderType};
use crate::parser::{AgentEvent, EventType};
use chrono::Utc;
use serde_json::json;
use std::collections::HashMap;

/// Converts agent events to ailoop messages
///
/// This converter is completely transport-independent and agent-agnostic.
/// It preserves agent-specific metadata in the message.metadata field.
pub struct MessageConverter {
    channel: String,
    client_id: Option<String>,
    agent_type: String,
    session_id: Option<String>,
}

impl MessageConverter {
    /// Create a new message converter
    pub fn new(
        channel: String,
        client_id: Option<String>,
        agent_type: String,
    ) -> Self {
        Self {
            channel,
            client_id,
            agent_type,
            session_id: None,
        }
    }

    /// Set the session ID (extracted from system events)
    pub fn set_session_id(&mut self, session_id: String) {
        self.session_id = Some(session_id);
    }

    /// Set the agent type
    pub fn set_agent_type(&mut self, agent_type: String) {
        self.agent_type = agent_type;
    }

    /// Convert an agent event to one or more messages
    ///
    /// Returns a vector to handle cases where one event produces multiple messages.
    /// Preserves agent_type, session_id, client_id, and timestamp in message.metadata.
    pub fn convert(&mut self, event: AgentEvent) -> Vec<Message> {
        // Update session_id from system events
        if let EventType::System = event.event_type {
            if let Some(session_id) = event.metadata.get("session_id") {
                self.set_session_id(session_id.clone());
            }
            // System events don't produce messages, just update state
            return vec![];
        }

        // Build metadata object with all tracking information
        let mut metadata = json!({
            "agent_type": self.agent_type.clone(),
        });

        // Add session_id if available
        if let Some(ref session_id) = self.session_id {
            metadata["session_id"] = json!(session_id);
        }

        // Add client_id if available
        if let Some(ref client_id) = self.client_id {
            metadata["client_id"] = json!(client_id);
        }

        // Preserve original event metadata
        if !event.metadata.is_empty() {
            let event_metadata: HashMap<String, serde_json::Value> = event
                .metadata
                .iter()
                .map(|(k, v)| (k.clone(), json!(v)))
                .collect();
            metadata["event_metadata"] = json!(event_metadata);
        }

        // Use event timestamp if available, otherwise use current time
        let timestamp = event.timestamp.unwrap_or_else(Utc::now);

        // Convert based on event type
        let content = match event.event_type {
            EventType::Assistant => {
                let text = self.extract_text(&event.content, "message", "text");
                MessageContent::Notification {
                    text: format!("[{}] {}", self.agent_type, text),
                    priority: NotificationPriority::Normal,
                }
            }
            EventType::ToolCall => {
                let tool_name = self.extract_text(&event.content, "tool", "name");
                let status = self.extract_text(&event.content, "status", "state");
                metadata["tool_args"] = event.content.get("args").cloned().unwrap_or(json!(null));
                MessageContent::Notification {
                    text: format!("[{}] Tool: {} - {}", self.agent_type, tool_name, status),
                    priority: NotificationPriority::Low,
                }
            }
            EventType::Result => {
                let result_text = self.extract_text(&event.content, "result", "text");
                metadata["duration"] = event.content.get("duration").cloned().unwrap_or(json!(null));
                MessageContent::Notification {
                    text: format!("[{}] Result: {}", self.agent_type, result_text),
                    priority: NotificationPriority::High,
                }
            }
            EventType::User => {
                // Optional: include user events for context
                let text = self.extract_text(&event.content, "message", "text");
                MessageContent::Notification {
                    text: format!("[{}] User: {}", self.agent_type, text),
                    priority: NotificationPriority::Low,
                }
            }
            EventType::Error => {
                let error_text = self.extract_text(&event.content, "error", "message");
                metadata["error_details"] = event.content.clone();
                MessageContent::Notification {
                    text: format!("[{}] Error: {}", self.agent_type, error_text),
                    priority: NotificationPriority::Urgent,
                }
            }
            EventType::System => {
                // Already handled above
                return vec![];
            }
            EventType::Custom(typ) => {
                metadata["custom_type"] = json!(typ);
                let text = self.extract_text(&event.content, "message", "text");
                MessageContent::Notification {
                    text: format!("[{}] {}: {}", self.agent_type, typ, text),
                    priority: NotificationPriority::Normal,
                }
            }
        };

        let message = Message {
            id: uuid::Uuid::new_v4(),
            channel: self.channel.clone(),
            sender_type: SenderType::Agent,
            content,
            timestamp,
            correlation_id: None,
            metadata: Some(metadata),
        };

        vec![message]
    }

    /// Extract text from JSON content using multiple possible keys
    fn extract_text(&self, content: &serde_json::Value, primary: &str, secondary: &str) -> String {
        content
            .get(primary)
            .or_else(|| content.get(secondary))
            .and_then(|v| v.as_str())
            .map(|s| s.to_string())
            .unwrap_or_else(|| {
                // Fallback: try to serialize the whole content
                serde_json::to_string(content).unwrap_or_else(|_| "".to_string())
            })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::EventType;
    use std::collections::HashMap;

    #[test]
    fn test_convert_assistant_event() {
        let mut converter = MessageConverter::new(
            "test-channel".to_string(),
            Some("client-123".to_string()),
            "cursor".to_string(),
        );

        let event = AgentEvent {
            agent_type: "cursor".to_string(),
            event_type: EventType::Assistant,
            content: json!({
                "message": "Hello, world!",
                "type": "assistant"
            }),
            metadata: HashMap::new(),
            timestamp: None,
        };

        let messages = converter.convert(event);
        assert_eq!(messages.len(), 1);
        assert_eq!(messages[0].channel, "test-channel");
        assert!(messages[0].metadata.is_some());
        let metadata = messages[0].metadata.as_ref().unwrap();
        assert_eq!(metadata["agent_type"], "cursor");
        assert_eq!(metadata["client_id"], "client-123");
    }
}
</file>

<file path="src/cli/mod.rs">
//! CLI command handling

pub mod commands;
pub mod handlers;
pub mod message_converter;
pub mod forward;

pub use handlers::*;
</file>

<file path="src/models/configuration.rs">
//! Configuration data structures

use serde::{Deserialize, Serialize};
use std::path::PathBuf;

/// Logging level configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum LogLevel {
    #[serde(rename = "error")]
    Error,
    #[serde(rename = "warn")]
    Warn,
    #[serde(rename = "info")]
    Info,
    #[serde(rename = "debug")]
    Debug,
    #[serde(rename = "trace")]
    Trace,
}

impl Default for LogLevel {
    fn default() -> Self {
        LogLevel::Info
    }
}

/// Main configuration structure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Configuration {
    /// Default timeout in seconds for questions (0 = no timeout)
    pub timeout_seconds: Option<u32>,
    /// Default channel name
    pub default_channel: String,
    /// Logging verbosity level
    pub log_level: LogLevel,
    /// Server bind address
    pub server_host: String,
    /// Server port number
    pub server_port: u16,
    /// Maximum concurrent connections
    pub max_connections: u32,
    /// Maximum message size in bytes
    pub max_message_size: usize,
}

impl Default for Configuration {
    fn default() -> Self {
        Self {
            timeout_seconds: Some(300), // 5 minutes default
            default_channel: "public".to_string(),
            log_level: LogLevel::Info,
            server_host: "127.0.0.1".to_string(),
            server_port: 8080,
            max_connections: 100,
            max_message_size: 10240, // 10KB
        }
    }
}

impl Configuration {
    /// Load configuration from file
    pub fn load_from_file(path: &PathBuf) -> Result<Self, Box<dyn std::error::Error>> {
        if path.exists() {
            let content = std::fs::read_to_string(path)?;
            let config: Configuration = toml::from_str(&content)?;
            Ok(config)
        } else {
            // Return default configuration if file doesn't exist
            Ok(Configuration::default())
        }
    }

    /// Save configuration to file
    pub fn save_to_file(&self, path: &PathBuf) -> Result<(), Box<dyn std::error::Error>> {
        let content = toml::to_string_pretty(self)?;
        if let Some(parent) = path.parent() {
            std::fs::create_dir_all(parent)?;
        }
        std::fs::write(path, content)?;
        Ok(())
    }

    /// Get the XDG config directory path
    pub fn default_config_path() -> Result<PathBuf, Box<dyn std::error::Error>> {
        let config_dir = dirs::config_dir()
            .ok_or("Could not determine config directory")?;
        Ok(config_dir.join("ailoop").join("config.toml"))
    }

    /// Validate configuration values
    pub fn validate(&self) -> Result<(), Vec<String>> {
        let mut errors = Vec::new();

        // Validate timeout
        if let Some(timeout) = self.timeout_seconds {
            if timeout > 3600 {
                errors.push("timeout_seconds cannot exceed 3600 (1 hour)".to_string());
            }
        }

        // Validate port (u16 is already 0-65535, so only check minimum)
        if self.server_port < 1024 {
            errors.push("server_port must be at least 1024 (privileged ports not allowed)".to_string());
        }

        // Validate max connections
        if self.max_connections > 1000 {
            errors.push("max_connections cannot exceed 1000".to_string());
        }

        // Validate message size
        if self.max_message_size > 102400 { // 100KB
            errors.push("max_message_size cannot exceed 102400 bytes (100KB)".to_string());
        }

        // Validate channel name
        if !is_valid_channel_name(&self.default_channel) {
            errors.push("default_channel must match channel naming convention".to_string());
        }

        if errors.is_empty() {
            Ok(())
        } else {
            Err(errors)
        }
    }
}

/// Validate channel name according to naming convention
fn is_valid_channel_name(name: &str) -> bool {
    if name.is_empty() || name.len() > 64 {
        return false;
    }

    let first_char = name.chars().next().unwrap();
    if !first_char.is_ascii_alphabetic() && !first_char.is_ascii_digit() {
        return false;
    }

    name.chars().all(|c| {
        c.is_ascii_alphabetic() || c.is_ascii_digit() || c == '-' || c == '_'
    })
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn test_default_configuration() {
        let config = Configuration::default();
        assert_eq!(config.timeout_seconds, Some(300));
        assert_eq!(config.default_channel, "public");
        assert_eq!(config.server_port, 8080);
    }

    #[test]
    fn test_configuration_validation() {
        let config = Configuration {
            timeout_seconds: Some(7200), // Invalid: too high
            default_channel: "invalid channel!".to_string(), // Invalid: spaces and special chars
            server_port: 80, // Invalid: privileged port
            max_connections: 2000, // Invalid: too high
            max_message_size: 200000, // Invalid: too high
            ..Configuration::default()
        };

        let errors = config.validate().unwrap_err();
        assert!(errors.len() > 0);
        assert!(errors.iter().any(|e| e.contains("timeout_seconds")));
        assert!(errors.iter().any(|e| e.contains("default_channel")));
        assert!(errors.iter().any(|e| e.contains("server_port")));
    }

    #[test]
    fn test_channel_name_validation() {
        assert!(is_valid_channel_name("valid-channel"));
        assert!(is_valid_channel_name("valid_channel"));
        assert!(is_valid_channel_name("channel123"));
        assert!(is_valid_channel_name("a"));

        assert!(!is_valid_channel_name(""));
        assert!(!is_valid_channel_name("-invalid-start"));
        assert!(!is_valid_channel_name("invalid space"));
        assert!(!is_valid_channel_name("invalid@symbol"));
        assert!(!is_valid_channel_name(&"a".repeat(65))); // Too long
    }

    #[test]
    fn test_config_file_operations() {
        let temp_dir = tempdir().unwrap();
        let config_path = temp_dir.path().join("test_config.toml");

        let config = Configuration {
            timeout_seconds: Some(120),
            default_channel: "test-channel".to_string(),
            ..Configuration::default()
        };

        // Save configuration
        config.save_to_file(&config_path).unwrap();
        assert!(config_path.exists());

        // Load configuration
        let loaded_config = Configuration::load_from_file(&config_path).unwrap();
        assert_eq!(loaded_config.timeout_seconds, Some(120));
        assert_eq!(loaded_config.default_channel, "test-channel");
    }
}
</file>

<file path="src/models/message.rs">
//! Message data structures

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// Type of message sender
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SenderType {
    #[serde(rename = "AGENT")]
    Agent,
    #[serde(rename = "HUMAN")]
    Human,
}

/// Content of a message
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum MessageContent {
    #[serde(rename = "question")]
    Question {
        text: String,
        timeout_seconds: u32,
    },
    #[serde(rename = "authorization")]
    Authorization {
        action: String,
        context: Option<serde_json::Value>,
        timeout_seconds: u32,
    },
    #[serde(rename = "notification")]
    Notification {
        text: String,
        #[serde(default)]
        priority: NotificationPriority,
    },
    #[serde(rename = "response")]
    Response {
        answer: Option<String>,
        response_type: ResponseType,
    },
}

/// Priority levels for notifications
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub enum NotificationPriority {
    #[default]
    #[serde(rename = "low")]
    Low,
    #[serde(rename = "normal")]
    Normal,
    #[serde(rename = "high")]
    High,
    #[serde(rename = "urgent")]
    Urgent,
}

/// Types of responses to questions/authorizations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ResponseType {
    #[serde(rename = "text")]
    Text,
    #[serde(rename = "authorization_approved")]
    AuthorizationApproved,
    #[serde(rename = "authorization_denied")]
    AuthorizationDenied,
    #[serde(rename = "timeout")]
    Timeout,
    #[serde(rename = "cancelled")]
    Cancelled,
}

/// Core message structure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Message {
    /// Unique message identifier
    pub id: Uuid,
    /// Channel name (validated)
    pub channel: String,
    /// Type of sender
    pub sender_type: SenderType,
    /// Message content/payload
    pub content: MessageContent,
    /// Creation timestamp
    pub timestamp: DateTime<Utc>,
    /// Links related messages (optional)
    pub correlation_id: Option<Uuid>,
    /// Extended metadata for agent-specific and client tracking information
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<serde_json::Value>,
}

impl Message {
    /// Create a new message
    pub fn new(
        channel: String,
        sender_type: SenderType,
        content: MessageContent,
    ) -> Self {
        Self {
            id: Uuid::new_v4(),
            channel,
            sender_type,
            content,
            timestamp: Utc::now(),
            correlation_id: None,
            metadata: None,
        }
    }

    /// Create a response message linked to another message
    pub fn response(
        channel: String,
        content: MessageContent,
        correlation_id: Uuid,
    ) -> Self {
        Self {
            id: Uuid::new_v4(),
            channel,
            sender_type: SenderType::Human,
            content,
            timestamp: Utc::now(),
            correlation_id: Some(correlation_id),
            metadata: None,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_message_creation() {
        let content = MessageContent::Question {
            text: "What is the answer?".to_string(),
            timeout_seconds: 60,
        };

        let message = Message::new(
            "test-channel".to_string(),
            SenderType::Agent,
            content,
        );

        assert_eq!(message.channel, "test-channel");
        assert!(matches!(message.sender_type, SenderType::Agent));
        assert!(message.correlation_id.is_none());
    }
}
</file>

<file path="src/server/api.rs">
//! HTTP API server for web clients

use crate::server::history::MessageHistory;
use crate::server::broadcast::BroadcastManager;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use warp::Filter;

/// API response for channel information
#[derive(Debug, Clone, Serialize)]
pub struct ChannelInfo {
    pub name: String,
    pub message_count: usize,
    pub oldest_message: Option<String>,
    pub newest_message: Option<String>,
}

/// API response for channel list
#[derive(Debug, Clone, Serialize)]
pub struct ChannelsResponse {
    pub channels: Vec<ChannelInfo>,
}

/// API response for message history
#[derive(Debug, Clone, Serialize)]
pub struct MessagesResponse {
    pub channel: String,
    pub messages: Vec<serde_json::Value>,
    pub total_count: usize,
}

/// API response for channel statistics
#[derive(Debug, Clone, Serialize)]
pub struct StatsResponse {
    pub channel: String,
    pub message_count: usize,
    pub oldest_message: Option<String>,
    pub newest_message: Option<String>,
}

/// Create HTTP API routes
pub fn create_api_routes(
    message_history: Arc<MessageHistory>,
    broadcast_manager: Arc<BroadcastManager>,
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    let message_history_filter = warp::any().map(move || Arc::clone(&message_history));
    let broadcast_manager_filter = warp::any().map(move || Arc::clone(&broadcast_manager));

    // GET /api/channels - List all channels
    let get_channels = warp::path!("api" / "channels")
        .and(warp::get())
        .and(message_history_filter.clone())
        .and_then(handle_get_channels);

    // GET /api/channels/:channel/messages - Get message history for a channel
    let get_channel_messages = warp::path!("api" / "channels" / String / "messages")
        .and(warp::get())
        .and(warp::query::<MessagesQuery>())
        .and(message_history_filter.clone())
        .and_then(handle_get_channel_messages);

    // GET /api/channels/:channel/stats - Get statistics for a channel
    let get_channel_stats = warp::path!("api" / "channels" / String / "stats")
        .and(warp::get())
        .and(message_history_filter.clone())
        .and_then(handle_get_channel_stats);

    // GET /api/stats - Get overall broadcast statistics
    let get_stats = warp::path!("api" / "stats")
        .and(warp::get())
        .and(broadcast_manager_filter.clone())
        .and_then(handle_get_stats);

    get_channels
        .or(get_channel_messages)
        .or(get_channel_stats)
        .or(get_stats)
}

/// Query parameters for message history
#[derive(Debug, Deserialize)]
struct MessagesQuery {
    limit: Option<usize>,
    offset: Option<usize>,
}

/// Handle GET /api/channels
async fn handle_get_channels(
    message_history: Arc<MessageHistory>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let channels = message_history.get_channels().await;

    let mut channel_infos = Vec::new();
    for channel_name in channels {
        let stats = message_history.get_channel_stats(&channel_name).await;
        let info = ChannelInfo {
            name: channel_name,
            message_count: stats.message_count,
            oldest_message: stats.oldest_message.map(|dt| dt.to_rfc3339()),
            newest_message: stats.newest_message.map(|dt| dt.to_rfc3339()),
        };
        channel_infos.push(info);
    }

    let response = ChannelsResponse {
        channels: channel_infos,
    };

    Ok(warp::reply::json(&response))
}

/// Handle GET /api/channels/:channel/messages
async fn handle_get_channel_messages(
    channel: String,
    query: MessagesQuery,
    message_history: Arc<MessageHistory>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let limit = query.limit.unwrap_or(100);
    let messages = message_history.get_messages(&channel, Some(limit)).await;

    // Convert messages to JSON values for API response
    let message_values: Vec<serde_json::Value> = messages
        .into_iter()
        .map(|msg| serde_json::to_value(msg).unwrap_or_else(|_| serde_json::json!({})))
        .collect();

    let response = MessagesResponse {
        channel,
        messages: message_values.clone(),
        total_count: message_values.len(),
    };

    Ok(warp::reply::json(&response))
}

/// Handle GET /api/channels/:channel/stats
async fn handle_get_channel_stats(
    channel: String,
    message_history: Arc<MessageHistory>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let stats = message_history.get_channel_stats(&channel).await;

    let response = StatsResponse {
        channel,
        message_count: stats.message_count,
        oldest_message: stats.oldest_message.map(|dt| dt.to_rfc3339()),
        newest_message: stats.newest_message.map(|dt| dt.to_rfc3339()),
    };

    Ok(warp::reply::json(&response))
}

/// Handle GET /api/stats
async fn handle_get_stats(
    broadcast_manager: Arc<BroadcastManager>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let stats = broadcast_manager.get_stats().await;
    Ok(warp::reply::json(&stats))
}
</file>

<file path="src/server/mod.rs">
pub mod websocket;
pub mod queue;
pub mod terminal;
pub mod server;
pub mod history;
pub mod broadcast;
pub mod api;

pub use server::AiloopServer;
pub use websocket::WebSocketServer;
pub use queue::MessageQueue;
pub use terminal::TerminalUI;
pub use history::MessageHistory;
pub use broadcast::BroadcastManager;
</file>

<file path="src/server/terminal.rs">
//! Interactive terminal UI for server monitoring with channel switching

use crate::models::{Message, MessageContent, NotificationPriority};
use crate::server::history::MessageHistory;
use crossterm::{
    event::{self, DisableMouseCapture, EnableMouseCapture, Event, KeyCode, KeyEventKind},
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::{
    backend::CrosstermBackend,
    layout::{Alignment, Constraint, Direction, Layout},
    style::{Color, Modifier, Style},
    text::{Line, Span},
    widgets::{Block, Borders, List, ListItem, Paragraph, Wrap},
    Terminal,
};
use std::io::{self, Stdout};
use std::sync::Arc;
use tokio::sync::RwLock;

/// Terminal UI for server monitoring with channel switching
pub struct TerminalUI {
    terminal: Terminal<CrosstermBackend<Stdout>>,
    message_history: Arc<MessageHistory>,
    current_channel: Arc<RwLock<String>>,
    channels: Arc<RwLock<Vec<String>>>,
}

impl TerminalUI {
    /// Create a new terminal UI with message history
    pub fn new(message_history: Arc<MessageHistory>) -> Result<Self, Box<dyn std::error::Error>> {
        // Setup terminal
        enable_raw_mode()?;
        let mut stdout = io::stdout();
        execute!(stdout, EnterAlternateScreen, EnableMouseCapture)?;
        let backend = CrosstermBackend::new(stdout);
        let terminal = Terminal::new(backend)?;

        Ok(Self {
            terminal,
            message_history,
            current_channel: Arc::new(RwLock::new("public".to_string())),
            channels: Arc::new(RwLock::new(vec!["public".to_string()])),
        })
    }

    /// Render the terminal UI with channel switching and message display
    pub async fn render(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        // Update channels list
        let available_channels = self.message_history.get_channels().await;
        {
            let mut channels = self.channels.write().await;
            *channels = available_channels;
            if channels.is_empty() {
                channels.push("public".to_string());
            }
        }

        // Get current channel
        let current_channel = {
            let channel = self.current_channel.read().await;
            channel.clone()
        };

        // Get messages for current channel
        let messages = self.message_history.get_messages(&current_channel, Some(50)).await;

        // Get channels for display
        let channels = {
            let channels_lock = self.channels.read().await;
            channels_lock.clone()
        };

        // Format messages outside the closure to avoid borrowing issues
        // We need to format before calling terminal.draw to avoid borrow conflicts
        let format_fn = |msg: &Message| -> Line {
            let timestamp = msg.timestamp.format("%H:%M:%S").to_string();
            
            // Extract agent type from metadata
            let agent_type = msg
                .metadata
                .as_ref()
                .and_then(|m| m.get("agent_type"))
                .and_then(|v| v.as_str())
                .unwrap_or("unknown");

            let (content_text, color) = match &msg.content {
                MessageContent::Notification { text, priority } => {
                    let color = match priority {
                        NotificationPriority::Urgent => Color::Red,
                        NotificationPriority::High => Color::Yellow,
                        NotificationPriority::Normal => Color::Green,
                        NotificationPriority::Low => Color::Blue,
                    };
                    (text.clone(), color)
                }
                MessageContent::Question { text, .. } => {
                    (format!("â“ {}", text), Color::Cyan)
                }
                MessageContent::Authorization { action, .. } => {
                    (format!("ðŸ” Authorization: {}", action), Color::Magenta)
                }
                MessageContent::Response { answer, response_type } => {
                    let answer_text = answer.as_deref().unwrap_or("(no answer)");
                    (format!("ðŸ“¤ Response: {} ({:?})", answer_text, response_type), Color::Blue)
                }
            };

            Line::from(vec![
                Span::styled(format!("[{}] ", timestamp), Style::default().fg(Color::DarkGray)),
                Span::styled(format!("[{}] ", agent_type), Style::default().fg(Color::Cyan)),
                Span::styled(content_text, Style::default().fg(color)),
            ])
        };

        let message_lines: Vec<Line> = if messages.is_empty() {
            vec![Line::from("No messages in this channel yet.")]
        } else {
            messages
                .iter()
                .rev() // Show newest first
                .take(30) // Limit display
                .map(format_fn)
                .collect()
        };

        // Prepare all data for the closure (clone what we need)
        let channels_for_draw = channels.clone();
        let message_lines_for_draw = message_lines.clone();
        let current_channel_for_draw = current_channel.clone();
        let message_count = messages.len();
        let scroll_offset = (message_count.saturating_sub(30)).max(0) as u16;

        // Now do the terminal drawing
        self.terminal.draw(|f| {
            let size = f.size();


            // Create layout
            let chunks = Layout::default()
                .direction(Direction::Vertical)
                .constraints([
                    Constraint::Length(3),  // Header
                    Constraint::Min(10),    // Main content
                    Constraint::Length(3),  // Footer
                ])
                .split(size);

            // Header
            let header = Paragraph::new(Line::from(vec![
                Span::styled("ailoop Server", Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD)),
                Span::raw(" - Agent Message Streaming"),
            ]))
            .block(Block::default().borders(Borders::ALL).title("Server Status"))
            .alignment(Alignment::Center);
            f.render_widget(header, chunks[0]);


            // Main content area - split into channels list and messages
            let main_chunks = Layout::default()
                .direction(Direction::Horizontal)
                .constraints([Constraint::Percentage(25), Constraint::Percentage(75)])
                .split(chunks[1]);

            // Left side - Channel list (using prepared data)
            let channel_items: Vec<ListItem> = channels_for_draw
                .iter()
                .map(|ch| {
                    let style = if ch == &current_channel_for_draw {
                        Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD)
                    } else {
                        Style::default().fg(Color::White)
                    };
                    ListItem::new(Line::from(vec![
                        Span::styled(format!("â— {}", ch), style),
                    ]))
                })
                .collect();

            let channel_list = List::new(channel_items)
                .block(Block::default().borders(Borders::ALL).title("Channels (Tab to switch)"))
                .highlight_style(Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD));
            f.render_widget(channel_list, main_chunks[0]);

            // Right side - Messages (using prepared data)
            let message_widget = Paragraph::new(message_lines_for_draw)
                .block(Block::default().borders(Borders::ALL).title(format!("Messages - {}", current_channel_for_draw)))
                .wrap(Wrap { trim: true })
                .scroll((scroll_offset, 0));
            f.render_widget(message_widget, main_chunks[1]);

            // Footer
            let footer_text = format!(
                "Tab: Switch channel | q: Quit | Channel: {} | Messages: {}",
                current_channel_for_draw,
                message_count
            );
            let footer = Paragraph::new(footer_text)
                .block(Block::default().borders(Borders::ALL))
                .alignment(Alignment::Center);
            f.render_widget(footer, chunks[2]);
        })?;

        Ok(())
    }

    /// Format a message for display
    fn format_message(&self, message: &Message) -> Line {
        let timestamp = message.timestamp.format("%H:%M:%S").to_string();
        
        // Extract agent type from metadata
        let agent_type = message
            .metadata
            .as_ref()
            .and_then(|m| m.get("agent_type"))
            .and_then(|v| v.as_str())
            .unwrap_or("unknown");

        let (content_text, color) = match &message.content {
            MessageContent::Notification { text, priority } => {
                let color = match priority {
                    NotificationPriority::Urgent => Color::Red,
                    NotificationPriority::High => Color::Yellow,
                    NotificationPriority::Normal => Color::Green,
                    NotificationPriority::Low => Color::Blue,
                };
                (text.clone(), color)
            }
            MessageContent::Question { text, .. } => {
                (format!("â“ {}", text), Color::Cyan)
            }
            MessageContent::Authorization { action, .. } => {
                (format!("ðŸ” Authorization: {}", action), Color::Magenta)
            }
            MessageContent::Response { answer, response_type } => {
                let answer_text = answer.as_deref().unwrap_or("(no answer)");
                (format!("ðŸ“¤ Response: {} ({:?})", answer_text, response_type), Color::Blue)
            }
        };

        Line::from(vec![
            Span::styled(format!("[{}] ", timestamp), Style::default().fg(Color::DarkGray)),
            Span::styled(format!("[{}] ", agent_type), Style::default().fg(Color::Cyan)),
            Span::styled(content_text, Style::default().fg(color)),
        ])
    }

    /// Handle keyboard input for channel switching
    pub async fn handle_input(&mut self) -> Result<bool, Box<dyn std::error::Error>> {
        if event::poll(std::time::Duration::from_millis(100))? {
            if let Event::Key(key) = event::read()? {
                if key.kind == KeyEventKind::Press {
                    match key.code {
                        KeyCode::Char('q') | KeyCode::Esc => {
                            return Ok(true); // Quit
                        }
                        KeyCode::Tab => {
                            // Switch to next channel
                            let channels = self.channels.read().await;
                            if !channels.is_empty() {
                                let current = self.current_channel.read().await.clone();
                                let current_idx = channels.iter().position(|c| c == &current).unwrap_or(0);
                                let next_idx = (current_idx + 1) % channels.len();
                                let mut current_ch = self.current_channel.write().await;
                                *current_ch = channels[next_idx].clone();
                            }
                        }
                        _ => {}
                    }
                }
            }
        }
        Ok(false) // Continue
    }

    /// Cleanup and restore terminal
    pub fn cleanup(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        disable_raw_mode()?;
        execute!(self.terminal.backend_mut(), LeaveAlternateScreen, DisableMouseCapture)?;
        self.terminal.show_cursor()?;
        Ok(())
    }
}

impl Drop for TerminalUI {
    fn drop(&mut self) {
        let _ = self.cleanup(); // Best effort cleanup
    }
}
</file>

<file path="src/lib.rs">
//! ailoop - Human-in-the-Loop CLI Tool
//!
//! This library provides the core functionality for ailoop, a tool that enables
//! AI agents to communicate with human users through structured interactions.

pub mod cli;
pub mod server;
pub mod channel;
pub mod models;
pub mod services;
pub mod mode;
pub mod transport;
pub mod parser;

// Re-export commonly used types
pub use models::*;
pub use services::*;
</file>

<file path="src/main.rs">
mod cli;
mod server;
mod channel;
mod models;
mod services;
mod transport;
mod parser;

use anyhow::Result;
use clap::{Parser, Subcommand};
use cli::handlers;

#[derive(Parser)]
#[command(name = "ailoop")]
#[command(about = "Human-in-the-Loop CLI Tool for AI Agent Communication")]
#[command(version)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Ask a question and collect human response
    Ask {
        /// The question text
        question: String,

        /// Channel name (default: public)
        #[arg(short, long, default_value = "public")]
        channel: String,

        /// Response timeout in seconds (0 = no timeout)
        #[arg(short, long, default_value = "0")]
        timeout: u32,

        /// Server URL for remote operation
        #[arg(long, default_value = "http://127.0.0.1:8080")]
        server: String,

        /// Output in JSON format
        #[arg(long)]
        json: bool,
    },

    /// Request authorization for a critical action
    Authorize {
        /// Description of action requiring authorization
        action: String,

        /// Channel name (default: public)
        #[arg(short, long, default_value = "public")]
        channel: String,

        /// Authorization timeout in seconds (default: 300)
        #[arg(short, long, default_value = "300")]
        timeout: u32,

        /// Server URL for remote operation
        #[arg(long, default_value = "http://127.0.0.1:8080")]
        server: String,

        /// Output in JSON format
        #[arg(long)]
        json: bool,
    },

    /// Send a notification message
    Say {
        /// Notification message text
        message: String,

        /// Channel name (default: public)
        #[arg(short, long, default_value = "public")]
        channel: String,

        /// Message priority level
        #[arg(short, long, default_value = "normal")]
        priority: String,

        /// Server URL for remote operation
        #[arg(long, default_value = "http://127.0.0.1:8080")]
        server: String,
    },

    /// Start ailoop server for multi-agent communication
    Serve {
        /// Server bind address
        #[arg(long, default_value = "127.0.0.1")]
        host: String,

        /// Server port number
        #[arg(short, long, default_value = "8080")]
        port: u16,

        /// Default channel name
        #[arg(short, long, default_value = "public")]
        channel: String,
    },

    /// Configure ailoop settings interactively
    Config {
        /// Start interactive configuration setup
        #[arg(long)]
        init: bool,

        /// Path to configuration file
        #[arg(long, default_value = "~/.config/ailoop/config.toml")]
        config_file: String,
    },

    /// Display an image to the user
    Image {
        /// Image file path or URL
        image_path: String,

        /// Channel name (default: public)
        #[arg(short, long, default_value = "public")]
        channel: String,

        /// Server URL for remote operation
        #[arg(long, default_value = "http://127.0.0.1:8080")]
        server: String,
    },

    /// Suggest user to navigate to a URL
    Navigate {
        /// URL to navigate to
        url: String,

        /// Channel name (default: public)
        #[arg(short, long, default_value = "public")]
        channel: String,

        /// Server URL for remote operation
        #[arg(long, default_value = "http://127.0.0.1:8080")]
        server: String,
    },

    /// Forward agent output to ailoop server
    Forward {
        /// Channel name for messages
        #[arg(short, long, default_value = "public")]
        channel: String,

        /// Agent type (cursor, jsonl, or auto-detect)
        #[arg(long)]
        agent_type: Option<String>,

        /// Input format (json, stream-json, text)
        #[arg(long, default_value = "stream-json")]
        format: String,

        /// Transport type (websocket, file)
        #[arg(long, default_value = "websocket")]
        transport: String,

        /// WebSocket server URL (for websocket transport)
        #[arg(long, default_value = "ws://127.0.0.1:8080")]
        url: Option<String>,

        /// Output file path (for file transport)
        #[arg(long)]
        output: Option<String>,

        /// Client ID for tracking
        #[arg(long)]
        client_id: Option<String>,

        /// Input file path (if not reading from stdin)
        #[arg(long)]
        input: Option<String>,
    },
}

#[tokio::main]
async fn main() -> Result<()> {
    let cli = Cli::parse();

    match cli.command {
        Commands::Ask { question, channel, timeout, server, json } => {
            handlers::handle_ask(question, channel, timeout, server, json).await?;
        }
        Commands::Authorize { action, channel, timeout, server, json } => {
            handlers::handle_authorize(action, channel, timeout, server, json).await?;
        }
        Commands::Say { message, channel, priority, server } => {
            handlers::handle_say(message, channel, priority, server).await?;
        }
        Commands::Serve { host, port, channel } => {
            handlers::handle_serve(host, port, channel).await?;
        }
        Commands::Config { init, config_file } => {
            if init {
                handlers::handle_config_init(config_file).await?;
            } else {
                println!("Config command requires --init flag");
                println!("Usage: ailoop config --init [--config-file PATH]");
            }
        }
        Commands::Image { image_path, channel, server } => {
            handlers::handle_image(image_path, channel, server).await?;
        }
        Commands::Navigate { url, channel, server } => {
            handlers::handle_navigate(url, channel, server).await?;
        }
        Commands::Forward {
            channel,
            agent_type,
            format,
            transport,
            url,
            output,
            client_id,
            input,
        } => {
            handlers::handle_forward(
                channel,
                agent_type,
                format,
                transport,
                url,
                output,
                client_id,
                input,
            )
            .await?;
        }
    }

    Ok(())
}
</file>

<file path="Cargo.toml">
[package]
name = "ailoop"
version = "0.1.0"
edition = "2021"

[dependencies]
# CLI framework
clap = { version = "4.4", features = ["derive"] }

# Async runtime and networking
tokio = { version = "1.35", features = ["full"] }
tokio-tungstenite = "0.21"
futures-util = "0.3"

# Web framework for server
warp = "0.3"

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# Terminal UI
crossterm = "0.27"
ratatui = "0.24"

# Utilities
uuid = { version = "1.6", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }
dirs = "5.0"

# Error handling
thiserror = "1.0"
anyhow = "1.0"

# Async traits
async-trait = "0.1"

# Logging
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

# Configuration
toml = "0.8"

# URL parsing
url = "2.5"

[dev-dependencies]
tokio-test = "0.4"
tempfile = "3.8"
</file>

<file path="src/server/server.rs">
//! Main server integration for ailoop

use crate::channel::ChannelIsolation;
use crate::models::{Message, MessageContent, ResponseType};
use crate::server::TerminalUI;
use anyhow::{Result, Context};
use futures_util::{SinkExt, StreamExt};
use std::io::{self, Write};
use std::sync::Arc;
use tokio::net::TcpListener;
use tokio::sync::mpsc;
use tokio::time::{interval, Duration};
use tokio_tungstenite::{accept_async, tungstenite::Message as WsMessage};

/// Main ailoop server
pub struct AiloopServer {
    host: String,
    port: u16,
    default_channel: String,
    channel_manager: Arc<ChannelIsolation>,
    message_history: Arc<crate::server::history::MessageHistory>,
    broadcast_manager: Arc<crate::server::broadcast::BroadcastManager>,
}

/// Server status for UI
#[derive(Clone, Debug)]
pub struct ServerStatus {
    pub status: String,
    pub total_queue_size: usize,
    pub total_connections: usize,
    pub active_channels: usize,
}

impl AiloopServer {
    /// Create a new ailoop server
    pub fn new(host: String, port: u16, default_channel: String) -> Self {
        let channel_manager = Arc::new(ChannelIsolation::new(default_channel.clone()));
        let message_history = Arc::new(crate::server::history::MessageHistory::new());
        let broadcast_manager = Arc::new(crate::server::broadcast::BroadcastManager::new());

        Self {
            host,
            port,
            default_channel,
            channel_manager,
            message_history,
            broadcast_manager,
        }
    }

    /// Start the server with terminal UI
    pub async fn start(self) -> Result<()> {
        use std::net::SocketAddr;
        let address: SocketAddr = format!("{}:{}", self.host, self.port)
            .parse()
            .context("Invalid server address")?;

        let listener = TcpListener::bind(&address).await
            .context(format!("Failed to bind to {}", address))?;

        println!("ðŸš€ ailoop server starting on {}", address);
        println!("ðŸ“º Default channel: {}", self.default_channel);
        println!("Press Ctrl+C to stop the server");

        // Create terminal UI with message history
        let message_history_ui = Arc::clone(&self.message_history);
        let terminal = TerminalUI::new(message_history_ui)
            .map_err(|e| anyhow::anyhow!("Failed to initialize terminal UI: {}", e))?;
        let terminal = Arc::new(std::sync::Mutex::new(terminal));

        // Start HTTP API server
        let api_routes = crate::server::api::create_api_routes(
            Arc::clone(&self.message_history),
            Arc::clone(&self.broadcast_manager),
        );

        // Channel for UI updates
        let (ui_tx, _ui_rx) = mpsc::channel::<ServerStatus>(100);

        // Spawn terminal UI update task
        let channel_manager_clone = Arc::clone(&self.channel_manager);
        let default_channel_clone = self.default_channel.clone();
        tokio::spawn(async move {
            let mut update_interval = interval(Duration::from_millis(500));
            loop {
                tokio::select! {
                    _ = update_interval.tick() => {
                        let status = Self::calculate_status(
                            &channel_manager_clone,
                            &default_channel_clone,
                        );
                        let _ = ui_tx.send(status).await;
                    }
                }
            }
        });

        // Spawn terminal UI render task with channel switching
        // Note: We use spawn_blocking because TerminalUI uses std::sync::Mutex
        // and we need to avoid Send requirements
        let terminal_clone = Arc::clone(&terminal);
        let terminal_task = tokio::task::spawn_blocking(move || {
            // Run terminal UI in a blocking context
            let rt = tokio::runtime::Handle::current();
            let _render_interval = interval(Duration::from_millis(200));
            
            loop {
                // Check for quit condition
                let should_quit = {
                    if let Ok(mut term) = terminal_clone.lock() {
                        // Use block_on for async operations in blocking context
                        rt.block_on(async {
                            // Handle input (non-blocking check)
                            if let Ok(true) = term.handle_input().await {
                                return true;
                            }
                            false
                        })
                    } else {
                        false
                    }
                };
                
                if should_quit {
                    break;
                }
                
                // Render
                if let Ok(mut term) = terminal_clone.lock() {
                    let _ = rt.block_on(term.render());
                }
                
                // Small sleep to avoid busy-waiting
                std::thread::sleep(Duration::from_millis(200));
            }
        });

        // Spawn HTTP API server task
        let api_task = tokio::spawn(async move {
            warp::serve(api_routes)
                .run(([127, 0, 0, 1], 8081))
                .await;
        });

        // Spawn message processing task
        let channel_manager_msg = Arc::clone(&self.channel_manager);
        let message_task = tokio::spawn(async move {
            Self::process_queued_messages(channel_manager_msg).await;
        });

        // Main server loop
        let channel_manager_ws = Arc::clone(&self.channel_manager);
        let server_result = tokio::select! {
            result = self.accept_connections(listener, channel_manager_ws) => result,
            _ = tokio::signal::ctrl_c() => {
                println!("\nðŸ›‘ Shutting down server...");
                Ok(())
            }
        };

        // Cleanup
        terminal_task.abort();
        api_task.abort();
        message_task.abort();
        if let Ok(mut term) = terminal.lock() {
            let _ = term.cleanup();
        }

        server_result
    }

    /// Accept WebSocket connections
    async fn accept_connections(
        &self,
        listener: TcpListener,
        channel_manager: Arc<ChannelIsolation>,
    ) -> Result<()> {
        while let Ok((stream, addr)) = listener.accept().await {
            let channel_manager_clone = Arc::clone(&channel_manager);
            let default_channel = self.default_channel.clone();

            let message_history_clone = Arc::clone(&self.message_history);
            let broadcast_clone = Arc::clone(&self.broadcast_manager);
            tokio::spawn(async move {
                if let Err(e) = Self::handle_connection(
                    stream,
                    addr,
                    channel_manager_clone,
                    default_channel,
                    message_history_clone,
                    broadcast_clone,
                ).await {
                    eprintln!("Connection error: {}", e);
                }
            });
        }

        Ok(())
    }

    /// Handle a single WebSocket connection
    async fn handle_connection(
        stream: tokio::net::TcpStream,
        addr: std::net::SocketAddr,
        channel_manager: Arc<ChannelIsolation>,
        default_channel: String,
        message_history: Arc<crate::server::history::MessageHistory>,
        broadcast_manager: Arc<crate::server::broadcast::BroadcastManager>,
    ) -> Result<()> {
        let ws_stream = accept_async(stream).await
            .context("WebSocket handshake failed")?;

        println!("[{}] New WebSocket connection", addr);

        let (mut ws_sender, mut ws_receiver) = ws_stream.split();
        let (tx, rx) = tokio::sync::mpsc::unbounded_channel();
        let mut channel_name = default_channel.clone();

        // Determine connection type (default to Agent, can be changed by protocol)
        let connection_type = crate::server::broadcast::ConnectionType::Agent;
        let connection_id = broadcast_manager.add_viewer(connection_type, tx).await;

        // Track connection
        channel_manager.add_connection(&channel_name);

        // Handle incoming messages and forward outgoing messages
        let mut forward_task = tokio::spawn(async move {
            let mut rx = rx;
            while let Some(msg) = rx.recv().await {
                if SinkExt::send(&mut ws_sender, msg).await.is_err() {
                    break;
                }
            }
        });

        // Handle incoming messages
        while let Some(msg) = ws_receiver.next().await {
            match msg {
                Ok(WsMessage::Text(text)) => {
                    // Parse incoming message
                    match serde_json::from_str::<Message>(&text) {
                        Ok(message) => {
                            // Update channel if specified
                            channel_name = message.channel.clone();

                            // Store message in history
                            let history_clone = Arc::clone(&message_history);
                            let broadcast_clone = Arc::clone(&broadcast_manager);
                            let channel_clone = channel_name.clone();
                            let message_clone = message.clone();
                            tokio::spawn(async move {
                                history_clone.add_message(&channel_clone, message_clone.clone()).await;
                                // Broadcast to viewers
                                broadcast_clone.broadcast_message(&message_clone).await;
                            });

                            // Enqueue message
                            channel_manager.enqueue_message(&channel_name, message);

                            println!("[{}] Message queued in channel '{}'", addr, channel_name);
                        }
                        Err(e) => {
                            eprintln!("[{}] Failed to parse message: {}", addr, e);
                        }
                    }
                }
                Ok(WsMessage::Close(_)) => {
                    println!("[{}] Connection closed", addr);
                    break;
                }
                Err(e) => {
                    eprintln!("[{}] WebSocket error: {}", addr, e);
                    break;
                }
                _ => {}
            }
        }

        // Cleanup
        forward_task.abort();
        broadcast_manager.remove_viewer(&connection_id).await;
        channel_manager.remove_connection(&channel_name);

        Ok(())
    }

    /// Process queued messages and display them to users
    async fn process_queued_messages(channel_manager: Arc<ChannelIsolation>) {
        let mut check_interval = interval(Duration::from_millis(100));

        loop {
            check_interval.tick().await;

            let active_channels = channel_manager.get_active_channels();

            for channel_name in active_channels {
                if let Some(message) = channel_manager.dequeue_message(&channel_name) {

                    // Process message based on type
                    match &message.content {
                        MessageContent::Question { text, timeout_seconds } => {
                            // Create a display-friendly version
                            let question_text = text.clone();
                            Self::handle_question(
                                message.clone(),
                                question_text,
                                *timeout_seconds,
                                channel_manager.clone(),
                            ).await;
                        }
                        MessageContent::Authorization { action, timeout_seconds, .. } => {
                            Self::handle_authorization(
                                message.clone(),
                                action.clone(),
                                *timeout_seconds,
                                channel_manager.clone(),
                            ).await;
                        }
                        MessageContent::Notification { text, priority } => {
                            Self::handle_notification(text.clone(), priority.clone());
                        }
                        _ => {}
                    }
                }
            }
        }
    }

    /// Handle a question message
    async fn handle_question(
        message: Message,
        question_text: String,
        timeout_secs: u32,
        _channel_manager: Arc<ChannelIsolation>,
    ) {
        print!("\nâ“ [{}] {}: ", message.channel, question_text);
        io::stdout().flush().ok();

        let response = if timeout_secs > 0 {
            let timeout_duration = Duration::from_secs(timeout_secs as u64);
            tokio::select! {
                result = Self::read_user_input_async() => {
                    result.unwrap_or_else(|_| {
                        ResponseType::Timeout
                    })
                }
                _ = tokio::time::sleep(timeout_duration) => {
                    println!("\nâ±ï¸  Timeout");
                    ResponseType::Timeout
                }
                _ = tokio::signal::ctrl_c() => {
                    println!("\nâš ï¸  Cancelled");
                    ResponseType::Cancelled
                }
            }
        } else {
            tokio::select! {
                result = Self::read_user_input_async() => {
                    result.unwrap_or_else(|_| ResponseType::Cancelled)
                }
                _ = tokio::signal::ctrl_c() => {
                    println!("\nâš ï¸  Cancelled");
                    ResponseType::Cancelled
                }
            }
        };

        // Create response message
        let answer = match response {
            ResponseType::Text => {
                // This would be set from the actual input
                None
            }
            _ => None,
        };

        let response_content = MessageContent::Response {
            answer,
            response_type: response,
        };

        let response_message = Message::response(
            message.channel.clone(),
            response_content,
            message.id,
        );

        // TODO: Send response back via WebSocket to the original sender
        // For now, just log it
        println!("ðŸ“¤ Response: {:?}", response_message);
    }

    /// Handle an authorization message
    async fn handle_authorization(
        message: Message,
        action: String,
        timeout_secs: u32,
        _channel_manager: Arc<ChannelIsolation>,
    ) {
        println!("\nðŸ” [{}] Authorization Request", message.channel);
        println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
        println!("Action: {}", action);
        if timeout_secs > 0 {
            println!("Timeout: {} seconds", timeout_secs);
        }
        println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
        print!("Authorize? (authorized/denied): ");
        io::stdout().flush().ok();

        let decision = if timeout_secs > 0 {
            let timeout_duration = Duration::from_secs(timeout_secs as u64);
            tokio::select! {
                result = Self::read_authorization_async() => {
                    result.unwrap_or(ResponseType::AuthorizationDenied)
                }
                _ = tokio::time::sleep(timeout_duration) => {
                    println!("\nâ±ï¸  Timeout - DENIED");
                    ResponseType::AuthorizationDenied
                }
                _ = tokio::signal::ctrl_c() => {
                    println!("\nâš ï¸  Cancelled - DENIED");
                    ResponseType::AuthorizationDenied
                }
            }
        } else {
            tokio::select! {
                result = Self::read_authorization_async() => {
                    result.unwrap_or(ResponseType::AuthorizationDenied)
                }
                _ = tokio::signal::ctrl_c() => {
                    println!("\nâš ï¸  Cancelled - DENIED");
                    ResponseType::AuthorizationDenied
                }
            }
        };

        let response_content = MessageContent::Response {
            answer: None,
            response_type: decision,
        };

        let response_message = Message::response(
            message.channel.clone(),
            response_content,
            message.id,
        );

        println!("ðŸ“¤ Authorization response: {:?}", response_message);
    }

    /// Handle a notification message
    fn handle_notification(text: String, _priority: crate::models::NotificationPriority) {
        println!("\nðŸ’¬ {}", text);
    }

    /// Read user input asynchronously
    async fn read_user_input_async() -> Result<ResponseType> {
        let _input = tokio::task::spawn_blocking(|| {
            let mut buffer = String::new();
            io::stdin().read_line(&mut buffer)?;
            Ok::<String, io::Error>(buffer)
        })
        .await
        .context("Failed to read input")?
        .context("Failed to read from stdin")?;

        Ok(ResponseType::Text) // Simplified for now
    }

    /// Read authorization response asynchronously
    async fn read_authorization_async() -> Result<ResponseType> {
        let input = tokio::task::spawn_blocking(|| {
            let mut buffer = String::new();
            io::stdin().read_line(&mut buffer)?;
            Ok::<String, io::Error>(buffer)
        })
        .await
        .context("Failed to read input")?
        .context("Failed to read from stdin")?;

        let normalized = input.trim().to_lowercase();
        match normalized.as_str() {
            "authorized" | "yes" | "y" | "approve" | "ok" => {
                Ok(ResponseType::AuthorizationApproved)
            }
            _ => Ok(ResponseType::AuthorizationDenied),
        }
    }

    /// Calculate current server status
    fn calculate_status(
        channel_manager: &Arc<ChannelIsolation>,
        _default_channel: &str,
    ) -> ServerStatus {
        let active_channels = channel_manager.get_active_channels();
        let mut total_queue = 0;
        let mut total_connections = 0;

        for channel_name in &active_channels {
            total_queue += channel_manager.get_queue_size(channel_name);
            total_connections += channel_manager.get_connection_count(channel_name);
        }

        ServerStatus {
            status: "Running".to_string(),
            total_queue_size: total_queue,
            total_connections,
            active_channels: active_channels.len(),
        }
    }
}
</file>

</files>
