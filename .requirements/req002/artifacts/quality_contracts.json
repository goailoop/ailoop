{
  "meta": {
    "generated_at": "2026-01-13T20:15:00.000000Z",
    "requirement_set": "req002",
    "purpose": "Enforceable quality contracts derived from acceptance criteria - measurable and testable",
    "rules_applied": [
      "No tooling references",
      "Only measurable criteria",
      "Generate test case mappings"
    ]
  },
  "quality_contracts": [
    {
      "id": "QC-001",
      "requirement_id": "REQ-001",
      "interface_id": "IF-001",
      "category": "functional",
      "title": "Mode detection performance and correctness",
      "statement": "System SHALL determine operation mode (direct or server) within 100ms of command execution, correctly identifying mode based on AILOOP_SERVER environment variable presence or absence",
      "measurable_criteria": [
        {
          "criterion": "Mode detection latency",
          "measurement": "Time from command execution start to mode determination",
          "threshold": "<= 100ms",
          "unit": "milliseconds"
        },
        {
          "criterion": "Direct mode detection",
          "measurement": "Mode determined as 'direct' when AILOOP_SERVER env var is absent",
          "threshold": "100% accuracy",
          "unit": "percentage"
        },
        {
          "criterion": "Server mode detection",
          "measurement": "Mode determined as 'server' when AILOOP_SERVER env var is present",
          "threshold": "100% accuracy",
          "unit": "percentage"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-001-01",
          "description": "Verify direct mode detection when AILOOP_SERVER is absent",
          "given": "AILOOP_SERVER environment variable is not set",
          "when": "Execute 'ailoop ask \"test\"' command",
          "then": [
            "System determines operation_mode = 'direct'",
            "Mode detection completes within 100ms",
            "Question is displayed in local terminal (not WebSocket connection attempted)"
          ]
        },
        {
          "test_case_id": "TC-REQ-001-02",
          "description": "Verify server mode detection when AILOOP_SERVER is present",
          "given": "AILOOP_SERVER=http://localhost:8080 environment variable is set",
          "when": "Execute 'ailoop ask \"test\"' command",
          "then": [
            "System determines operation_mode = 'server'",
            "Mode detection completes within 100ms",
            "System attempts WebSocket connection (no local terminal prompt)"
          ]
        }
      ],
      "evidence_requirements": [
        "Mode determination timestamp",
        "Operation mode value",
        "Precedence source used"
      ]
    },
    {
      "id": "QC-002",
      "requirement_id": "REQ-002",
      "interface_id": "IF-002",
      "category": "functional",
      "title": "Direct mode execution correctness",
      "statement": "System SHALL operate in direct mode when AILOOP_SERVER is absent, displaying questions in local terminal within 1 second and capturing user responses without attempting WebSocket connections",
      "measurable_criteria": [
        {
          "criterion": "Question display latency",
          "measurement": "Time from command execution to question display in terminal",
          "threshold": "<= 1 second",
          "unit": "seconds"
        },
        {
          "criterion": "Response capture accuracy",
          "measurement": "User response is correctly captured and returned",
          "threshold": "100% accuracy",
          "unit": "percentage"
        },
        {
          "criterion": "No WebSocket connection attempts",
          "measurement": "Zero WebSocket connection attempts made in direct mode",
          "threshold": "0 attempts",
          "unit": "count"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-002-01",
          "description": "Verify direct mode ask command execution",
          "given": "AILOOP_SERVER env var is not set",
          "when": "Execute 'ailoop ask \"What is your name?\"' command",
          "then": [
            "Question is displayed in local terminal within 1 second",
            "User response is captured and returned to agent",
            "No WebSocket connection attempt is made",
            "Command completes with exit code 0"
          ]
        }
      ],
      "evidence_requirements": [
        "Question display timestamp",
        "User response captured",
        "Exit code",
        "WebSocket connection attempt count (must be 0)"
      ]
    },
    {
      "id": "QC-003",
      "requirement_id": "REQ-003",
      "interface_id": "IF-005",
      "category": "functional",
      "title": "Server mode activation and WebSocket connection",
      "statement": "System SHALL activate server mode when AILOOP_SERVER is set, attempt WebSocket connection to converted URL, and send messages via connection without displaying local terminal prompts",
      "measurable_criteria": [
        {
          "criterion": "WebSocket connection attempt",
          "measurement": "WebSocket connection attempt made to correct URL",
          "threshold": "1 attempt to ws://localhost:8080 (when AILOOP_SERVER=http://localhost:8080)",
          "unit": "count"
        },
        {
          "criterion": "No local terminal prompt",
          "measurement": "Zero local terminal prompts displayed in server mode",
          "threshold": "0 prompts",
          "unit": "count"
        },
        {
          "criterion": "Message transmission",
          "measurement": "Message successfully sent via WebSocket connection",
          "threshold": "1 message sent",
          "unit": "count"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-003-01",
          "description": "Verify server mode activation with AILOOP_SERVER",
          "given": "AILOOP_SERVER=http://localhost:8080 environment variable is set",
          "when": "Execute 'ailoop ask \"test question\"' command",
          "then": [
            "System attempts WebSocket connection to ws://localhost:8080",
            "No local terminal prompt is displayed",
            "Message is sent via WebSocket connection"
          ]
        }
      ],
      "evidence_requirements": [
        "WebSocket connection attempt URL",
        "Local terminal prompt count (must be 0)",
        "Message sent confirmation"
      ]
    },
    {
      "id": "QC-004",
      "requirement_id": "REQ-004",
      "interface_id": "IF-005",
      "category": "functional",
      "title": "URL protocol conversion and WebSocket connection establishment",
      "statement": "System SHALL convert server URL from http/https to ws/wss protocol and establish WebSocket connection successfully",
      "measurable_criteria": [
        {
          "criterion": "HTTP to WS conversion",
          "measurement": "URL http://localhost:8080 converted to ws://localhost:8080",
          "threshold": "100% accuracy",
          "unit": "percentage"
        },
        {
          "criterion": "HTTPS to WSS conversion",
          "measurement": "URL https://example.com:443 converted to wss://example.com:443",
          "threshold": "100% accuracy",
          "unit": "percentage"
        },
        {
          "criterion": "Connection establishment success",
          "measurement": "WebSocket connection established successfully",
          "threshold": "Connection state = 'connected'",
          "unit": "state"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-004-01",
          "description": "Verify HTTP to WS URL conversion",
          "given": "AILOOP_SERVER=http://localhost:8080",
          "when": "Execute command in server mode",
          "then": [
            "URL is converted from http:// to ws:// protocol",
            "WebSocket connection is established successfully"
          ]
        },
        {
          "test_case_id": "TC-REQ-004-02",
          "description": "Verify HTTPS to WSS URL conversion",
          "given": "AILOOP_SERVER=https://example.com:443",
          "when": "Execute command in server mode",
          "then": [
            "URL is converted from https:// to wss:// protocol",
            "WebSocket connection is established successfully"
          ]
        }
      ],
      "evidence_requirements": [
        "Original URL",
        "Converted WebSocket URL",
        "Connection establishment status"
      ]
    },
    {
      "id": "QC-005",
      "requirement_id": "REQ-005",
      "interface_id": "IF-006",
      "category": "functional",
      "title": "Correlation ID generation uniqueness and format",
      "statement": "System SHALL create Message objects with globally unique correlation_id in UUID format (8-4-4-4-12 hexadecimal) for all message types",
      "measurable_criteria": [
        {
          "criterion": "Correlation ID presence",
          "measurement": "Message object contains correlation_id field",
          "threshold": "100% of messages",
          "unit": "percentage"
        },
        {
          "criterion": "UUID format compliance",
          "measurement": "correlation_id matches UUID format (8-4-4-4-12 hexadecimal)",
          "threshold": "100% compliance",
          "unit": "percentage"
        },
        {
          "criterion": "Global uniqueness",
          "measurement": "All correlation_ids are unique across 1000 messages",
          "threshold": "0 duplicates in 1000 messages",
          "unit": "duplicate count"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-005-01",
          "description": "Verify correlation_id generation for question messages",
          "given": "WebSocket client ready to send question message",
          "when": "Send question message via WebSocket client",
          "then": [
            "Message object contains correlation_id field",
            "correlation_id is UUID format (8-4-4-4-12 hexadecimal)",
            "correlation_id is unique"
          ]
        },
        {
          "test_case_id": "TC-REQ-005-02",
          "description": "Verify correlation_id uniqueness across message types",
          "given": "WebSocket client ready to send multiple messages",
          "when": "Send question, authorization, and notification messages",
          "then": [
            "Each message has unique correlation_id",
            "All correlation_ids are in UUID format",
            "No duplicate correlation_ids across 1000 messages"
          ]
        }
      ],
      "evidence_requirements": [
        "Message correlation_id values",
        "UUID format validation results",
        "Uniqueness check results (duplicate count)"
      ]
    },
    {
      "id": "QC-006",
      "requirement_id": "REQ-006",
      "interface_id": "IF-006",
      "category": "functional",
      "title": "Message serialization and transmission",
      "statement": "System SHALL serialize Message objects to valid JSON format and send via WebSocket connection, with messages arriving at server within 1 second",
      "measurable_criteria": [
        {
          "criterion": "JSON serialization validity",
          "measurement": "Message serialized to valid JSON format",
          "threshold": "100% valid JSON",
          "unit": "percentage"
        },
        {
          "criterion": "Message transmission",
          "measurement": "JSON message sent via WebSocket connection",
          "threshold": "1 message sent",
          "unit": "count"
        },
        {
          "criterion": "Message arrival latency",
          "measurement": "Time from send to server receipt",
          "threshold": "<= 1 second",
          "unit": "seconds"
        },
        {
          "criterion": "Server parseability",
          "measurement": "Server can parse received JSON message",
          "threshold": "100% parseable",
          "unit": "percentage"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-006-01",
          "description": "Verify message serialization and transmission",
          "given": "Message object with question content and WebSocket connection established",
          "when": "Serialize and send message via WebSocket",
          "then": [
            "Message is serialized to valid JSON format",
            "JSON message is sent via WebSocket connection",
            "Message arrives at server within 1 second",
            "Server can parse received JSON message"
          ]
        }
      ],
      "evidence_requirements": [
        "Serialized JSON message",
        "JSON validity check result",
        "Message send timestamp",
        "Server receipt timestamp",
        "Server parse result"
      ]
    },
    {
      "id": "QC-007",
      "requirement_id": "REQ-007",
      "interface_id": "IF-015",
      "category": "functional",
      "title": "Connection tracking accuracy and persistence",
      "statement": "System SHALL record mapping between incoming messages and originating WebSocket connections, maintaining separate mappings for each connection, with mappings persisting until response is sent or connection closes",
      "measurable_criteria": [
        {
          "criterion": "Mapping creation",
          "measurement": "Server records mapping between message and connection",
          "threshold": "1 mapping per message",
          "unit": "count"
        },
        {
          "criterion": "Mapping separation",
          "measurement": "Separate mappings maintained for different connections",
          "threshold": "100% separation accuracy",
          "unit": "percentage"
        },
        {
          "criterion": "Mapping persistence",
          "measurement": "Mapping persists until response sent or connection closes",
          "threshold": "Mapping exists until response/close event",
          "unit": "state"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-007-01",
          "description": "Verify connection mapping creation",
          "given": "WebSocket connection established",
          "when": "Send message from WebSocket client to server",
          "then": [
            "Server records mapping between message and connection",
            "Mapping persists until response is sent or connection closes"
          ]
        },
        {
          "test_case_id": "TC-REQ-007-02",
          "description": "Verify separate mappings for different connections",
          "given": "Two WebSocket connections established",
          "when": "Send messages from both connections",
          "then": [
            "Server maintains separate mappings for each connection",
            "Mappings do not interfere with each other"
          ]
        }
      ],
      "evidence_requirements": [
        "Connection mapping records",
        "Mapping persistence duration",
        "Mapping separation verification"
      ]
    },
    {
      "id": "QC-008",
      "requirement_id": "REQ-008",
      "interface_id": "IF-019",
      "category": "functional",
      "title": "Channel-specific message queuing and isolation",
      "statement": "System SHALL add messages to channel-specific queues, maintaining complete channel isolation where messages in different channels cannot access each other",
      "measurable_criteria": [
        {
          "criterion": "Channel queue assignment",
          "measurement": "Message added to correct channel queue",
          "threshold": "100% accuracy",
          "unit": "percentage"
        },
        {
          "criterion": "Channel isolation",
          "measurement": "Messages in different channels cannot access each other",
          "threshold": "0 cross-channel accesses",
          "unit": "count"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-008-01",
          "description": "Verify channel-specific queuing",
          "given": "Server with channel queues",
          "when": "Send messages with channel='test-channel' and channel='other-channel'",
          "then": [
            "Message with channel='test-channel' is added to 'test-channel' queue",
            "Message with channel='other-channel' is added to 'other-channel' queue",
            "Messages in different channels are isolated (cannot access cross-channel)"
          ]
        }
      ],
      "evidence_requirements": [
        "Channel queue assignments",
        "Cross-channel access attempts (must be 0)",
        "Channel isolation verification"
      ]
    },
    {
      "id": "QC-009",
      "requirement_id": "REQ-009",
      "interface_id": "IF-010",
      "category": "functional",
      "title": "Message display latency and accuracy",
      "statement": "System SHALL display queued messages in server terminal UI within 500ms of enqueueing, with message content matching exactly what was sent",
      "measurable_criteria": [
        {
          "criterion": "Display latency",
          "measurement": "Time from enqueue to display in terminal UI",
          "threshold": "<= 500ms",
          "unit": "milliseconds"
        },
        {
          "criterion": "Content accuracy",
          "measurement": "Displayed message content matches sent message content",
          "threshold": "100% match",
          "unit": "percentage"
        },
        {
          "criterion": "Display order",
          "measurement": "Messages appear in order of enqueueing",
          "threshold": "FIFO order maintained",
          "unit": "order"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-009-01",
          "description": "Verify message display in terminal UI",
          "given": "Question message enqueued in server channel queue",
          "when": "Message is displayed in server terminal UI",
          "then": [
            "Question text appears in server terminal UI within 500ms",
            "Message content matches exactly what was sent",
            "Messages appear in order of enqueueing"
          ]
        }
      ],
      "evidence_requirements": [
        "Enqueue timestamp",
        "Display timestamp",
        "Displayed message content",
        "Original message content",
        "Content match verification"
      ]
    },
    {
      "id": "QC-010",
      "requirement_id": "REQ-010",
      "interface_id": "IF-011",
      "category": "functional",
      "title": "Response correlation ID matching",
      "statement": "System SHALL create response Message with correlation_id set to the id of the original request message",
      "measurable_criteria": [
        {
          "criterion": "Correlation ID match",
          "measurement": "Response correlation_id matches original request id",
          "threshold": "100% match accuracy",
          "unit": "percentage"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-010-01",
          "description": "Verify response correlation_id matching",
          "given": "Question message with id='msg-123' sent to server",
          "when": "Human provides response in server terminal",
          "then": [
            "Response Message has correlation_id='msg-123'",
            "correlation_id matches original request id exactly"
          ]
        }
      ],
      "evidence_requirements": [
        "Original request message id",
        "Response message correlation_id",
        "Match verification result"
      ]
    },
    {
      "id": "QC-011",
      "requirement_id": "REQ-011",
      "interface_id": "IF-011",
      "category": "functional",
      "title": "Response routing accuracy",
      "statement": "System SHALL route response messages back to originating WebSocket connections using connection tracking, ensuring responses are sent via correct connections",
      "measurable_criteria": [
        {
          "criterion": "Connection identification",
          "measurement": "Server uses connection tracking to identify originating connection",
          "threshold": "100% accuracy",
          "unit": "percentage"
        },
        {
          "criterion": "Response routing accuracy",
          "measurement": "Response sent via correct originating connection",
          "threshold": "100% accuracy",
          "unit": "percentage"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-011-01",
          "description": "Verify response routing to correct connection",
          "given": "Messages sent from WebSocket connections A and B",
          "when": "Create responses with matching correlation_ids",
          "then": [
            "Server uses connection tracking to identify connection A for first response",
            "Response for first request is sent via connection A (not connection B)",
            "Response for second request is sent via connection B (not connection A)"
          ]
        }
      ],
      "evidence_requirements": [
        "Connection tracking lookup results",
        "Response routing destinations",
        "Routing accuracy verification"
      ]
    },
    {
      "id": "QC-012",
      "requirement_id": "REQ-012",
      "interface_id": "IF-007",
      "category": "functional",
      "title": "Response matching using correlation ID",
      "statement": "System SHALL maintain map of pending requests keyed by correlation_id and match response correlation_id to correct pending request using lookup",
      "measurable_criteria": [
        {
          "criterion": "Pending request tracking",
          "measurement": "Pending requests maintained in map keyed by correlation_id",
          "threshold": "1 entry per pending request",
          "unit": "count"
        },
        {
          "criterion": "Response matching accuracy",
          "measurement": "Response correctly matched to pending request using correlation_id",
          "threshold": "100% accuracy",
          "unit": "percentage"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-012-01",
          "description": "Verify response matching to pending requests",
          "given": "Two requests sent with correlation_id='req-1' and correlation_id='req-2'",
          "when": "Receive responses with correlation_id='req-1' and correlation_id='req-2'",
          "then": [
            "Response with correlation_id='req-1' is matched to first request",
            "Response with correlation_id='req-2' is matched to second request",
            "Map lookup correctly matches correlation_ids"
          ]
        }
      ],
      "evidence_requirements": [
        "Pending requests map contents",
        "Response correlation_ids",
        "Match results"
      ]
    },
    {
      "id": "QC-013",
      "requirement_id": "REQ-013",
      "interface_id": "IF-007",
      "category": "functional",
      "title": "Response waiting with timeout rules",
      "statement": "System SHALL wait for response Message from server with matching correlation_id, applying timeout rules: timeout_seconds > 0 applies finite timeout, timeout_seconds = 0 waits indefinitely",
      "measurable_criteria": [
        {
          "criterion": "Waiting behavior",
          "measurement": "Client waits for response with matching correlation_id",
          "threshold": "Waits until response received or timeout",
          "unit": "behavior"
        },
        {
          "criterion": "Finite timeout application",
          "measurement": "When timeout_seconds=5, timeout is applied (5 seconds)",
          "threshold": "Timeout occurs at 5 seconds (within 100ms tolerance)",
          "unit": "seconds"
        },
        {
          "criterion": "Indefinite wait",
          "measurement": "When timeout_seconds=0, client waits indefinitely",
          "threshold": "No timeout after 60 seconds",
          "unit": "timeout occurrence"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-013-01",
          "description": "Verify waiting for response with finite timeout",
          "given": "timeout_seconds=5 in config, question message sent",
          "when": "Wait for response",
          "then": [
            "Client waits for response with matching correlation_id",
            "Timeout rules (REQ-016) are applied (timeout set to 5 seconds)",
            "Timeout occurs at 5 seconds (within 100ms tolerance)"
          ]
        },
        {
          "test_case_id": "TC-REQ-013-02",
          "description": "Verify indefinite wait when timeout_seconds=0",
          "given": "timeout_seconds=0 in config, question message sent",
          "when": "Wait for response",
          "then": [
            "Client waits indefinitely (no timeout after 60 seconds)",
            "Timeout rules (REQ-017) are applied correctly"
          ]
        }
      ],
      "evidence_requirements": [
        "Timeout configuration value",
        "Wait start timestamp",
        "Timeout occurrence timestamp (if applicable)",
        "Response received timestamp (if applicable)"
      ]
    },
    {
      "id": "QC-014",
      "requirement_id": "REQ-014",
      "interface_id": "IF-005",
      "category": "error_handling",
      "title": "Connection error message format and behavior",
      "statement": "System SHALL display error message in format 'Failed to connect to server at {URL}: {error_type}. Ensure server is running and accessible.' and exit with error code 1, without falling back to direct mode",
      "measurable_criteria": [
        {
          "criterion": "Error message format",
          "measurement": "Error message matches required format with URL and error_type",
          "threshold": "100% format compliance",
          "unit": "percentage"
        },
        {
          "criterion": "Error type specificity",
          "measurement": "error_type is specific (connection refused, network unreachable, etc.)",
          "threshold": "Specific error type provided",
          "unit": "presence"
        },
        {
          "criterion": "Exit code",
          "measurement": "Command exits with error code 1",
          "threshold": "exit_code = 1",
          "unit": "exit code"
        },
        {
          "criterion": "No fallback to direct mode",
          "measurement": "System does NOT fall back to direct mode",
          "threshold": "0 fallback occurrences",
          "unit": "count"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-014-01",
          "description": "Verify connection error handling",
          "given": "AILOOP_SERVER=http://unreachable:8080, server is unreachable",
          "when": "Execute 'ailoop ask \"test\"' command",
          "then": [
            "Error message format: 'Failed to connect to server at http://unreachable:8080: {error_type}. Ensure server is running and accessible.'",
            "error_type is specific (connection refused, network unreachable, etc.)",
            "Command exits with error code 1",
            "System does NOT fall back to direct mode"
          ]
        }
      ],
      "evidence_requirements": [
        "Error message text",
        "Error message format compliance",
        "Exit code",
        "Fallback occurrence count (must be 0)"
      ]
    },
    {
      "id": "QC-016",
      "requirement_id": "REQ-016",
      "interface_id": "IF-007",
      "category": "functional",
      "title": "Finite timeout application from configuration",
      "statement": "System SHALL apply timeout_seconds from configuration file as maximum wait time for server response when timeout_seconds > 0",
      "measurable_criteria": [
        {
          "criterion": "Timeout application",
          "measurement": "Timeout of configured seconds is applied",
          "threshold": "Timeout occurs at configured value (within 100ms tolerance)",
          "unit": "seconds"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-016-01",
          "description": "Verify finite timeout application",
          "given": "timeout_seconds=10 in configuration file, question message sent",
          "when": "Wait for response without receiving one",
          "then": [
            "Timeout of 10 seconds is applied",
            "Timeout error occurs at 10 seconds (within 100ms tolerance)"
          ]
        }
      ],
      "evidence_requirements": [
        "Configuration timeout_seconds value",
        "Timeout occurrence timestamp",
        "Expected timeout timestamp",
        "Tolerance verification"
      ]
    },
    {
      "id": "QC-017",
      "requirement_id": "REQ-017",
      "interface_id": "IF-007",
      "category": "functional",
      "title": "Indefinite wait when timeout is 0",
      "statement": "System SHALL wait indefinitely for server response when configuration timeout_seconds is 0, without timeout expiration",
      "measurable_criteria": [
        {
          "criterion": "Indefinite wait",
          "measurement": "No timeout error occurs after 60 seconds",
          "threshold": "0 timeout errors after 60 seconds",
          "unit": "count"
        },
        {
          "criterion": "Extended wait",
          "measurement": "No timeout error occurs after 300 seconds",
          "threshold": "0 timeout errors after 300 seconds",
          "unit": "count"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-017-01",
          "description": "Verify indefinite wait when timeout_seconds=0",
          "given": "timeout_seconds=0 in configuration file, question message sent",
          "when": "Wait for response without receiving one",
          "then": [
            "No timeout error occurs after 60 seconds",
            "No timeout error occurs after 300 seconds",
            "System waits indefinitely"
          ]
        }
      ],
      "evidence_requirements": [
        "Configuration timeout_seconds value (must be 0)",
        "Wait duration",
        "Timeout error occurrence count (must be 0)"
      ]
    },
    {
      "id": "QC-018",
      "requirement_id": "REQ-018",
      "interface_id": "IF-007",
      "category": "error_handling",
      "title": "Timeout error handling",
      "statement": "System SHALL display timeout error message and exit with error code 1 when timeout expires while waiting for server response",
      "measurable_criteria": [
        {
          "criterion": "Timeout error message",
          "measurement": "Timeout error message is displayed",
          "threshold": "Error message present",
          "unit": "presence"
        },
        {
          "criterion": "Exit code",
          "measurement": "Command exits with error code 1",
          "threshold": "exit_code = 1",
          "unit": "exit code"
        },
        {
          "criterion": "Timeout precision",
          "measurement": "Timeout occurs within 100ms of configured timeout",
          "threshold": "<= 100ms deviation",
          "unit": "milliseconds"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-018-01",
          "description": "Verify timeout error handling",
          "given": "timeout_seconds=5 in configuration, question message sent",
          "when": "Wait 6 seconds without receiving response",
          "then": [
            "Timeout error message is displayed",
            "Command exits with error code 1",
            "Timeout occurs within 100ms of configured timeout (5 seconds)"
          ]
        }
      ],
      "evidence_requirements": [
        "Timeout error message text",
        "Exit code",
        "Timeout occurrence timestamp",
        "Expected timeout timestamp",
        "Deviation calculation"
      ]
    },
    {
      "id": "QC-020",
      "requirement_id": "REQ-020",
      "interface_id": "IF-018",
      "category": "validation",
      "title": "Channel name validation consistency",
      "statement": "System SHALL apply same channel name validation rules regardless of operation mode (direct or server)",
      "measurable_criteria": [
        {
          "criterion": "Validation consistency",
          "measurement": "Same validation rules applied in both modes",
          "threshold": "100% consistency",
          "unit": "percentage"
        },
        {
          "criterion": "Error consistency",
          "measurement": "Same validation errors in both modes",
          "threshold": "100% consistency",
          "unit": "percentage"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-020-01",
          "description": "Verify channel validation consistency",
          "given": "Invalid channel name 'invalid-channel!'",
          "when": "Execute command with --channel invalid-channel! in direct mode and server mode",
          "then": [
            "Same channel validation error occurs in both modes",
            "Validation rules are identical in both modes"
          ]
        }
      ],
      "evidence_requirements": [
        "Direct mode validation result",
        "Server mode validation result",
        "Validation consistency verification"
      ]
    },
    {
      "id": "QC-021",
      "requirement_id": "REQ-021",
      "interface_id": "IF-025",
      "category": "functional",
      "title": "JSON output format consistency",
      "statement": "System SHALL generate JSON output with same structure and fields regardless of operation mode (direct or server)",
      "measurable_criteria": [
        {
          "criterion": "JSON structure consistency",
          "measurement": "JSON structures are identical in both modes",
          "threshold": "100% structure match",
          "unit": "percentage"
        },
        {
          "criterion": "Field consistency",
          "measurement": "Same fields present in both modes",
          "threshold": "100% field match",
          "unit": "percentage"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-021-01",
          "description": "Verify JSON output format consistency",
          "given": "Same question asked in both direct mode and server mode with --json flag",
          "when": "Execute 'ailoop ask \"test\"' --json in both modes",
          "then": [
            "JSON output structures are identical",
            "Same fields are present in both modes",
            "JSON format is consistent"
          ]
        }
      ],
      "evidence_requirements": [
        "Direct mode JSON output",
        "Server mode JSON output",
        "Structure comparison result",
        "Field comparison result"
      ]
    },
    {
      "id": "QC-022",
      "requirement_id": "REQ-022",
      "interface_id": "IF-006",
      "category": "functional",
      "title": "Server mode ask command execution",
      "statement": "System SHALL send question to server, wait for human response subject to timeout rules, and return response to agent",
      "measurable_criteria": [
        {
          "criterion": "Question transmission",
          "measurement": "Question is sent to server via WebSocket",
          "threshold": "1 message sent",
          "unit": "count"
        },
        {
          "criterion": "Response reception",
          "measurement": "Response is received by client",
          "threshold": "1 response received",
          "unit": "count"
        },
        {
          "criterion": "Response return",
          "measurement": "Response is returned to agent",
          "threshold": "1 response returned",
          "unit": "count"
        },
        {
          "criterion": "Timeout rules application",
          "measurement": "Timeout rules are applied during wait",
          "threshold": "Timeout rules correctly applied",
          "unit": "behavior"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-022-01",
          "description": "Verify server mode ask command",
          "given": "AILOOP_SERVER set, server running",
          "when": "Execute 'ailoop ask \"What is the answer?\"'",
          "then": [
            "Question is sent to server via WebSocket",
            "Response is provided in server terminal",
            "Response is received by client",
            "Response is returned to agent",
            "Timeout rules are applied during wait"
          ]
        }
      ],
      "evidence_requirements": [
        "Question sent confirmation",
        "Response received confirmation",
        "Response returned confirmation",
        "Timeout rules application verification"
      ]
    },
    {
      "id": "QC-023",
      "requirement_id": "REQ-023",
      "interface_id": "IF-006",
      "category": "functional",
      "title": "Server mode authorize command execution",
      "statement": "System SHALL send authorization request to server, wait for human decision subject to timeout rules, and return approval/denial to agent with appropriate exit codes",
      "measurable_criteria": [
        {
          "criterion": "Authorization request transmission",
          "measurement": "Authorization request is sent to server",
          "threshold": "1 request sent",
          "unit": "count"
        },
        {
          "criterion": "Approval handling",
          "measurement": "When authorized, command exits with code 0",
          "threshold": "exit_code = 0 for authorized",
          "unit": "exit code"
        },
        {
          "criterion": "Denial handling",
          "measurement": "When denied, command exits with code 1",
          "threshold": "exit_code = 1 for denied",
          "unit": "exit code"
        },
        {
          "criterion": "Timeout rules application",
          "measurement": "Timeout rules are applied during wait",
          "threshold": "Timeout rules correctly applied",
          "unit": "behavior"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-023-01",
          "description": "Verify server mode authorize command with approval",
          "given": "AILOOP_SERVER set, server running",
          "when": "Execute 'ailoop authorize \"Deploy to prod\"' and provide 'authorized' response",
          "then": [
            "Authorization request is sent to server",
            "Approval decision is received by client",
            "Command exits with code 0 (authorized)"
          ]
        },
        {
          "test_case_id": "TC-REQ-023-02",
          "description": "Verify server mode authorize command with denial",
          "given": "AILOOP_SERVER set, server running",
          "when": "Execute 'ailoop authorize \"Deploy to prod\"' and provide 'denied' response",
          "then": [
            "Authorization request is sent to server",
            "Denial decision is received by client",
            "Command exits with code 1 (denied)"
          ]
        }
      ],
      "evidence_requirements": [
        "Authorization request sent confirmation",
        "Authorization decision received",
        "Exit code",
        "Timeout rules application verification"
      ]
    },
    {
      "id": "QC-024",
      "requirement_id": "REQ-024",
      "interface_id": "IF-006",
      "category": "functional",
      "title": "Server mode say command execution",
      "statement": "System SHALL send notification message to server and complete immediately without waiting for response",
      "measurable_criteria": [
        {
          "criterion": "Notification transmission",
          "measurement": "Notification is sent to server via WebSocket",
          "threshold": "1 notification sent",
          "unit": "count"
        },
        {
          "criterion": "Immediate completion",
          "measurement": "Command completes within 1 second",
          "threshold": "<= 1 second",
          "unit": "seconds"
        },
        {
          "criterion": "No response waiting",
          "measurement": "No response waiting occurs",
          "threshold": "0 wait operations",
          "unit": "count"
        },
        {
          "criterion": "Success exit code",
          "measurement": "Command exits with success code 0",
          "threshold": "exit_code = 0",
          "unit": "exit code"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-024-01",
          "description": "Verify server mode say command",
          "given": "AILOOP_SERVER set, server running",
          "when": "Execute 'ailoop say \"Notification\"'",
          "then": [
            "Notification is sent to server via WebSocket",
            "Command completes immediately (within 1 second)",
            "No response waiting occurs",
            "Notification appears in server terminal UI",
            "Command exits with success code 0"
          ]
        }
      ],
      "evidence_requirements": [
        "Notification sent confirmation",
        "Command completion timestamp",
        "Response wait count (must be 0)",
        "Exit code"
      ]
    },
    {
      "id": "QC-025",
      "requirement_id": "REQ-025",
      "interface_id": "IF-023",
      "category": "error_handling",
      "title": "No fallback to direct mode on connection failure",
      "statement": "System SHALL NOT fall back to direct mode when server connection fails in server mode",
      "measurable_criteria": [
        {
          "criterion": "No fallback",
          "measurement": "System does NOT fall back to direct mode",
          "threshold": "0 fallback occurrences",
          "unit": "count"
        },
        {
          "criterion": "Error reporting",
          "measurement": "Error is reported and command fails",
          "threshold": "Error reported, exit_code = 1",
          "unit": "state"
        },
        {
          "criterion": "No local prompt",
          "measurement": "No local terminal prompt appears",
          "threshold": "0 local prompts",
          "unit": "count"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-025-01",
          "description": "Verify no fallback to direct mode",
          "given": "AILOOP_SERVER=http://unreachable:8080, server is unreachable",
          "when": "Execute 'ailoop ask \"test\"' command",
          "then": [
            "Connection fails",
            "System does NOT fall back to direct mode",
            "Error is reported and command fails",
            "No local terminal prompt appears"
          ]
        }
      ],
      "evidence_requirements": [
        "Fallback occurrence count (must be 0)",
        "Error message",
        "Exit code",
        "Local prompt count (must be 0)"
      ]
    },
    {
      "id": "QC-026",
      "requirement_id": "REQ-026",
      "interface_id": "IF-016",
      "category": "functional",
      "title": "Response routing accuracy to connections",
      "statement": "System SHALL NOT route response messages to incorrect WebSocket connections",
      "measurable_criteria": [
        {
          "criterion": "Routing accuracy",
          "measurement": "Responses routed to correct originating connections",
          "threshold": "100% accuracy",
          "unit": "percentage"
        },
        {
          "criterion": "No incorrect routing",
          "measurement": "Responses never go to wrong connections",
          "threshold": "0 incorrect routings",
          "unit": "count"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-026-01",
          "description": "Verify response routing accuracy",
          "given": "Requests sent from connections A and B with correlation_id='req-a' and 'req-b'",
          "when": "Send responses for req-a and req-b",
          "then": [
            "Response for req-a is routed to connection A (not B)",
            "Response for req-b is routed to connection B (not A)",
            "Responses never go to wrong connections"
          ]
        }
      ],
      "evidence_requirements": [
        "Response routing destinations",
        "Originating connection identifiers",
        "Routing accuracy verification",
        "Incorrect routing count (must be 0)"
      ]
    },
    {
      "id": "QC-027",
      "requirement_id": "REQ-027",
      "interface_id": "IF-013",
      "category": "functional",
      "title": "Correlation ID global uniqueness",
      "statement": "System SHALL NOT allow duplicate correlation_id values across different messages",
      "measurable_criteria": [
        {
          "criterion": "Uniqueness across messages",
          "measurement": "All correlation_ids are unique across 1000 messages",
          "threshold": "0 duplicates in 1000 messages",
          "unit": "duplicate count"
        },
        {
          "criterion": "UUID format",
          "measurement": "correlation_id format is valid UUID",
          "threshold": "100% valid UUID format",
          "unit": "percentage"
        },
        {
          "criterion": "Cross-connection uniqueness",
          "measurement": "correlation_id uniqueness across different connections",
          "threshold": "0 duplicates across connections",
          "unit": "duplicate count"
        },
        {
          "criterion": "Cross-channel uniqueness",
          "measurement": "correlation_id uniqueness across different channels",
          "threshold": "0 duplicates across channels",
          "unit": "duplicate count"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-027-01",
          "description": "Verify correlation_id uniqueness",
          "given": "System generating messages",
          "when": "Generate 1000 messages and collect all correlation_ids",
          "then": [
            "All correlation_ids are unique (no duplicates)",
            "correlation_id format is valid UUID",
            "correlation_id uniqueness across different connections",
            "correlation_id uniqueness across different channels"
          ]
        }
      ],
      "evidence_requirements": [
        "Generated correlation_ids",
        "Duplicate count (must be 0)",
        "UUID format validation results",
        "Cross-connection uniqueness check",
        "Cross-channel uniqueness check"
      ]
    },
    {
      "id": "QC-028",
      "requirement_id": "REQ-028",
      "interface_id": "IF-015",
      "category": "functional",
      "title": "Connection tracking persistence",
      "statement": "System SHALL NOT lose connection tracking information when WebSocket connection is established",
      "measurable_criteria": [
        {
          "criterion": "Tracking information recording",
          "measurement": "Connection tracking information is recorded",
          "threshold": "Tracking information present",
          "unit": "presence"
        },
        {
          "criterion": "Tracking usage",
          "measurement": "Connection tracking is used for response routing",
          "threshold": "Tracking used for routing",
          "unit": "usage"
        },
        {
          "criterion": "Tracking persistence",
          "measurement": "Connection tracking persists until connection closes",
          "threshold": "Tracking persists until close",
          "unit": "duration"
        },
        {
          "criterion": "No information loss",
          "measurement": "No connection tracking information is lost",
          "threshold": "0 information loss events",
          "unit": "count"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-028-01",
          "description": "Verify connection tracking persistence",
          "given": "WebSocket connection established",
          "when": "Send message and then send response",
          "then": [
            "Connection tracking information is recorded",
            "Connection tracking is used for response routing",
            "Connection tracking persists until connection closes",
            "No connection tracking information is lost"
          ]
        }
      ],
      "evidence_requirements": [
        "Connection tracking information recorded",
        "Tracking usage for routing",
        "Tracking persistence duration",
        "Information loss count (must be 0)"
      ]
    },
    {
      "id": "QC-029",
      "requirement_id": "REQ-029",
      "interface_id": "IF-019",
      "category": "functional",
      "title": "Channel isolation enforcement",
      "statement": "System SHALL NOT process messages from channels other than the channel specified in the message",
      "measurable_criteria": [
        {
          "criterion": "Channel-specific processing",
          "measurement": "Messages processed in correct channel queue only",
          "threshold": "100% accuracy",
          "unit": "percentage"
        },
        {
          "criterion": "Cross-channel access prevention",
          "measurement": "Messages in different channels cannot access each other",
          "threshold": "0 cross-channel accesses",
          "unit": "count"
        },
        {
          "criterion": "Channel isolation maintenance",
          "measurement": "Channel isolation is maintained",
          "threshold": "100% isolation",
          "unit": "percentage"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-029-01",
          "description": "Verify channel isolation",
          "given": "Messages with channel='channel-a' and channel='channel-b'",
          "when": "Send messages to server",
          "then": [
            "Message with channel='channel-a' is processed in channel-a queue only",
            "Message with channel='channel-b' is processed in channel-b queue only",
            "channel-a messages are not accessible from channel-b",
            "channel-b messages are not accessible from channel-a",
            "Channel isolation is maintained"
          ]
        }
      ],
      "evidence_requirements": [
        "Channel queue assignments",
        "Cross-channel access attempts (must be 0)",
        "Channel isolation verification"
      ]
    },
    {
      "id": "QC-030",
      "requirement_id": "REQ-030",
      "interface_id": "IF-011",
      "category": "error_handling",
      "title": "Closed connection handling",
      "statement": "System SHALL NOT send response messages if the originating WebSocket connection has been closed",
      "measurable_criteria": [
        {
          "criterion": "Connection closure detection",
          "measurement": "Server detects connection is closed",
          "threshold": "Closure detected",
          "unit": "detection"
        },
        {
          "criterion": "No send to closed connection",
          "measurement": "Server does NOT attempt to send response to closed connection",
          "threshold": "0 send attempts to closed connections",
          "unit": "count"
        },
        {
          "criterion": "No errors from closed connection",
          "measurement": "No error occurs from sending to closed connection",
          "threshold": "0 errors",
          "unit": "count"
        },
        {
          "criterion": "Graceful handling",
          "measurement": "Closed connections are handled gracefully",
          "threshold": "Graceful handling",
          "unit": "behavior"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-030-01",
          "description": "Verify closed connection handling",
          "given": "Request sent from WebSocket connection",
          "when": "Close WebSocket connection before response is ready",
          "then": [
            "Server detects connection is closed",
            "Server does NOT attempt to send response to closed connection",
            "No error occurs from sending to closed connection",
            "Closed connections are handled gracefully"
          ]
        }
      ],
      "evidence_requirements": [
        "Connection closure detection",
        "Send attempt count to closed connections (must be 0)",
        "Error count (must be 0)",
        "Graceful handling verification"
      ]
    },
    {
      "id": "QC-031",
      "requirement_id": "REQ-031",
      "interface_id": "IF-010",
      "category": "validation",
      "title": "Message format validation",
      "statement": "System SHALL NOT allow WebSocket connections without proper message format validation",
      "measurable_criteria": [
        {
          "criterion": "Malformed JSON rejection",
          "measurement": "Server rejects malformed JSON messages with validation error",
          "threshold": "100% rejection of malformed JSON",
          "unit": "percentage"
        },
        {
          "criterion": "Missing field rejection",
          "measurement": "Server rejects messages with missing required fields",
          "threshold": "100% rejection",
          "unit": "percentage"
        },
        {
          "criterion": "Invalid type rejection",
          "measurement": "Server rejects messages with invalid field types",
          "threshold": "100% rejection",
          "unit": "percentage"
        },
        {
          "criterion": "Valid message acceptance",
          "measurement": "Only valid messages are processed",
          "threshold": "100% of processed messages are valid",
          "unit": "percentage"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-031-01",
          "description": "Verify message format validation",
          "given": "WebSocket connection established",
          "when": "Send malformed JSON, missing fields, invalid types, and valid messages",
          "then": [
            "Server rejects malformed JSON message with validation error",
            "Server rejects message with missing required fields",
            "Server rejects message with invalid field types",
            "Only valid messages are processed"
          ]
        }
      ],
      "evidence_requirements": [
        "Validation error messages",
        "Rejection count for each invalid message type",
        "Valid message acceptance count"
      ]
    },
    {
      "id": "QC-032",
      "requirement_id": "REQ-032",
      "interface_id": "IF-023",
      "category": "security",
      "title": "Error message information exposure prevention",
      "statement": "System SHALL NOT expose sensitive connection details (internal IPs, connection IDs, internal state) in error messages to clients",
      "measurable_criteria": [
        {
          "criterion": "No internal IP exposure",
          "measurement": "Error message does NOT contain internal IP addresses",
          "threshold": "0 internal IPs in error messages",
          "unit": "count"
        },
        {
          "criterion": "No connection ID exposure",
          "measurement": "Error message does NOT contain connection IDs",
          "threshold": "0 connection IDs in error messages",
          "unit": "count"
        },
        {
          "criterion": "No internal state exposure",
          "measurement": "Error message does NOT contain internal state information",
          "threshold": "0 internal state references",
          "unit": "count"
        },
        {
          "criterion": "User-facing information only",
          "measurement": "Error message contains only user-facing information (URL, error type, guidance)",
          "threshold": "Only user-facing information present",
          "unit": "content"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-032-01",
          "description": "Verify error message security",
          "given": "Connection error occurs",
          "when": "Trigger connection error and capture error message",
          "then": [
            "Error message does NOT contain internal IP addresses",
            "Error message does NOT contain connection IDs",
            "Error message does NOT contain internal state information",
            "Error message contains only user-facing information (URL, error type, guidance)"
          ]
        }
      ],
      "evidence_requirements": [
        "Error message text",
        "Internal IP count in message (must be 0)",
        "Connection ID count in message (must be 0)",
        "Internal state reference count (must be 0)",
        "User-facing information verification"
      ]
    },
    {
      "id": "QC-033",
      "requirement_id": "REQ-033",
      "interface_id": "IF-018",
      "category": "validation",
      "title": "Channel validation bypass prevention",
      "statement": "System SHALL NOT allow messages to bypass channel validation in server mode",
      "measurable_criteria": [
        {
          "criterion": "Invalid channel rejection",
          "measurement": "Channel validation error occurs for invalid channel names",
          "threshold": "100% rejection of invalid channels",
          "unit": "percentage"
        },
        {
          "criterion": "Valid channel acceptance",
          "measurement": "Valid channel names are accepted",
          "threshold": "100% acceptance of valid channels",
          "unit": "percentage"
        },
        {
          "criterion": "Validation consistency",
          "measurement": "Channel validation is identical in both modes",
          "threshold": "100% consistency",
          "unit": "percentage"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-033-01",
          "description": "Verify channel validation in server mode",
          "given": "Invalid and valid channel names",
          "when": "Attempt to send messages with invalid and valid channel names in server mode",
          "then": [
            "Channel validation error occurs for invalid channel name",
            "Message is accepted for valid channel name",
            "Channel validation is identical in both modes"
          ]
        }
      ],
      "evidence_requirements": [
        "Channel validation results",
        "Invalid channel rejection count",
        "Valid channel acceptance count",
        "Validation consistency verification"
      ]
    },
    {
      "id": "QC-034",
      "requirement_id": "REQ-034",
      "interface_id": "IF-014",
      "category": "error_handling",
      "title": "Unmatched correlation ID handling",
      "statement": "System SHALL NOT process responses with correlation_id that does not match any pending request without logging or handling appropriately",
      "measurable_criteria": [
        {
          "criterion": "Unmatched detection",
          "measurement": "System detects unmatched correlation_id",
          "threshold": "100% detection rate",
          "unit": "percentage"
        },
        {
          "criterion": "Appropriate handling",
          "measurement": "System logs warning or handles appropriately",
          "threshold": "Warning logged or handled",
          "unit": "action"
        },
        {
          "criterion": "No silent failure",
          "measurement": "System does NOT crash or fail silently",
          "threshold": "0 crashes, 0 silent failures",
          "unit": "count"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-034-01",
          "description": "Verify unmatched correlation_id handling",
          "given": "Request sent with correlation_id='req-1'",
          "when": "Receive response with correlation_id='req-999' (non-existent)",
          "then": [
            "System detects unmatched correlation_id",
            "System logs warning or handles appropriately",
            "System does NOT crash or fail silently"
          ]
        }
      ],
      "evidence_requirements": [
        "Unmatched correlation_id detection",
        "Warning log or handling action",
        "Crash count (must be 0)",
        "Silent failure count (must be 0)"
      ]
    },
    {
      "id": "QC-035",
      "requirement_id": "REQ-035",
      "interface_id": "IF-005",
      "category": "validation",
      "title": "Invalid URL validation",
      "statement": "System SHALL NOT allow AILOOP_SERVER environment variable to point to invalid or malicious URLs without validation",
      "measurable_criteria": [
        {
          "criterion": "Invalid URL rejection",
          "measurement": "Invalid URLs are rejected before connection attempt",
          "threshold": "100% rejection of invalid URLs",
          "unit": "percentage"
        },
        {
          "criterion": "URL validation error",
          "measurement": "URL validation error occurs for invalid URLs",
          "threshold": "Error present for invalid URLs",
          "unit": "presence"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-035-01",
          "description": "Verify invalid URL validation",
          "given": "Invalid URL formats: invalid-url-format, http://, not-a-url",
          "when": "Set AILOOP_SERVER to invalid URLs and execute command",
          "then": [
            "URL validation error occurs for each invalid URL",
            "Invalid URLs are rejected before connection attempt",
            "URL validation prevents connection to invalid destinations"
          ]
        }
      ],
      "evidence_requirements": [
        "URL validation error messages",
        "Invalid URL rejection count",
        "Connection attempt count (must be 0 for invalid URLs)"
      ]
    },
    {
      "id": "QC-036",
      "requirement_id": "REQ-036",
      "interface_id": "IF-021",
      "category": "functional",
      "title": "Timeout logic independence",
      "statement": "System SHALL NOT mix timeout handling between direct mode and server mode - each mode SHALL have independent timeout logic",
      "measurable_criteria": [
        {
          "criterion": "Timeout independence",
          "measurement": "Timeout logic is independent for each mode",
          "threshold": "100% independence",
          "unit": "percentage"
        },
        {
          "criterion": "Mode-specific timeout",
          "measurement": "Each mode uses its own timeout configuration",
          "threshold": "Correct timeout used per mode",
          "unit": "accuracy"
        }
      ],
      "test_specs": [
        {
          "test_case_id": "TC-REQ-036-01",
          "description": "Verify timeout logic independence",
          "given": "timeout_seconds=10 in config",
          "when": "Execute ask command in direct mode and server mode",
          "then": [
            "Timeout logic is independent for each mode",
            "Each mode uses its own timeout",
            "Timeout handling does not mix between modes"
          ]
        }
      ],
      "evidence_requirements": [
        "Direct mode timeout behavior",
        "Server mode timeout behavior",
        "Timeout independence verification"
      ]
    }
  ],
  "test_spec_index": {
    "by_requirement": {
      "REQ-001": ["TC-REQ-001-01", "TC-REQ-001-02"],
      "REQ-002": ["TC-REQ-002-01"],
      "REQ-003": ["TC-REQ-003-01"],
      "REQ-004": ["TC-REQ-004-01", "TC-REQ-004-02"],
      "REQ-005": ["TC-REQ-005-01", "TC-REQ-005-02"],
      "REQ-006": ["TC-REQ-006-01"],
      "REQ-007": ["TC-REQ-007-01", "TC-REQ-007-02"],
      "REQ-008": ["TC-REQ-008-01"],
      "REQ-009": ["TC-REQ-009-01"],
      "REQ-010": ["TC-REQ-010-01"],
      "REQ-011": ["TC-REQ-011-01"],
      "REQ-012": ["TC-REQ-012-01"],
      "REQ-013": ["TC-REQ-013-01", "TC-REQ-013-02"],
      "REQ-014": ["TC-REQ-014-01"],
      "REQ-016": ["TC-REQ-016-01"],
      "REQ-017": ["TC-REQ-017-01"],
      "REQ-018": ["TC-REQ-018-01"],
      "REQ-020": ["TC-REQ-020-01"],
      "REQ-021": ["TC-REQ-021-01"],
      "REQ-022": ["TC-REQ-022-01"],
      "REQ-023": ["TC-REQ-023-01", "TC-REQ-023-02"],
      "REQ-024": ["TC-REQ-024-01"],
      "REQ-025": ["TC-REQ-025-01"],
      "REQ-026": ["TC-REQ-026-01"],
      "REQ-027": ["TC-REQ-027-01"],
      "REQ-028": ["TC-REQ-028-01"],
      "REQ-029": ["TC-REQ-029-01"],
      "REQ-030": ["TC-REQ-030-01"],
      "REQ-031": ["TC-REQ-031-01"],
      "REQ-032": ["TC-REQ-032-01"],
      "REQ-033": ["TC-REQ-033-01"],
      "REQ-034": ["TC-REQ-034-01"],
      "REQ-035": ["TC-REQ-035-01"],
      "REQ-036": ["TC-REQ-036-01"]
    },
    "by_interface": {
      "IF-001": ["TC-REQ-001-01", "TC-REQ-001-02"],
      "IF-002": ["TC-REQ-002-01"],
      "IF-005": ["TC-REQ-003-01", "TC-REQ-004-01", "TC-REQ-004-02", "TC-REQ-014-01", "TC-REQ-035-01"],
      "IF-006": ["TC-REQ-005-01", "TC-REQ-005-02", "TC-REQ-006-01", "TC-REQ-022-01", "TC-REQ-023-01", "TC-REQ-023-02", "TC-REQ-024-01"],
      "IF-007": ["TC-REQ-012-01", "TC-REQ-013-01", "TC-REQ-013-02", "TC-REQ-016-01", "TC-REQ-017-01", "TC-REQ-018-01"],
      "IF-010": ["TC-REQ-009-01", "TC-REQ-031-01"],
      "IF-011": ["TC-REQ-010-01", "TC-REQ-011-01", "TC-REQ-030-01"],
      "IF-013": ["TC-REQ-005-01", "TC-REQ-005-02", "TC-REQ-027-01"],
      "IF-014": ["TC-REQ-012-01", "TC-REQ-034-01"],
      "IF-015": ["TC-REQ-007-01", "TC-REQ-007-02", "TC-REQ-028-01"],
      "IF-016": ["TC-REQ-011-01", "TC-REQ-026-01"],
      "IF-018": ["TC-REQ-020-01", "TC-REQ-033-01"],
      "IF-019": ["TC-REQ-008-01", "TC-REQ-029-01"],
      "IF-021": ["TC-REQ-016-01", "TC-REQ-017-01", "TC-REQ-036-01"],
      "IF-023": ["TC-REQ-014-01", "TC-REQ-025-01", "TC-REQ-032-01"],
      "IF-025": ["TC-REQ-021-01"]
    },
    "by_category": {
      "functional": ["QC-001", "QC-002", "QC-003", "QC-004", "QC-005", "QC-006", "QC-007", "QC-008", "QC-009", "QC-010", "QC-011", "QC-012", "QC-013", "QC-016", "QC-017", "QC-020", "QC-021", "QC-022", "QC-023", "QC-024", "QC-026", "QC-027", "QC-028", "QC-029", "QC-036"],
      "error_handling": ["QC-014", "QC-018", "QC-025", "QC-030", "QC-034"],
      "validation": ["QC-020", "QC-031", "QC-033", "QC-035"],
      "security": ["QC-032"]
    }
  },
  "traceability": {
    "requirements_coverage": {
      "REQ-001": ["QC-001"],
      "REQ-002": ["QC-002"],
      "REQ-003": ["QC-003"],
      "REQ-004": ["QC-004"],
      "REQ-005": ["QC-005"],
      "REQ-006": ["QC-006"],
      "REQ-007": ["QC-007"],
      "REQ-008": ["QC-008"],
      "REQ-009": ["QC-009"],
      "REQ-010": ["QC-010"],
      "REQ-011": ["QC-011"],
      "REQ-012": ["QC-012"],
      "REQ-013": ["QC-013"],
      "REQ-014": ["QC-014"],
      "REQ-016": ["QC-016"],
      "REQ-017": ["QC-017"],
      "REQ-018": ["QC-018"],
      "REQ-020": ["QC-020"],
      "REQ-021": ["QC-021"],
      "REQ-022": ["QC-022"],
      "REQ-023": ["QC-023"],
      "REQ-024": ["QC-024"],
      "REQ-025": ["QC-025"],
      "REQ-026": ["QC-026"],
      "REQ-027": ["QC-027"],
      "REQ-028": ["QC-028"],
      "REQ-029": ["QC-029"],
      "REQ-030": ["QC-030"],
      "REQ-031": ["QC-031"],
      "REQ-032": ["QC-032"],
      "REQ-033": ["QC-033"],
      "REQ-034": ["QC-034"],
      "REQ-035": ["QC-035"],
      "REQ-036": ["QC-036"]
    }
  }
}
