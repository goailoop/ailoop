{
  "meta": {
    "generated_at": "2026-01-13T19:55:26.280546Z",
    "inputs_used": [
      "intake.json",
      "scope.json",
      "glossary.json",
      "journeys.json",
      "semantic.json",
      "ears.json",
      "issues.json",
      "verification.json",
      "negative.json",
      "trace.json"
    ],
    "build_notes": [
      "All artifacts successfully merged",
      "Total requirements: 34 (22 positive + 12 negative)",
      "REQ-015 removed as unnecessary (each CLI command creates its own connection)",
      "REQ-013 simplified to focus on waiting behavior only (timeout error handling covered by REQ-018)",
      "Negative requirements (REQ-025 to REQ-036) included as unwanted behaviors",
      "Traceability relations embedded from trace.json",
      "Verification criteria attached from verification.json",
      "Issues attached to corresponding requirements"
    ]
  },
  "glossary": [
    {
      "term": "Direct Mode",
      "definition": "Operation mode where CLI commands display questions and collect responses directly in the local terminal where the command is executed. No network communication is involved.",
      "aliases": [
        "local mode",
        "standalone mode"
      ],
      "source": "client"
    },
    {
      "term": "Server Mode",
      "definition": "Operation mode where CLI commands connect to a running ailoop server via WebSocket, send messages to the server, and wait for responses. Human users monitor the server terminal UI to provide responses.",
      "aliases": [
        "remote mode",
        "client mode"
      ],
      "source": "client"
    },
    {
      "term": "WebSocket Client",
      "definition": "Component in CLI commands that establishes WebSocket connections to ailoop server, sends messages, and receives responses. Implemented in src/cli/client.rs.",
      "aliases": [
        "WS client",
        "client connection"
      ],
      "source": "client"
    },
    {
      "term": "Mode Detection",
      "definition": "Logic that determines whether a CLI command should operate in direct mode or server mode. Based on --server flag presence or AILOOP_SERVER environment variable.",
      "aliases": [
        "operation mode detection",
        "mode selection"
      ],
      "source": "client"
    },
    {
      "term": "Message Correlation",
      "definition": "Process of matching response messages to their originating request messages using the correlation_id field. Enables routing responses back to correct client connections.",
      "aliases": [
        "request-response matching",
        "message tracking"
      ],
      "source": "client"
    },
    {
      "term": "Correlation ID",
      "definition": "Unique identifier in Message structure that links response messages to their originating request messages. Used for routing responses back to correct WebSocket connections.",
      "aliases": [
        "correlation identifier",
        "request ID"
      ],
      "source": "client"
    },
    {
      "term": "Connection Tracking",
      "definition": "Server-side mechanism that maintains mapping between WebSocket connections and the messages they send. Enables routing responses back to originating connections.",
      "aliases": [
        "connection mapping",
        "client tracking"
      ],
      "source": "client"
    },
    {
      "term": "Response Routing",
      "definition": "Server-side process of sending response messages back to the WebSocket connection that originated the corresponding request message.",
      "aliases": [
        "response delivery",
        "message routing"
      ],
      "source": "client"
    },
    {
      "term": "Concurrent Requests",
      "definition": "Multiple request messages sent from the same WebSocket client connection before receiving responses. Server must handle and process these independently.",
      "aliases": [
        "parallel requests",
        "simultaneous requests"
      ],
      "source": "client"
    },
    {
      "term": "AILOOP_SERVER",
      "definition": "Environment variable that, when set, overrides default behavior and enables server mode for CLI commands even if --server flag is not provided.",
      "aliases": [],
      "source": "client"
    },
    {
      "term": "Server URL",
      "definition": "Network address of ailoop server specified via --server flag. Format: http://host:port or https://host:port. Converted to ws:// or wss:// for WebSocket connections.",
      "aliases": [
        "server address",
        "server endpoint"
      ],
      "source": "client"
    },
    {
      "term": "Request-Response Cycle",
      "definition": "Complete interaction flow: client sends request message via WebSocket, server processes and displays to human, human provides response, server sends response back to client, client receives and processes response.",
      "aliases": [
        "message exchange",
        "interaction cycle"
      ],
      "source": "client"
    },
    {
      "term": "Backward Compatibility",
      "definition": "Requirement that existing direct mode behavior remains unchanged. CLI commands without --server flag and without AILOOP_SERVER env var must continue to work exactly as before.",
      "aliases": [
        "compatibility",
        "non-breaking change"
      ],
      "source": "client"
    },
    {
      "term": "Connection Error",
      "definition": "Failure to establish or maintain WebSocket connection to server. In server mode, commands must fail with clear error message (no fallback to direct mode).",
      "aliases": [
        "connection failure",
        "network error"
      ],
      "source": "client"
    },
    {
      "term": "Response Timeout",
      "definition": "Maximum time to wait for server response. Defined in configuration file timeout_seconds setting. Default value 0 means wait indefinitely.",
      "aliases": [
        "timeout",
        "response wait time"
      ],
      "source": "client"
    },
    {
      "term": "WebSocket Protocol",
      "definition": "Communication protocol used for bidirectional message exchange between CLI clients and ailoop server. Based on existing Message JSON format.",
      "aliases": [
        "WS protocol",
        "WebSocket communication"
      ],
      "source": "assumed"
    },
    {
      "term": "Bidirectional Communication",
      "definition": "Two-way message exchange capability where client can send messages to server and server can send messages back to client over same WebSocket connection.",
      "aliases": [
        "two-way communication",
        "full-duplex"
      ],
      "source": "assumed"
    },
    {
      "term": "Message Queue",
      "definition": "Server-side data structure that holds incoming messages from WebSocket clients before they are processed and displayed to human users in terminal UI.",
      "aliases": [
        "queue",
        "message buffer"
      ],
      "source": "assumed"
    },
    {
      "term": "Terminal UI",
      "definition": "Interactive terminal interface displayed by ailoop server showing server status, queued messages, and active connections. Human users monitor this to provide responses.",
      "aliases": [
        "server UI",
        "monitoring interface"
      ],
      "source": "assumed"
    },
    {
      "term": "Channel Isolation",
      "definition": "Requirement that messages in different channels remain separate. Must be maintained in both direct mode and server mode operation.",
      "aliases": [
        "channel separation",
        "message isolation"
      ],
      "source": "assumed"
    },
    {
      "term": "JSON Output Format",
      "definition": "Structured output format for CLI commands when --json flag is used. Must be consistent between direct mode and server mode responses.",
      "aliases": [
        "JSON format",
        "structured output"
      ],
      "source": "assumed"
    },
    {
      "term": "Mode Override",
      "definition": "Mechanism where AILOOP_SERVER environment variable takes precedence over default direct mode behavior, enabling server mode without explicit --server flag.",
      "aliases": [
        "environment override",
        "env var override"
      ],
      "source": "client"
    }
  ],
  "journeys": [
    {
      "id": "JRN-001",
      "actor": "AI agent",
      "goal": "Ask a question in direct mode and receive human response in local terminal",
      "trigger": "AI agent invokes 'ailoop ask' command without --server flag and without AILOOP_SERVER env var",
      "steps": [
        "Agent executes: ailoop ask 'What is the best approach?'",
        "CLI handler detects no --server flag and no AILOOP_SERVER env var",
        "CLI handler determines operation mode is direct mode",
        "CLI handler validates channel name (default: public)",
        "CLI handler displays question in local terminal: '\u2753 What is the best approach?: '",
        "CLI handler waits for user input from stdin",
        "Human user types response in same terminal",
        "CLI handler receives response and displays it",
        "CLI handler exits with success code 0"
      ],
      "success_outcome": "Question displayed in local terminal, human response collected and returned to agent",
      "failure_outcomes": [
        "Invalid channel name: command fails with validation error",
        "User presses Ctrl+C: command exits with code 130 and displays cancellation message",
        "Timeout occurs (if timeout > 0): command exits with code 1 and displays timeout message"
      ]
    },
    {
      "id": "JRN-002",
      "actor": "AI agent",
      "goal": "Ask a question in server mode using --server flag and receive response from server",
      "trigger": "AI agent invokes 'ailoop ask' command with --server flag pointing to running ailoop server",
      "steps": [
        "Agent executes: ailoop ask 'Should we proceed?' --server http://localhost:8080",
        "CLI handler detects --server flag is present",
        "CLI handler determines operation mode is server mode",
        "CLI handler validates channel name (default: public)",
        "WebSocket client converts server URL from http:// to ws://",
        "WebSocket client establishes connection to server at ws://localhost:8080",
        "WebSocket client creates Message with Question content and correlation_id",
        "WebSocket client sends message to server via WebSocket",
        "Server receives message and tracks connection that sent it",
        "Server enqueues message in channel-specific queue",
        "Server terminal UI displays question to human user",
        "Human user monitoring server terminal types response",
        "Server creates response Message with correlation_id matching original request",
        "Server routes response back to originating WebSocket connection",
        "WebSocket client receives response message",
        "WebSocket client matches response using correlation_id",
        "WebSocket client extracts answer from response",
        "CLI handler displays response and exits with success code 0"
      ],
      "success_outcome": "Question sent to server, displayed in server terminal UI, human response received and returned to agent",
      "failure_outcomes": [
        "Server unreachable: command fails with connection error, no fallback to direct mode",
        "Invalid server URL: command fails with URL parsing error",
        "WebSocket handshake fails: command fails with handshake error",
        "Response timeout: command fails with timeout error (if timeout configured)",
        "Connection closed before response: command fails with connection closed error"
      ]
    },
    {
      "id": "JRN-003",
      "actor": "AI agent",
      "goal": "Ask a question in server mode using AILOOP_SERVER environment variable",
      "trigger": "AI agent sets AILOOP_SERVER environment variable and invokes 'ailoop ask' without --server flag",
      "steps": [
        "Agent sets environment variable: export AILOOP_SERVER=http://localhost:8080",
        "Agent executes: ailoop ask 'Review this code change'",
        "CLI handler detects AILOOP_SERVER environment variable is set",
        "CLI handler determines operation mode is server mode (env var override)",
        "CLI handler uses AILOOP_SERVER value as server URL",
        "WebSocket client establishes connection using AILOOP_SERVER URL",
        "WebSocket client sends question message to server",
        "Server processes message and displays to human in terminal UI",
        "Human provides response in server terminal",
        "Server sends response back to client",
        "CLI handler receives and displays response"
      ],
      "success_outcome": "Server mode activated via environment variable, question processed, response received",
      "failure_outcomes": [
        "AILOOP_SERVER points to unreachable server: command fails with error",
        "AILOOP_SERVER has invalid URL format: command fails with URL error",
        "AILOOP_SERVER overrides --server flag if both are present: uses AILOOP_SERVER value"
      ]
    },
    {
      "id": "JRN-004",
      "actor": "AI agent",
      "goal": "Request authorization in server mode and receive approval/denial from server",
      "trigger": "AI agent invokes 'ailoop authorize' command with --server flag",
      "steps": [
        "Agent executes: ailoop authorize 'Deploy to production' --server http://localhost:8080 --timeout 300",
        "CLI handler detects server mode",
        "CLI handler validates channel name",
        "WebSocket client connects to server",
        "WebSocket client creates Message with Authorization content and timeout",
        "WebSocket client sends authorization request to server",
        "Server receives message and tracks originating connection",
        "Server enqueues authorization message in channel queue",
        "Server terminal UI displays authorization request with action description",
        "Human user sees request in server terminal and types 'authorized' or 'denied'",
        "Server creates response Message with AuthorizationApproved or AuthorizationDenied",
        "Server routes response back to originating connection using correlation_id",
        "WebSocket client receives response and matches to request",
        "CLI handler processes authorization decision",
        "If authorized: CLI handler exits with code 0",
        "If denied: CLI handler exits with code 1"
      ],
      "success_outcome": "Authorization request sent to server, human decision received, command exits with appropriate code",
      "failure_outcomes": [
        "Server unreachable: command fails with error, exits with code 1",
        "Timeout occurs: server defaults to denied, response sent, command exits with code 1",
        "Human cancels (Ctrl+C): server defaults to denied, response sent, command exits with code 1",
        "Connection lost: command fails with connection error"
      ]
    },
    {
      "id": "JRN-005",
      "actor": "AI agent",
      "goal": "Send notification in server mode without waiting for response",
      "trigger": "AI agent invokes 'ailoop say' command with --server flag",
      "steps": [
        "Agent executes: ailoop say 'Build completed successfully' --server http://localhost:8080 --priority high",
        "CLI handler detects server mode",
        "CLI handler validates channel name and priority",
        "WebSocket client connects to server",
        "WebSocket client creates Message with Notification content",
        "WebSocket client sends notification message to server",
        "Server receives message and enqueues in channel queue",
        "Server terminal UI displays notification with priority indicator",
        "WebSocket client closes connection (no response expected)",
        "CLI handler exits with success code 0"
      ],
      "success_outcome": "Notification sent to server and displayed in server terminal UI, command completes immediately",
      "failure_outcomes": [
        "Server unreachable: command fails with connection error",
        "Invalid priority: command uses default priority and continues",
        "Connection fails: command fails with error"
      ]
    },
    {
      "id": "JRN-006",
      "actor": "AI agent",
      "goal": "Handle server connection failure gracefully with clear error message",
      "trigger": "AI agent invokes command in server mode but server is unreachable",
      "steps": [
        "Agent executes: ailoop ask 'Question' --server http://unreachable:8080",
        "CLI handler detects server mode",
        "WebSocket client attempts to connect to server",
        "Connection attempt fails (network unreachable, server down, etc.)",
        "WebSocket client detects connection error",
        "CLI handler receives connection error",
        "CLI handler displays clear error message indicating server unreachable",
        "CLI handler exits with error code 1 (no fallback to direct mode)"
      ],
      "success_outcome": "Command fails with clear error message, no silent fallback, agent knows server mode failed",
      "failure_outcomes": [
        "Error message unclear: agent cannot diagnose issue",
        "Command hangs: connection timeout not properly handled",
        "Fallback occurs: direct mode activated (should not happen)"
      ]
    },
    {
      "id": "JRN-007",
      "actor": "AI agent",
      "goal": "Send multiple concurrent requests from different connections and receive responses",
      "trigger": "AI agent sends multiple ask/authorize commands rapidly (each creates its own connection)",
      "steps": [
        "Agent executes first: ailoop ask 'Question 1' --server http://localhost:8080",
        "First WebSocket client establishes connection and sends first message",
        "Agent immediately executes second: ailoop ask 'Question 2' --server http://localhost:8080",
        "Second WebSocket client creates new connection and sends second message",
        "Server receives both messages and tracks each to its own connection",
        "Server enqueues both messages in channel queue",
        "Server terminal UI displays both questions",
        "Human user provides response to first question",
        "Server creates response with correlation_id matching first request",
        "Server routes first response back to first connection",
        "First WebSocket client receives and matches response",
        "Human user provides response to second question",
        "Server creates response with correlation_id matching second request",
        "Server routes second response back to second connection",
        "Second WebSocket client receives and matches response"
      ],
      "success_outcome": "Multiple requests processed independently, each with its own connection, responses correctly matched to requests via correlation_id",
      "failure_outcomes": [
        "Response correlation fails: wrong response matched to request",
        "Server cannot handle concurrent connections",
        "Message ordering issues: responses arrive out of order and correlation fails"
      ]
    },
    {
      "id": "JRN-008",
      "actor": "AI agent",
      "goal": "Handle response timeout in server mode using configuration file timeout setting",
      "trigger": "AI agent sends question to server, but human does not respond within configured timeout",
      "steps": [
        "Agent executes: ailoop ask 'Urgent question' --server http://localhost:8080",
        "CLI handler detects server mode",
        "CLI handler reads timeout_seconds from configuration file (default: 0 = wait forever)",
        "If timeout_seconds > 0: CLI handler sets timeout for response waiting",
        "WebSocket client sends question to server",
        "Server displays question to human in terminal UI",
        "Human does not respond within timeout period",
        "If timeout configured: CLI handler timeout expires",
        "CLI handler detects timeout and displays timeout error",
        "CLI handler exits with error code 1",
        "If timeout = 0: CLI handler waits indefinitely for response"
      ],
      "success_outcome": "Timeout properly applied from configuration, command fails with timeout error if no response received",
      "failure_outcomes": [
        "Timeout not applied: command waits forever even when timeout configured",
        "Timeout conflicts: message timeout vs config timeout not properly handled",
        "Timeout too short: valid response arrives after timeout expires"
      ]
    }
  ],
  "requirements": [
    {
      "id": "REQ-001",
      "title": "System must detect operation mode based on --server flag or AILOOP_SERVER environment variable",
      "priority": "must",
      "ears": {
        "type": "event",
        "statement": "WHEN AI agent executes any ailoop CLI command, system SHALL determine if command should operate in direct mode (no AILOOP_SERVER env var) or server mode (AILOOP_SERVER env var present)."
      },
      "fields": {
        "trigger": "AI agent executes any ailoop CLI command",
        "condition": null,
        "state": null,
        "response": "Determine if command should operate in direct mode (no AILOOP_SERVER env var) or server mode (AILOOP_SERVER env var present)"
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Execute 'ailoop ask \"test\"' without AILOOP_SERVER env var set",
          "Verify system operates in direct mode (question displayed in local terminal)",
          "Set AILOOP_SERVER=http://localhost:8080 and execute 'ailoop ask \"test\"'",
          "Verify system operates in server mode (attempts WebSocket connection)",
          "Confirm mode detection completes within 100ms of command execution"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [],
        "enables": [
          "REQ-002",
          "REQ-003"
        ],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": []
    },
    {
      "id": "REQ-002",
      "title": "System must use direct mode when neither --server flag nor AILOOP_SERVER environment variable is present",
      "priority": "must",
      "ears": {
        "type": "event",
        "statement": "WHEN AI agent executes CLI command without AILOOP_SERVER environment variable, system SHALL operate in direct mode, displaying questions and collecting responses in local terminal."
      },
      "fields": {
        "trigger": "AI agent executes CLI command without AILOOP_SERVER environment variable",
        "condition": null,
        "state": null,
        "response": "Operate in direct mode, displaying questions and collecting responses in local terminal"
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Execute 'ailoop ask \"What is your name?\"' without AILOOP_SERVER env var",
          "Verify question is displayed in local terminal within 1 second",
          "Provide response and verify it is captured and returned to agent",
          "Confirm no WebSocket connection attempt is made",
          "Verify command completes in direct mode"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [
          "REQ-001"
        ],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": []
    },
    {
      "id": "REQ-003",
      "title": "System must use server mode when --server flag is provided",
      "priority": "must",
      "ears": {
        "type": "event",
        "statement": "WHEN AI agent executes CLI command with AILOOP_SERVER environment variable set, system SHALL operate in server mode, connecting to server specified in AILOOP_SERVER via WebSocket and sending messages."
      },
      "fields": {
        "trigger": "AI agent executes CLI command with AILOOP_SERVER environment variable set",
        "condition": null,
        "state": null,
        "response": "Operate in server mode, connecting to server specified in AILOOP_SERVER via WebSocket and sending messages"
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Set AILOOP_SERVER=http://localhost:8080 environment variable",
          "Execute 'ailoop ask \"test question\"' command",
          "Verify system attempts WebSocket connection to ws://localhost:8080",
          "Confirm server mode is activated (no local terminal prompt)",
          "Verify message is sent via WebSocket connection"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [
          "REQ-001"
        ],
        "enables": [
          "REQ-004",
          "REQ-022",
          "REQ-023",
          "REQ-024"
        ],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": []
    },
    {
      "id": "REQ-004",
      "title": "System must use server mode when AILOOP_SERVER environment variable is set, even without --server flag",
      "priority": "must",
      "ears": {
        "type": "event",
        "statement": "WHEN CLI command determines operation mode is server mode, system SHALL convert server URL from http/https to ws/wss protocol and establish WebSocket connection."
      },
      "fields": {
        "trigger": "CLI command determines operation mode is server mode",
        "condition": null,
        "state": null,
        "response": "Convert server URL from http/https to ws/wss protocol and establish WebSocket connection"
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Set AILOOP_SERVER=http://localhost:8080 and execute command",
          "Verify URL is converted from http:// to ws:// protocol",
          "Set AILOOP_SERVER=https://example.com:443 and execute command",
          "Verify URL is converted from https:// to wss:// protocol",
          "Confirm WebSocket connection is established successfully"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [
          "REQ-003"
        ],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [
        {
          "requirement_id": "REQ-004",
          "type": "VAGUE",
          "severity": "low",
          "blocking": false,
          "suggested_fix": "Clarify what happens if AILOOP_SERVER URL is invalid or malformed. Should system validate URL format before attempting connection?",
          "question": "What should happen if AILOOP_SERVER environment variable contains an invalid or malformed URL? Should system: a) validate URL format and fail early with validation error, b) attempt connection and let connection error (REQ-014) handle it, or c) something else?"
        }
      ],
      "open_questions": [
        {
          "id": "Q-001",
          "question": "What should happen if AILOOP_SERVER environment variable contains an invalid or malformed URL? Should system: a) validate URL format and fail early with validation error, b) attempt connection and let connection error (REQ-014) handle it, or c) something else?",
          "blocking": false,
          "priority": "medium",
          "affects_requirements": [
            "REQ-004"
          ],
          "affects_dimensions": [],
          "answer_format": "free_text",
          "status": "open",
          "answer": null,
          "created_by": "migration",
          "created_at": "2026-01-13T19:55:26.280334Z"
        }
      ]
    },
    {
      "id": "REQ-005",
      "title": "System must establish WebSocket connection to server when operating in server mode",
      "priority": "must",
      "ears": {
        "type": "event",
        "statement": "WHEN WebSocket client sends question, authorization, or notification message to server, system SHALL create Message object with globally unique correlation_id (UUID) to enable response matching."
      },
      "fields": {
        "trigger": "WebSocket client sends question, authorization, or notification message to server",
        "condition": null,
        "state": null,
        "response": "Create Message object with globally unique correlation_id (UUID) to enable response matching"
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Send question message via WebSocket client",
          "Verify Message object contains correlation_id field",
          "Verify correlation_id is UUID format (8-4-4-4-12 hexadecimal)",
          "Send authorization message and verify unique correlation_id",
          "Send notification message and verify unique correlation_id",
          "Confirm all correlation_ids are globally unique (no duplicates across 1000 messages)"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [],
        "enables": [
          "REQ-012"
        ],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": []
    },
    {
      "id": "REQ-006",
      "title": "System must create Message with correlation_id when sending request in server mode",
      "priority": "must",
      "ears": {
        "type": "event",
        "statement": "WHEN WebSocket client has created Message and established connection, system SHALL serialize Message to JSON and send via WebSocket connection to server."
      },
      "fields": {
        "trigger": "WebSocket client has created Message and established connection",
        "condition": null,
        "state": null,
        "response": "Serialize Message to JSON and send via WebSocket connection to server"
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Create Message object with question content",
          "Establish WebSocket connection to server",
          "Verify Message is serialized to valid JSON format",
          "Verify JSON message is sent via WebSocket connection",
          "Confirm message arrives at server within 1 second",
          "Verify server can parse received JSON message"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [
          "REQ-005",
          "REQ-004"
        ],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": []
    },
    {
      "id": "REQ-007",
      "title": "System must track which WebSocket connection sent each incoming message",
      "priority": "must",
      "ears": {
        "type": "event",
        "statement": "WHEN server receives Message from WebSocket client, system SHALL record mapping between incoming message and originating WebSocket connection for response routing."
      },
      "fields": {
        "trigger": "Server receives Message from WebSocket client",
        "condition": null,
        "state": null,
        "response": "Record mapping between incoming message and originating WebSocket connection for response routing"
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Send message from WebSocket client to server",
          "Verify server records mapping between message and connection",
          "Send second message from different connection",
          "Verify server maintains separate mappings for each connection",
          "Confirm mapping persists until response is sent or connection closes"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [
          "REQ-006"
        ],
        "enables": [
          "REQ-011"
        ],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": []
    },
    {
      "id": "REQ-008",
      "title": "System must enqueue incoming messages in channel-specific queue on server",
      "priority": "must",
      "ears": {
        "type": "event",
        "statement": "WHEN server receives Message from WebSocket client, system SHALL add message to queue for the channel specified in message, maintaining channel isolation."
      },
      "fields": {
        "trigger": "Server receives Message from WebSocket client",
        "condition": null,
        "state": null,
        "response": "Add message to queue for the channel specified in message, maintaining channel isolation"
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Send message with channel='test-channel' to server",
          "Verify message is added to queue for 'test-channel'",
          "Send message with channel='other-channel' to server",
          "Verify message is added to queue for 'other-channel'",
          "Verify messages in different channels are isolated (cannot access cross-channel)",
          "Confirm channel isolation is maintained"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [
          "REQ-007"
        ],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": []
    },
    {
      "id": "REQ-009",
      "title": "System must display queued messages to human users in server terminal UI",
      "priority": "must",
      "ears": {
        "type": "event",
        "statement": "WHEN message is enqueued in server channel queue, system SHALL display message content (question, authorization request, or notification) in server terminal UI for human interaction."
      },
      "fields": {
        "trigger": "Message is enqueued in server channel queue",
        "condition": null,
        "state": null,
        "response": "Display message content (question, authorization request, or notification) in server terminal UI for human interaction"
      },
      "verification": {
        "method": "inspection",
        "acceptance_criteria": [
          "Enqueue question message in server channel queue",
          "Verify question text appears in server terminal UI within 500ms",
          "Enqueue authorization message and verify it appears in terminal UI",
          "Enqueue notification message and verify it appears in terminal UI",
          "Confirm message content matches exactly what was sent",
          "Verify messages appear in order of enqueueing"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [
          "REQ-008"
        ],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": []
    },
    {
      "id": "REQ-010",
      "title": "System must create response Message with correlation_id matching original request",
      "priority": "must",
      "ears": {
        "type": "event",
        "statement": "WHEN human user provides response to question or authorization request in server terminal, system SHALL create response Message with correlation_id set to the id of the original request message."
      },
      "fields": {
        "trigger": "Human user provides response to question or authorization request in server terminal",
        "condition": null,
        "state": null,
        "response": "Create response Message with correlation_id set to the id of the original request message"
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Send question message with id='msg-123' to server",
          "Human provides response in server terminal",
          "Verify response Message has correlation_id='msg-123'",
          "Send authorization message with id='msg-456'",
          "Human provides authorization decision",
          "Verify response Message has correlation_id='msg-456'",
          "Confirm correlation_id matches original request id exactly"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [
          "REQ-009"
        ],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": []
    },
    {
      "id": "REQ-011",
      "title": "System must route response Message back to originating WebSocket connection",
      "priority": "must",
      "ears": {
        "type": "event",
        "statement": "WHEN server creates response Message with correlation_id matching request, system SHALL use connection tracking to identify originating connection and send response via that connection."
      },
      "fields": {
        "trigger": "Server creates response Message with correlation_id matching request",
        "condition": null,
        "state": null,
        "response": "Use connection tracking to identify originating connection and send response via that connection"
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Send message from WebSocket connection A",
          "Create response with matching correlation_id",
          "Verify server uses connection tracking to identify connection A",
          "Verify response is sent via connection A (not connection B)",
          "Send message from different connection B",
          "Verify response for B is sent via connection B",
          "Confirm responses are routed to correct originating connections"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [
          "REQ-010",
          "REQ-007"
        ],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [
        {
          "requirement_id": "REQ-011",
          "type": "VAGUE",
          "severity": "low",
          "blocking": false,
          "suggested_fix": "Clarify what happens if originating connection is closed before response can be sent. Should system handle this gracefully or fail?",
          "question": "What should happen if the originating WebSocket connection is closed before server can send response? Should system: a) silently drop the response, b) log an error, c) attempt to reconnect, or d) fail with error?"
        }
      ],
      "open_questions": [
        {
          "id": "Q-002",
          "question": "What should happen if the originating WebSocket connection is closed before server can send response? Should system: a) silently drop the response, b) log an error, c) attempt to reconnect, or d) fail with error?",
          "blocking": false,
          "priority": "medium",
          "affects_requirements": [
            "REQ-011"
          ],
          "affects_dimensions": [],
          "answer_format": "free_text",
          "status": "open",
          "answer": null,
          "created_by": "migration",
          "created_at": "2026-01-13T19:55:26.280357Z"
        }
      ]
    },
    {
      "id": "REQ-012",
      "title": "System must match received response to original request using correlation_id",
      "priority": "must",
      "ears": {
        "type": "event",
        "statement": "WHEN WebSocket client receives response Message from server, system SHALL maintain a map of pending requests keyed by correlation_id and match response correlation_id to correct pending request using lookup."
      },
      "fields": {
        "trigger": "WebSocket client receives response Message from server",
        "condition": null,
        "state": null,
        "response": "Maintain a map of pending requests keyed by correlation_id and match response correlation_id to correct pending request using lookup"
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Send request with correlation_id='req-1'",
          "Send request with correlation_id='req-2'",
          "Receive response with correlation_id='req-1'",
          "Verify response is matched to first request (req-1)",
          "Receive response with correlation_id='req-2'",
          "Verify response is matched to second request (req-2)",
          "Confirm map lookup correctly matches correlation_ids",
          "Verify unmatched correlation_id is handled appropriately"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [
          "REQ-011"
        ],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [
        {
          "requirement_id": "REQ-012",
          "type": "VAGUE",
          "severity": "low",
          "blocking": false,
          "suggested_fix": "Clarify what happens if response correlation_id does not match any pending request. Should system ignore it, log error, or fail?",
          "question": "What should happen if WebSocket client receives response with correlation_id that doesn't match any pending request? Should system: a) ignore the response, b) log a warning, c) fail with error, or d) something else?"
        }
      ],
      "open_questions": [
        {
          "id": "Q-003",
          "question": "What should happen if WebSocket client receives response with correlation_id that doesn't match any pending request? Should system: a) ignore the response, b) log a warning, c) fail with error, or d) something else?",
          "blocking": false,
          "priority": "medium",
          "affects_requirements": [
            "REQ-012"
          ],
          "affects_dimensions": [],
          "answer_format": "free_text",
          "status": "open",
          "answer": null,
          "created_by": "migration",
          "created_at": "2026-01-13T19:55:26.280362Z"
        }
      ]
    },
    {
      "id": "REQ-013",
      "title": "System must wait for server response when operating in server mode for ask and authorize commands",
      "priority": "must",
      "ears": {
        "type": "event",
        "statement": "WHEN WebSocket client sends question or authorization message to server, system SHALL wait for response Message from server with matching correlation_id subject to timeout rules (REQ-016/REQ-017)."
      },
      "fields": {
        "trigger": "WebSocket client sends question or authorization message to server",
        "condition": null,
        "state": null,
        "response": "Wait for response Message from server with matching correlation_id subject to timeout rules (REQ-016/REQ-017)"
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Send question message to server",
          "Verify client waits for response with matching correlation_id",
          "Set timeout_seconds=5 in config and send question",
          "Verify timeout rules (REQ-016) are applied (timeout set to 5 seconds)",
          "Set timeout_seconds=0 in config and send question",
          "Verify client waits indefinitely (no timeout after 60 seconds) per REQ-017",
          "Confirm timeout rules (REQ-016/REQ-017) are applied correctly during waiting"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [
          "REQ-012",
          "REQ-016",
          "REQ-017"
        ],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": [
          "REQ-016",
          "REQ-017"
        ]
      },
      "issues": [
        {
          "requirement_id": "REQ-013",
          "type": "AMBIGUOUS",
          "severity": "medium",
          "blocking": false,
          "suggested_fix": "REQ-013 mixes WHEN trigger with IF condition in the response field. Consider splitting into separate requirements or restructuring as a complex EARS type with proper WHEN/IF structure.",
          "question": "REQ-013 has both WHEN trigger and IF condition in the response. Should this be: a) split into two requirements (one for waiting, one for timeout handling), b) restructured as complex EARS type with proper WHEN/IF syntax, or c) keep as-is with clarified wording?",
          "status": "resolved",
          "resolution": "REQ-013 simplified to focus on waiting behavior only. Timeout error handling is already covered by REQ-018, so removed redundant timeout error handling from REQ-013 statement."
        }
      ],
      "open_questions": []
    },
    {
      "id": "REQ-014",
      "title": "System must fail command with connection error when server is unreachable in server mode",
      "priority": "must",
      "ears": {
        "type": "event",
        "statement": "WHEN WebSocket client attempts to connect to server but connection fails, system SHALL display error message in format 'Failed to connect to server at {URL}: {error_type}. Ensure server is running and accessible.' and exit with error code 1, without falling back to direct mode."
      },
      "fields": {
        "trigger": "WebSocket client attempts to connect to server but connection fails",
        "condition": null,
        "state": null,
        "response": "Display error message in format 'Failed to connect to server at {URL}: {error_type}. Ensure server is running and accessible.' and exit with error code 1, without falling back to direct mode"
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Set AILOOP_SERVER=http://unreachable:8080",
          "Execute 'ailoop ask \"test\"' command",
          "Verify error message format: 'Failed to connect to server at http://unreachable:8080: {error_type}. Ensure server is running and accessible.'",
          "Verify error_type is specific (connection refused, network unreachable, etc.)",
          "Verify command exits with error code 1",
          "Verify system does NOT fall back to direct mode",
          "Confirm error message includes URL and actionable guidance"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [
          "REQ-004"
        ],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": []
    },
    {
      "id": "REQ-016",
      "title": "System must apply timeout from configuration file when waiting for server response",
      "priority": "must",
      "ears": {
        "type": "complex",
        "statement": "WHEN WebSocket client waits for server response in server mode, IF configuration file timeout_seconds is greater than 0, system SHALL apply timeout_seconds from configuration file as maximum wait time for server response."
      },
      "fields": {
        "trigger": "WebSocket client waits for server response in server mode",
        "condition": "Configuration file timeout_seconds is greater than 0",
        "state": null,
        "response": "Apply timeout_seconds from configuration file as maximum wait time for server response"
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Set timeout_seconds=10 in configuration file",
          "Send question message in server mode",
          "Verify timeout of 10 seconds is applied",
          "Wait 11 seconds without response",
          "Verify timeout error occurs at 10 seconds (within 100ms tolerance)",
          "Set timeout_seconds=30 and verify 30 second timeout is applied",
          "Confirm timeout_seconds from config file is used correctly"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [
          "REQ-013"
        ],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": []
    },
    {
      "id": "REQ-017",
      "title": "System must wait indefinitely for server response when configuration timeout is 0",
      "priority": "must",
      "ears": {
        "type": "complex",
        "statement": "WHEN WebSocket client waits for server response in server mode, IF configuration file timeout_seconds is 0, system SHALL wait indefinitely for server response without timeout expiration."
      },
      "fields": {
        "trigger": "WebSocket client waits for server response in server mode",
        "condition": "Configuration file timeout_seconds is 0",
        "state": null,
        "response": "Wait indefinitely for server response without timeout expiration"
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Set timeout_seconds=0 in configuration file",
          "Send question message in server mode",
          "Wait 60 seconds without response",
          "Verify no timeout error occurs",
          "Wait 300 seconds without response",
          "Verify still no timeout error occurs",
          "Confirm system waits indefinitely when timeout_seconds=0"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [
          "REQ-013"
        ],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": []
    },
    {
      "id": "REQ-018",
      "title": "System must fail command with timeout error when server response timeout expires",
      "priority": "must",
      "ears": {
        "type": "event",
        "statement": "WHEN timeout expires while waiting for server response, system SHALL display timeout error message and exit with error code 1."
      },
      "fields": {
        "trigger": "Timeout expires while waiting for server response",
        "condition": null,
        "state": null,
        "response": "Display timeout error message and exit with error code 1"
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Set timeout_seconds=5 in configuration",
          "Send question message and wait 6 seconds",
          "Verify timeout error message is displayed",
          "Verify command exits with error code 1",
          "Verify timeout occurs within 100ms of configured timeout",
          "Confirm timeout error is clear and actionable"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [
          "REQ-016"
        ],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": []
    },
    {
      "id": "REQ-020",
      "title": "System must validate channel names in both direct mode and server mode",
      "priority": "must",
      "ears": {
        "type": "event",
        "statement": "WHEN AI agent executes CLI command with channel parameter, system SHALL apply same channel name validation rules regardless of operation mode."
      },
      "fields": {
        "trigger": "AI agent executes CLI command with channel parameter",
        "condition": null,
        "state": null,
        "response": "Apply same channel name validation rules regardless of operation mode"
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Execute command with --channel invalid-channel! in direct mode",
          "Verify channel validation error occurs",
          "Execute command with --channel invalid-channel! in server mode",
          "Verify same channel validation error occurs",
          "Execute with valid channel in both modes",
          "Confirm validation rules are identical in both modes"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": []
    },
    {
      "id": "REQ-021",
      "title": "System must provide consistent JSON output format in both direct mode and server mode",
      "priority": "must",
      "ears": {
        "type": "event",
        "statement": "WHEN AI agent executes CLI command with --json flag, system SHALL generate JSON output with same structure and fields regardless of operation mode."
      },
      "fields": {
        "trigger": "AI agent executes CLI command with --json flag",
        "condition": null,
        "state": null,
        "response": "Generate JSON output with same structure and fields regardless of operation mode"
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Execute 'ailoop ask \"test\"' --json in direct mode",
          "Capture JSON output structure",
          "Set AILOOP_SERVER and execute 'ailoop ask \"test\"' --json in server mode",
          "Capture JSON output structure",
          "Compare JSON structures and verify they are identical",
          "Verify same fields are present in both modes",
          "Confirm JSON format is consistent"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": []
    },
    {
      "id": "REQ-022",
      "title": "System must support server mode for ask command",
      "priority": "must",
      "ears": {
        "type": "event",
        "statement": "WHEN AI agent executes 'ailoop ask' command in server mode, system SHALL send question to server, wait for human response subject to timeout rules, and return response to agent."
      },
      "fields": {
        "trigger": "AI agent executes 'ailoop ask' command in server mode",
        "condition": null,
        "state": null,
        "response": "Send question to server, wait for human response subject to timeout rules, and return response to agent"
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Set AILOOP_SERVER and execute 'ailoop ask \"What is the answer?\"'",
          "Verify question is sent to server via WebSocket",
          "Provide response in server terminal",
          "Verify response is received by client",
          "Verify response is returned to agent",
          "Confirm complete request-response cycle works",
          "Verify timeout rules are applied during wait"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [
          "REQ-003",
          "REQ-013"
        ],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": []
    },
    {
      "id": "REQ-023",
      "title": "System must support server mode for authorize command",
      "priority": "must",
      "ears": {
        "type": "event",
        "statement": "WHEN AI agent executes 'ailoop authorize' command in server mode, system SHALL send authorization request to server, wait for human decision subject to timeout rules, and return approval/denial to agent."
      },
      "fields": {
        "trigger": "AI agent executes 'ailoop authorize' command in server mode",
        "condition": null,
        "state": null,
        "response": "Send authorization request to server, wait for human decision subject to timeout rules, and return approval/denial to agent"
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Set AILOOP_SERVER and execute 'ailoop authorize \"Deploy to prod\"'",
          "Verify authorization request is sent to server",
          "Provide 'authorized' response in server terminal",
          "Verify approval decision is received by client",
          "Verify command exits with code 0 (authorized)",
          "Provide 'denied' response in server terminal",
          "Verify denial decision is received and command exits with code 1",
          "Confirm timeout rules are applied during wait"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [
          "REQ-003",
          "REQ-013"
        ],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": []
    },
    {
      "id": "REQ-024",
      "title": "System must support server mode for say command",
      "priority": "must",
      "ears": {
        "type": "event",
        "statement": "WHEN AI agent executes 'ailoop say' command in server mode, system SHALL send notification message to server and complete immediately without waiting for response."
      },
      "fields": {
        "trigger": "AI agent executes 'ailoop say' command in server mode",
        "condition": null,
        "state": null,
        "response": "Send notification message to server and complete immediately without waiting for response"
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Set AILOOP_SERVER and execute 'ailoop say \"Notification\"'",
          "Verify notification is sent to server via WebSocket",
          "Verify command completes immediately (within 1 second)",
          "Verify no response waiting occurs",
          "Verify notification appears in server terminal UI",
          "Confirm command exits with success code 0"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [
          "REQ-003"
        ],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": []
    },
    {
      "id": "REQ-025",
      "title": "System SHALL NOT fall back to direct mode when server connection fails in server mode.",
      "priority": "must",
      "ears": {
        "type": "unwanted",
        "statement": "System SHALL NOT fall back to direct mode when server connection fails in server mode."
      },
      "fields": {
        "trigger": null,
        "condition": null,
        "state": null,
        "response": "System SHALL NOT fall back to direct mode when server connection fails in server mode."
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Set AILOOP_SERVER=http://unreachable:8080",
          "Execute 'ailoop ask \"test\"' command",
          "Verify connection fails",
          "Verify system does NOT fall back to direct mode",
          "Verify error is reported and command fails",
          "Confirm no local terminal prompt appears"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": [],
      "rationale": "Prevents silent mode switching that could confuse AI agents and ensures explicit error reporting when server is unreachable"
    },
    {
      "id": "REQ-026",
      "title": "System SHALL NOT route response messages to incorrect WebSocket connections.",
      "priority": "must",
      "ears": {
        "type": "unwanted",
        "statement": "System SHALL NOT route response messages to incorrect WebSocket connections."
      },
      "fields": {
        "trigger": null,
        "condition": null,
        "state": null,
        "response": "System SHALL NOT route response messages to incorrect WebSocket connections."
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Send request from connection A with correlation_id='req-a'",
          "Send request from connection B with correlation_id='req-b'",
          "Send response for req-a",
          "Verify response is routed to connection A (not B)",
          "Send response for req-b",
          "Verify response is routed to connection B (not A)",
          "Confirm responses never go to wrong connections"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": [],
      "rationale": "Maintains message integrity and ensures responses reach the correct requesting client"
    },
    {
      "id": "REQ-027",
      "title": "System SHALL NOT allow duplicate correlation_id values across different messages.",
      "priority": "must",
      "ears": {
        "type": "unwanted",
        "statement": "System SHALL NOT allow duplicate correlation_id values across different messages."
      },
      "fields": {
        "trigger": null,
        "condition": null,
        "state": null,
        "response": "System SHALL NOT allow duplicate correlation_id values across different messages."
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Generate 1000 messages and collect all correlation_ids",
          "Verify all correlation_ids are unique (no duplicates)",
          "Check correlation_id format is valid UUID",
          "Verify correlation_id uniqueness across different connections",
          "Verify correlation_id uniqueness across different channels",
          "Confirm no duplicate correlation_ids are generated"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": [],
      "rationale": "Prevents response matching errors and ensures each request can be uniquely identified and matched to its response"
    },
    {
      "id": "REQ-028",
      "title": "System SHALL NOT lose connection tracking information when WebSocket connection is established.",
      "priority": "must",
      "ears": {
        "type": "unwanted",
        "statement": "System SHALL NOT lose connection tracking information when WebSocket connection is established."
      },
      "fields": {
        "trigger": null,
        "condition": null,
        "state": null,
        "response": "System SHALL NOT lose connection tracking information when WebSocket connection is established."
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Establish WebSocket connection and send message",
          "Verify connection tracking information is recorded",
          "Send response and verify connection tracking is used",
          "Establish new connection and verify tracking is separate",
          "Verify connection tracking persists until connection closes",
          "Confirm no connection tracking information is lost"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": [],
      "rationale": "Ensures server can route responses back to originating connections and prevents orphaned requests"
    },
    {
      "id": "REQ-029",
      "title": "System SHALL NOT process messages from channels other than the channel specified in the message.",
      "priority": "must",
      "ears": {
        "type": "unwanted",
        "statement": "System SHALL NOT process messages from channels other than the channel specified in the message."
      },
      "fields": {
        "trigger": null,
        "condition": null,
        "state": null,
        "response": "System SHALL NOT process messages from channels other than the channel specified in the message."
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Send message with channel='channel-a' to server",
          "Verify message is processed in channel-a queue only",
          "Send message with channel='channel-b' to server",
          "Verify message is processed in channel-b queue only",
          "Verify channel-a messages are not accessible from channel-b",
          "Verify channel-b messages are not accessible from channel-a",
          "Confirm channel isolation is maintained"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": [],
      "rationale": "Maintains channel isolation and prevents cross-channel message leakage"
    },
    {
      "id": "REQ-030",
      "title": "System SHALL NOT send response messages if the originating WebSocket connection has been closed.",
      "priority": "must",
      "ears": {
        "type": "unwanted",
        "statement": "System SHALL NOT send response messages if the originating WebSocket connection has been closed."
      },
      "fields": {
        "trigger": null,
        "condition": null,
        "state": null,
        "response": "System SHALL NOT send response messages if the originating WebSocket connection has been closed."
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Send request from WebSocket connection",
          "Close WebSocket connection before response is ready",
          "Verify server detects connection is closed",
          "Verify server does NOT attempt to send response to closed connection",
          "Verify no error occurs from sending to closed connection",
          "Confirm closed connections are handled gracefully"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": [],
      "rationale": "Prevents errors and resource waste when attempting to send responses to closed connections"
    },
    {
      "id": "REQ-031",
      "title": "System SHALL NOT allow WebSocket connections without proper message format validation.",
      "priority": "must",
      "ears": {
        "type": "unwanted",
        "statement": "System SHALL NOT allow WebSocket connections without proper message format validation."
      },
      "fields": {
        "trigger": null,
        "condition": null,
        "state": null,
        "response": "System SHALL NOT allow WebSocket connections without proper message format validation."
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Send malformed JSON message via WebSocket",
          "Verify server rejects message with validation error",
          "Send message with missing required fields",
          "Verify server rejects message",
          "Send message with invalid field types",
          "Verify server rejects message",
          "Confirm only valid messages are processed"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": [],
      "rationale": "Prevents malformed messages from causing system errors or security issues"
    },
    {
      "id": "REQ-032",
      "title": "System SHALL NOT expose sensitive connection details (internal IPs, connection IDs, internal state) in error messages to clients.",
      "priority": "must",
      "ears": {
        "type": "unwanted",
        "statement": "System SHALL NOT expose sensitive connection details (internal IPs, connection IDs, internal state) in error messages to clients."
      },
      "fields": {
        "trigger": null,
        "condition": null,
        "state": null,
        "response": "System SHALL NOT expose sensitive connection details (internal IPs, connection IDs, internal state) in error messages to clients."
      },
      "verification": {
        "method": "inspection",
        "acceptance_criteria": [
          "Trigger connection error and capture error message",
          "Verify error message does NOT contain internal IP addresses",
          "Verify error message does NOT contain connection IDs",
          "Verify error message does NOT contain internal state information",
          "Verify error message contains only user-facing information (URL, error type, guidance)",
          "Confirm sensitive details are not exposed"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": [],
      "rationale": "Protects system internals and prevents information leakage that could aid attackers"
    },
    {
      "id": "REQ-033",
      "title": "System SHALL NOT allow messages to bypass channel validation in server mode.",
      "priority": "must",
      "ears": {
        "type": "unwanted",
        "statement": "System SHALL NOT allow messages to bypass channel validation in server mode."
      },
      "fields": {
        "trigger": null,
        "condition": null,
        "state": null,
        "response": "System SHALL NOT allow messages to bypass channel validation in server mode."
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Attempt to send message with invalid channel name in server mode",
          "Verify channel validation error occurs",
          "Attempt to send message with valid channel name in server mode",
          "Verify message is accepted",
          "Compare validation behavior with direct mode",
          "Confirm channel validation is identical in both modes"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": [],
      "rationale": "Ensures channel isolation is maintained consistently across both direct and server modes"
    },
    {
      "id": "REQ-034",
      "title": "System SHALL NOT process responses with correlation_id that does not match any pending request without logging or handling appropriately.",
      "priority": "must",
      "ears": {
        "type": "unwanted",
        "statement": "System SHALL NOT process responses with correlation_id that does not match any pending request without logging or handling appropriately."
      },
      "fields": {
        "trigger": null,
        "condition": null,
        "state": null,
        "response": "System SHALL NOT process responses with correlation_id that does not match any pending request without logging or handling appropriately."
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Send request with correlation_id='req-1'",
          "Receive response with correlation_id='req-999' (non-existent)",
          "Verify system detects unmatched correlation_id",
          "Verify system logs warning or handles appropriately",
          "Verify system does NOT crash or fail silently",
          "Confirm orphaned responses are detected and handled"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": [],
      "rationale": "Prevents silent failures and ensures system can detect and handle orphaned or invalid responses"
    },
    {
      "id": "REQ-035",
      "title": "System SHALL NOT allow AILOOP_SERVER environment variable to point to invalid or malicious URLs without validation.",
      "priority": "must",
      "ears": {
        "type": "unwanted",
        "statement": "System SHALL NOT allow AILOOP_SERVER environment variable to point to invalid or malicious URLs without validation."
      },
      "fields": {
        "trigger": null,
        "condition": null,
        "state": null,
        "response": "System SHALL NOT allow AILOOP_SERVER environment variable to point to invalid or malicious URLs without validation."
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Set AILOOP_SERVER=invalid-url-format",
          "Execute command and verify URL validation error",
          "Set AILOOP_SERVER=http://",
          "Execute command and verify URL validation error",
          "Set AILOOP_SERVER=not-a-url",
          "Execute command and verify URL validation error",
          "Verify invalid URLs are rejected before connection attempt",
          "Confirm URL validation prevents connection to invalid destinations"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": [],
      "rationale": "Prevents connection attempts to invalid destinations and protects against potential security issues"
    },
    {
      "id": "REQ-036",
      "title": "System SHALL NOT mix timeout handling between direct mode and server mode - each mode SHALL have independent timeout logic.",
      "priority": "must",
      "ears": {
        "type": "unwanted",
        "statement": "System SHALL NOT mix timeout handling between direct mode and server mode - each mode SHALL have independent timeout logic."
      },
      "fields": {
        "trigger": null,
        "condition": null,
        "state": null,
        "response": "System SHALL NOT mix timeout handling between direct mode and server mode - each mode SHALL have independent timeout logic."
      },
      "verification": {
        "method": "test",
        "acceptance_criteria": [
          "Set timeout_seconds=10 in config",
          "Execute ask command in direct mode and verify timeout behavior",
          "Execute ask command in server mode and verify timeout behavior",
          "Verify timeout logic is independent for each mode",
          "Change timeout in config and verify each mode uses its own timeout",
          "Confirm timeout handling does not mix between modes"
        ]
      },
      "traceability": {
        "journeys": [],
        "depends_on": [],
        "enables": [],
        "conflicts_with": [],
        "duplicates": [],
        "refines": [],
        "refines_parent": []
      },
      "issues": [],
      "open_questions": [],
      "rationale": "Ensures timeout behavior is consistent and predictable within each operation mode"
    }
  ],
  "issues": [],
  "open_questions": [
    {
      "id": "Q-001",
      "question": "What should happen if AILOOP_SERVER environment variable contains an invalid or malformed URL? Should system: a) validate URL format and fail early with validation error, b) attempt connection and let connection error (REQ-014) handle it, or c) something else?",
      "blocking": false,
      "priority": "medium",
      "affects_requirements": [
        "REQ-004"
      ],
      "affects_dimensions": [],
      "answer_format": "free_text",
      "status": "open",
      "answer": null,
      "created_by": "migration",
      "created_at": "2026-01-13T19:55:26.280334Z"
    },
    {
      "id": "Q-002",
      "question": "What should happen if the originating WebSocket connection is closed before server can send response? Should system: a) silently drop the response, b) log an error, c) attempt to reconnect, or d) fail with error?",
      "blocking": false,
      "priority": "medium",
      "affects_requirements": [
        "REQ-011"
      ],
      "affects_dimensions": [],
      "answer_format": "free_text",
      "status": "open",
      "answer": null,
      "created_by": "migration",
      "created_at": "2026-01-13T19:55:26.280357Z"
    },
    {
      "id": "Q-003",
      "question": "What should happen if WebSocket client receives response with correlation_id that doesn't match any pending request? Should system: a) ignore the response, b) log a warning, c) fail with error, or d) something else?",
      "blocking": false,
      "priority": "medium",
      "affects_requirements": [
        "REQ-012"
      ],
      "affects_dimensions": [],
      "answer_format": "free_text",
      "status": "open",
      "answer": null,
      "created_by": "migration",
      "created_at": "2026-01-13T19:55:26.280362Z"
    }
  ],
  "relation_evidence": {
    "depends_on": [
      {
        "from": "REQ-002",
        "to": "REQ-001",
        "confidence": 0.95,
        "evidence": "REQ-002 states 'WHEN AI agent executes CLI command without AILOOP_SERVER environment variable' - this requires REQ-001's mode detection to determine no AILOOP_SERVER is present"
      },
      {
        "from": "REQ-003",
        "to": "REQ-001",
        "confidence": 0.95,
        "evidence": "REQ-003 states 'WHEN AI agent executes CLI command with AILOOP_SERVER environment variable set' - this requires REQ-001's mode detection to determine AILOOP_SERVER is present"
      },
      {
        "from": "REQ-004",
        "to": "REQ-003",
        "confidence": 0.9,
        "evidence": "REQ-004 trigger is 'WHEN CLI command determines operation mode is server mode' - this requires REQ-003 to establish server mode first"
      },
      {
        "from": "REQ-006",
        "to": "REQ-005",
        "confidence": 0.95,
        "evidence": "REQ-006 trigger is 'WHEN WebSocket client has created Message' - this requires REQ-005 to create Message with correlation_id first"
      },
      {
        "from": "REQ-006",
        "to": "REQ-004",
        "confidence": 0.9,
        "evidence": "REQ-006 requires 'established connection' - this requires REQ-004 to establish WebSocket connection first"
      },
      {
        "from": "REQ-007",
        "to": "REQ-006",
        "confidence": 0.9,
        "evidence": "REQ-007 trigger is 'WHEN server receives Message from WebSocket client' - this requires REQ-006 to send message first"
      },
      {
        "from": "REQ-008",
        "to": "REQ-007",
        "confidence": 0.85,
        "evidence": "REQ-008 has same trigger as REQ-007 but logically requires message reception (REQ-007) before enqueueing"
      },
      {
        "from": "REQ-009",
        "to": "REQ-008",
        "confidence": 0.95,
        "evidence": "REQ-009 trigger is 'WHEN message is enqueued in server channel queue' - this requires REQ-008 to enqueue message first"
      },
      {
        "from": "REQ-010",
        "to": "REQ-009",
        "confidence": 0.9,
        "evidence": "REQ-010 trigger is 'WHEN human user provides response' - this requires REQ-009 to display message to human first"
      },
      {
        "from": "REQ-011",
        "to": "REQ-010",
        "confidence": 0.95,
        "evidence": "REQ-011 trigger is 'WHEN server creates response Message' - this requires REQ-010 to create response Message first"
      },
      {
        "from": "REQ-011",
        "to": "REQ-007",
        "confidence": 0.9,
        "evidence": "REQ-011 states 'use connection tracking to identify originating connection' - this requires REQ-007 to record connection mapping first"
      },
      {
        "from": "REQ-012",
        "to": "REQ-011",
        "confidence": 0.9,
        "evidence": "REQ-012 trigger is 'WHEN WebSocket client receives response Message' - this requires REQ-011 to send response via connection first"
      },
      {
        "from": "REQ-013",
        "to": "REQ-012",
        "confidence": 0.9,
        "evidence": "REQ-013 states 'wait for response Message from server with matching correlation_id' - this requires REQ-012's correlation_id matching capability"
      },
      {
        "from": "REQ-013",
        "to": "REQ-016",
        "confidence": 0.85,
        "evidence": "REQ-013 explicitly references 'timeout rules (REQ-016/REQ-017)' in its statement"
      },
      {
        "from": "REQ-013",
        "to": "REQ-017",
        "confidence": 0.85,
        "evidence": "REQ-013 explicitly references 'timeout rules (REQ-016/REQ-017)' in its statement"
      },
      {
        "from": "REQ-014",
        "to": "REQ-004",
        "confidence": 0.9,
        "evidence": "REQ-014 trigger is 'WHEN WebSocket client attempts to connect to server but connection fails' - this requires REQ-004's connection attempt first"
      },
      {
        "from": "REQ-018",
        "to": "REQ-016",
        "confidence": 0.85,
        "evidence": "REQ-018 trigger is 'WHEN timeout expires' - this requires REQ-016 to apply timeout first (when timeout > 0)"
      },
      {
        "from": "REQ-022",
        "to": "REQ-003",
        "confidence": 0.9,
        "evidence": "REQ-022 trigger is 'WHEN AI agent executes 'ailoop ask' command in server mode' - this requires REQ-003 to establish server mode"
      },
      {
        "from": "REQ-022",
        "to": "REQ-013",
        "confidence": 0.85,
        "evidence": "REQ-022 states 'wait for human response subject to timeout rules' - this requires REQ-013's waiting capability"
      },
      {
        "from": "REQ-023",
        "to": "REQ-003",
        "confidence": 0.9,
        "evidence": "REQ-023 trigger is 'WHEN AI agent executes 'ailoop authorize' command in server mode' - this requires REQ-003 to establish server mode"
      },
      {
        "from": "REQ-023",
        "to": "REQ-013",
        "confidence": 0.85,
        "evidence": "REQ-023 states 'wait for human decision subject to timeout rules' - this requires REQ-013's waiting capability"
      },
      {
        "from": "REQ-024",
        "to": "REQ-003",
        "confidence": 0.9,
        "evidence": "REQ-024 trigger is 'WHEN AI agent executes 'ailoop say' command in server mode' - this requires REQ-003 to establish server mode"
      }
    ],
    "enables": [
      {
        "from": "REQ-001",
        "to": "REQ-002",
        "confidence": 0.85,
        "evidence": "REQ-001's mode detection enables REQ-002's direct mode operation"
      },
      {
        "from": "REQ-001",
        "to": "REQ-003",
        "confidence": 0.85,
        "evidence": "REQ-001's mode detection enables REQ-003's server mode operation"
      },
      {
        "from": "REQ-003",
        "to": "REQ-004",
        "confidence": 0.8,
        "evidence": "REQ-003's server mode enables REQ-004's WebSocket connection establishment"
      },
      {
        "from": "REQ-003",
        "to": "REQ-022",
        "confidence": 0.85,
        "evidence": "REQ-003's server mode enables REQ-022's ask command in server mode"
      },
      {
        "from": "REQ-003",
        "to": "REQ-023",
        "confidence": 0.85,
        "evidence": "REQ-003's server mode enables REQ-023's authorize command in server mode"
      },
      {
        "from": "REQ-003",
        "to": "REQ-024",
        "confidence": 0.85,
        "evidence": "REQ-003's server mode enables REQ-024's say command in server mode"
      },
      {
        "from": "REQ-005",
        "to": "REQ-012",
        "confidence": 0.9,
        "evidence": "REQ-005's correlation_id creation enables REQ-012's response matching"
      },
      {
        "from": "REQ-007",
        "to": "REQ-011",
        "confidence": 0.9,
        "evidence": "REQ-007's connection tracking enables REQ-011's response routing"
      }
    ],
    "conflicts_with": [],
    "duplicates": [],
    "refines": [
      {
        "parent": "REQ-013",
        "child": "REQ-016",
        "confidence": 0.9,
        "evidence": "REQ-016 adds specific condition 'IF configuration file timeout_seconds is greater than 0' to REQ-013's general timeout waiting behavior"
      },
      {
        "parent": "REQ-013",
        "child": "REQ-017",
        "confidence": 0.9,
        "evidence": "REQ-017 adds specific condition 'IF configuration file timeout_seconds is 0' to REQ-013's general timeout waiting behavior"
      }
    ]
  }
}