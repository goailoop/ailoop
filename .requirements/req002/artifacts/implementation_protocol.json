{
  "meta": {
    "generated_at": "2026-01-13T20:33:04.000000Z",
    "requirement_set": "req002",
    "purpose": "Agent execution protocol for implementation iteration loop",
    "rules_applied": [
      "No repo-specific tools assumed",
      "Generic steps compatible with multi-agent parallel execution",
      "Evidence-based completion verification"
    ]
  },
  "protocol": {
    "task_selection": {
      "rule": "topological",
      "algorithm": {
        "step_1": "Filter tasks where all dependencies (depends_on) are completed",
        "step_2": "Sort by milestone_order (MS-01 before MS-02, etc.)",
        "step_3": "Within same milestone, prefer tasks with MUST requirements",
        "step_4": "Within same priority, prefer high-risk tasks (integration type, non-empty risk_flags)",
        "step_5": "Break ties by task ID order"
      },
      "prefer": [
        "milestone_order",
        "must_first",
        "high_risk_first"
      ],
      "parallelism": {
        "max_parallel_tasks": 3,
        "avoid_shared_entities": true,
        "rules": [
          "Do not run tasks in parallel if they share input entities",
          "Do not run tasks in parallel if they modify the same component",
          "Prefer parallel execution for independent tasks in same milestone"
        ]
      },
      "blocking_conditions": [
        "Task has uncompleted dependencies",
        "Task shares entities with currently running task (if avoid_shared_entities=true)",
        "Maximum parallel tasks limit reached"
      ]
    },
    "definition_of_done": [
      {
        "criterion": "acceptance_criteria",
        "description": "All mapped acceptance criteria from task's acceptance_gates.requirements_satisfied are satisfied",
        "verification": "Review component_contracts for each requirement's acceptance_criteria"
      },
      {
        "criterion": "test_cases",
        "description": "All test cases listed in task's acceptance_gates.test_cases pass",
        "verification": "Execute test cases from test_plan.json, record results in evidence"
      },
      {
        "criterion": "quality_contracts",
        "description": "All quality contracts listed in task's acceptance_gates.quality_contracts are met",
        "verification": "Verify measurable_criteria thresholds from quality_contracts.json"
      },
      {
        "criterion": "no_regression",
        "description": "No new high-severity issues introduced (existing tests still pass, no new errors)",
        "verification": "Run regression test suite, check for new failures"
      },
      {
        "criterion": "evidence_artifacts",
        "description": "Evidence artifacts recorded per evidence protocol",
        "verification": "Check evidence storage path for required artifacts"
      },
      {
        "criterion": "code_quality",
        "description": "Code follows component_contracts behavior_contract and interface_contracts specifications",
        "verification": "Code review against component contracts"
      }
    ],
    "evidence": {
      "required": [
        {
          "type": "test_report",
          "format": "json",
          "structure": {
            "task_id": "T-XXX",
            "test_cases": [
              {
                "test_case_id": "TC-REQ-XXX-XX",
                "status": "pass|fail|skip",
                "duration_ms": 0,
                "evidence_files": [],
                "notes": ""
              }
            ],
            "summary": {
              "total": 0,
              "passed": 0,
              "failed": 0,
              "skipped": 0
            }
          },
          "notes": "One test report per task, includes all test cases from acceptance_gates"
        },
        {
          "type": "trace_update",
          "format": "json",
          "structure": {
            "task_id": "T-XXX",
            "status": "completed|blocked|in_progress",
            "completed_at": "ISO8601 timestamp",
            "requirements_satisfied": [],
            "interfaces_implemented": [],
            "entities_created": [],
            "artifacts_produced": [],
            "blockers": [],
            "notes": ""
          },
          "notes": "Update traceability showing task completion and artifacts produced"
        },
        {
          "type": "code_artifacts",
          "format": "source_code",
          "structure": "Implementation files, test files, configuration files",
          "notes": "Actual code implementation matching component contracts"
        }
      ],
      "storage": {
        "path": "/artifacts/evidence/",
        "naming": {
          "test_report": "TASK_ID.test_report.json",
          "trace_update": "TASK_ID.trace_update.json",
          "code_artifacts": "TASK_ID.code/ (directory)"
        },
        "notes": "All evidence files prefixed with task ID for traceability"
      },
      "collection_steps": [
        "1. Before starting task: Create evidence directory TASK_ID.code/",
        "2. During implementation: Write code artifacts to TASK_ID.code/",
        "3. After implementation: Run test cases, record results in TASK_ID.test_report.json",
        "4. Update traceability: Create TASK_ID.trace_update.json with completion status",
        "5. Verify all evidence artifacts are present before marking task complete"
      ]
    },
    "change_control": {
      "if_requirement_change_needed": {
        "action": "route_back_to_requirements_router",
        "process": [
          "1. Document the requirement change needed in TASK_ID.trace_update.json blockers field",
          "2. Create issue in requirements/issues.json with type='requirement_change'",
          "3. Stop task implementation, mark status='blocked'",
          "4. Route to requirements engineering workflow (req-XX stages)",
          "5. After requirement change approved, update task inputs and resume"
        ],
        "triggers": [
          "Requirement is ambiguous or contradictory",
          "Requirement conflicts with implementation constraints",
          "New requirement discovered during implementation",
          "Requirement needs clarification or refinement"
        ]
      },
      "if_contract_change_needed": {
        "action": "route_back_to_design_router",
        "process": [
          "1. Document the contract change needed in TASK_ID.trace_update.json blockers field",
          "2. Create issue in requirements/issues.json with type='design_change'",
          "3. Stop task implementation, mark status='blocked'",
          "4. Route to design workflow (design-XX stages)",
          "5. After contract change approved, update component_contracts and resume"
        ],
        "triggers": [
          "Interface contract needs modification",
          "Data model entity needs new attributes or relationships",
          "Component behavior contract is incomplete or incorrect",
          "Quality contract thresholds need adjustment"
        ]
      },
      "if_test_change_needed": {
        "action": "update_test_plan",
        "process": [
          "1. Document test case change in TASK_ID.trace_update.json",
          "2. Update test_plan.json with new or modified test cases",
          "3. Update quality_contracts.json if test specs change",
          "4. Continue implementation with updated test plan"
        ],
        "triggers": [
          "Test case is incorrect or incomplete",
          "Additional test cases needed for coverage",
          "Test case needs refinement based on implementation details"
        ]
      }
    },
    "reporting": {
      "completion_report": {
        "when": "After task completion (all definition_of_done criteria met)",
        "format": "TASK_ID.trace_update.json",
        "required_fields": [
          "task_id",
          "status='completed'",
          "completed_at",
          "requirements_satisfied",
          "interfaces_implemented",
          "entities_created",
          "artifacts_produced"
        ]
      },
      "blocker_report": {
        "when": "When task is blocked (requirement/contract change needed, dependency issue, etc.)",
        "format": "TASK_ID.trace_update.json",
        "required_fields": [
          "task_id",
          "status='blocked'",
          "blockers (array with details)",
          "next_action (route_to_requirements|route_to_design|wait_for_dependency)"
        ]
      },
      "progress_report": {
        "when": "Periodic updates during long-running tasks",
        "format": "TASK_ID.trace_update.json",
        "required_fields": [
          "task_id",
          "status='in_progress'",
          "progress_percentage (optional)",
          "current_step",
          "notes"
        ]
      }
    },
    "multi_agent_coordination": {
      "task_claiming": {
        "method": "atomic_file_lock",
        "process": [
          "1. Agent checks available tasks (dependencies satisfied, not claimed)",
          "2. Agent creates lock file: TASK_ID.lock (contains agent_id, timestamp)",
          "3. If lock file creation succeeds, agent claims task",
          "4. If lock file exists, agent skips task and selects next available"
        ],
        "lock_timeout": "30 minutes (if lock older than 30min, assume agent crashed, allow reclaim)"
      },
      "shared_resources": {
        "entities": "Tasks sharing entities cannot run in parallel (enforced by task_selection)",
        "components": "Tasks modifying same component should not run in parallel",
        "files": "Use file-level locking or version control for shared code files"
      },
      "conflict_resolution": {
        "merge_conflicts": "Route to human reviewer if code conflicts occur",
        "contract_conflicts": "Route to design router if component contracts conflict",
        "test_conflicts": "Route to test plan update if test cases conflict"
      }
    }
  },
  "open_questions": []
}