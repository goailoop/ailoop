{
  "meta": {
    "generated_at": "2026-01-13T20:30:00.000000Z",
    "requirement_set": "req002",
    "purpose": "Per-component implementation contracts (tech-agnostic) for coding agents",
    "rules_applied": [
      "No tech stack selection",
      "No file paths, no class names",
      "Focus on behaviors, state transitions, invariants, interface semantics, error handling"
    ]
  },
  "components": [
    {
      "component_id": "COMP-001",
      "name": "Mode Detection Component",
      "scope": {
        "requirements": [
          "REQ-001",
          "REQ-002",
          "REQ-003"
        ],
        "interfaces_owned": [
          "IF-001"
        ],
        "entities_owned": []
      },
      "behavior_contract": [
        {
          "requirement_id": "REQ-001",
          "statement": "WHEN AI agent executes any ailoop CLI command, system SHALL determine if command should operate in direct mode (no AILOOP_SERVER env var) or server mode (AILOOP_SERVER env var present).",
          "expected_behavior": [
            "Execute 'ailoop ask \"test\"' without AILOOP_SERVER env var set",
            "Verify system operates in direct mode (question displayed in local terminal)",
            "Set AILOOP_SERVER=http://localhost:8080 and execute 'ailoop ask \"test\"'",
            "Verify system operates in server mode (attempts WebSocket connection)",
            "Confirm mode detection completes within 100ms of command execution"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Execute 'ailoop ask \"test\"' without AILOOP_SERVER env var set",
            "Verify system operates in direct mode (question displayed in local terminal)",
            "Set AILOOP_SERVER=http://localhost:8080 and execute 'ailoop ask \"test\"'",
            "Verify system operates in server mode (attempts WebSocket connection)",
            "Confirm mode detection completes within 100ms of command execution"
          ]
        },
        {
          "requirement_id": "REQ-002",
          "statement": "WHEN AI agent executes CLI command without AILOOP_SERVER environment variable, system SHALL operate in direct mode, displaying questions and collecting responses in local terminal.",
          "expected_behavior": [
            "Execute 'ailoop ask \"What is your name?\"' without AILOOP_SERVER env var",
            "Verify question is displayed in local terminal within 1 second",
            "Provide response and verify it is captured and returned to agent",
            "Confirm no WebSocket connection attempt is made",
            "Verify command completes in direct mode"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Execute 'ailoop ask \"What is your name?\"' without AILOOP_SERVER env var",
            "Verify question is displayed in local terminal within 1 second",
            "Provide response and verify it is captured and returned to agent",
            "Confirm no WebSocket connection attempt is made",
            "Verify command completes in direct mode"
          ]
        },
        {
          "requirement_id": "REQ-003",
          "statement": "WHEN AI agent executes CLI command with AILOOP_SERVER environment variable set, system SHALL operate in server mode, connecting to server specified in AILOOP_SERVER via WebSocket and sending messages.",
          "expected_behavior": [
            "Set AILOOP_SERVER=http://localhost:8080 environment variable",
            "Execute 'ailoop ask \"test question\"' command",
            "Verify system attempts WebSocket connection to ws://localhost:8080",
            "Confirm server mode is activated (no local terminal prompt)",
            "Verify message is sent via WebSocket connection"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Set AILOOP_SERVER=http://localhost:8080 environment variable",
            "Execute 'ailoop ask \"test question\"' command",
            "Verify system attempts WebSocket connection to ws://localhost:8080",
            "Confirm server mode is activated (no local terminal prompt)",
            "Verify message is sent via WebSocket connection"
          ]
        }
      ],
      "interface_contracts": [
        {
          "interface_id": "IF-001",
          "kind": "query",
          "purpose": "Determine whether CLI command should operate in direct mode or server mode based on command-line arguments and environment variables",
          "input_fields": [
            "command_line_args",
            "environment_variables"
          ],
          "output_fields": [
            "operation_mode",
            "server_url",
            "precedence_applied"
          ],
          "errors": [
            "INVALID_SERVER_URL"
          ],
          "idempotency": {
            "required": true,
            "key": "command_line_args + environment_variables",
            "notes": "Same inputs always produce same output"
          }
        }
      ],
      "data_contract": [
        {
          "entity": "OperationMode",
          "fields": [
            "mode",
            "server_url",
            "precedence_source",
            "determined_at"
          ],
          "classification": [],
          "invariants": [
            "When mode is 'server', server_url must be present and valid",
            "When mode is 'direct', server_url must be absent",
            "AILOOP_SERVER environment variable takes precedence over --server flag (REQ-003, REQ-004)",
            "If neither AILOOP_SERVER nor --server flag is present, mode must be 'direct' (REQ-002)"
          ],
          "lifecycle": {
            "states": [
              {
                "state": "determined",
                "description": "Operation mode has been determined"
              }
            ],
            "transitions": []
          }
        }
      ],
      "quality_obligations": [
        {
          "quality_contract_id": "QC-001",
          "category": "functional",
          "statement": "System SHALL determine operation mode (direct or server) within 100ms of command execution, correctly identifying mode based on AILOOP_SERVER environment variable presence or absence",
          "targets": []
        }
      ],
      "dependencies": {
        "depends_on_components": [],
        "consumes_interfaces": [],
        "publishes_events": []
      },
      "open_questions": []
    },
    {
      "component_id": "COMP-002",
      "name": "Direct Mode Handler",
      "scope": {
        "requirements": [
          "REQ-002",
          "REQ-020",
          "REQ-021",
          "REQ-036"
        ],
        "interfaces_owned": [
          "IF-002",
          "IF-003",
          "IF-004"
        ],
        "entities_owned": []
      },
      "behavior_contract": [
        {
          "requirement_id": "REQ-002",
          "statement": "WHEN AI agent executes CLI command without AILOOP_SERVER environment variable, system SHALL operate in direct mode, displaying questions and collecting responses in local terminal.",
          "expected_behavior": [
            "Execute 'ailoop ask \"What is your name?\"' without AILOOP_SERVER env var",
            "Verify question is displayed in local terminal within 1 second",
            "Provide response and verify it is captured and returned to agent",
            "Confirm no WebSocket connection attempt is made",
            "Verify command completes in direct mode"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Execute 'ailoop ask \"What is your name?\"' without AILOOP_SERVER env var",
            "Verify question is displayed in local terminal within 1 second",
            "Provide response and verify it is captured and returned to agent",
            "Confirm no WebSocket connection attempt is made",
            "Verify command completes in direct mode"
          ]
        },
        {
          "requirement_id": "REQ-020",
          "statement": "WHEN AI agent executes CLI command with channel parameter, system SHALL apply same channel name validation rules regardless of operation mode.",
          "expected_behavior": [
            "Execute command with --channel invalid-channel! in direct mode",
            "Verify channel validation error occurs",
            "Execute command with --channel invalid-channel! in server mode",
            "Verify same channel validation error occurs",
            "Execute with valid channel in both modes",
            "Confirm validation rules are identical in both modes"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Execute command with --channel invalid-channel! in direct mode",
            "Verify channel validation error occurs",
            "Execute command with --channel invalid-channel! in server mode",
            "Verify same channel validation error occurs",
            "Execute with valid channel in both modes",
            "Confirm validation rules are identical in both modes"
          ]
        },
        {
          "requirement_id": "REQ-021",
          "statement": "WHEN AI agent executes CLI command with --json flag, system SHALL generate JSON output with same structure and fields regardless of operation mode.",
          "expected_behavior": [
            "Execute 'ailoop ask \"test\"' --json in direct mode",
            "Capture JSON output structure",
            "Set AILOOP_SERVER and execute 'ailoop ask \"test\"' --json in server mode",
            "Capture JSON output structure",
            "Compare JSON structures and verify they are identical",
            "Verify same fields are present in both modes",
            "Confirm JSON format is consistent"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Execute 'ailoop ask \"test\"' --json in direct mode",
            "Capture JSON output structure",
            "Set AILOOP_SERVER and execute 'ailoop ask \"test\"' --json in server mode",
            "Capture JSON output structure",
            "Compare JSON structures and verify they are identical",
            "Verify same fields are present in both modes",
            "Confirm JSON format is consistent"
          ]
        },
        {
          "requirement_id": "REQ-036",
          "statement": "System SHALL NOT mix timeout handling between direct mode and server mode - each mode SHALL have independent timeout logic.",
          "expected_behavior": [
            "Set timeout_seconds=10 in config",
            "Execute ask command in direct mode and verify timeout behavior",
            "Execute ask command in server mode and verify timeout behavior",
            "Verify timeout logic is independent for each mode",
            "Change timeout in config and verify each mode uses its own timeout",
            "Confirm timeout handling does not mix between modes"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Set timeout_seconds=10 in config",
            "Execute ask command in direct mode and verify timeout behavior",
            "Execute ask command in server mode and verify timeout behavior",
            "Verify timeout logic is independent for each mode",
            "Change timeout in config and verify each mode uses its own timeout",
            "Confirm timeout handling does not mix between modes"
          ]
        }
      ],
      "interface_contracts": [
        {
          "interface_id": "IF-002",
          "kind": "command",
          "purpose": "Execute ask command in direct mode - display question in local terminal and collect response",
          "input_fields": [
            "question",
            "channel",
            "output_format",
            "timeout_seconds"
          ],
          "output_fields": [
            "response",
            "exit_code"
          ],
          "errors": [
            "INVALID_CHANNEL",
            "TIMEOUT",
            "CANCELLED"
          ],
          "idempotency": {
            "required": false,
            "key": null,
            "notes": "Not idempotent - each call prompts user and collects new response"
          }
        },
        {
          "interface_id": "IF-003",
          "kind": "command",
          "purpose": "Execute authorize command in direct mode - display authorization request in local terminal and collect decision",
          "input_fields": [
            "action_description",
            "channel",
            "output_format",
            "timeout_seconds"
          ],
          "output_fields": [
            "authorization_decision",
            "exit_code"
          ],
          "errors": [
            "INVALID_CHANNEL",
            "TIMEOUT",
            "CANCELLED"
          ],
          "idempotency": {
            "required": false,
            "key": null,
            "notes": "Not idempotent - each call prompts user and collects new decision"
          }
        },
        {
          "interface_id": "IF-004",
          "kind": "command",
          "purpose": "Execute say command in direct mode - display notification in local terminal",
          "input_fields": [
            "notification_text",
            "channel",
            "priority",
            "output_format"
          ],
          "output_fields": [
            "exit_code"
          ],
          "errors": [
            "INVALID_CHANNEL"
          ],
          "idempotency": {
            "required": false,
            "key": null,
            "notes": "Not idempotent - each call displays notification"
          }
        }
      ],
      "data_contract": [
        {
          "entity": "Message",
          "fields": [
            "id",
            "correlation_id",
            "message_type",
            "channel",
            "content",
            "priority",
            "timeout_seconds",
            "created_at"
          ],
          "classification": [],
          "invariants": [
            "correlation_id must be globally unique across all messages (REQ-027)",
            "channel must pass validation rules (REQ-020, REQ-033)",
            "For response messages (Answer, AuthorizationApproved, AuthorizationDenied), correlation_id must match an existing request message",
            "For request messages (Question, Authorization, Notification), correlation_id is generated at creation time",
            "timeout_seconds must be >= 0 (0 means indefinite wait per REQ-017)"
          ],
          "lifecycle": {
            "states": [
              {
                "state": "created",
                "description": "Message created with correlation_id"
              },
              {
                "state": "sent",
                "description": "Message sent to server (server mode) or displayed to user (direct mode)"
              },
              {
                "state": "queued",
                "description": "Message enqueued in channel queue (server mode only)"
              },
              {
                "state": "displayed",
                "description": "Message displayed to human user in terminal UI (server mode only)"
              },
              {
                "state": "responded",
                "description": "Response message created with matching correlation_id (for request messages)"
              },
              {
                "state": "completed",
                "description": "Message processing completed"
              }
            ],
            "transitions": [
              {
                "from": "created",
                "to": "sent",
                "trigger": "Message sent via WebSocket (server mode) or displayed in terminal (direct mode)"
              },
              {
                "from": "sent",
                "to": "queued",
                "trigger": "Message received by server and enqueued in channel queue (server mode only)"
              },
              {
                "from": "queued",
                "to": "displayed",
                "trigger": "Message displayed in server terminal UI (server mode only)"
              },
              {
                "from": "displayed",
                "to": "responded",
                "trigger": "Human user provides response, response message created with matching correlation_id"
              },
              {
                "from": "responded",
                "to": "completed",
                "trigger": "Response received by client and processing completed"
              }
            ]
          }
        }
      ],
      "quality_obligations": [
        {
          "quality_contract_id": "QC-002",
          "category": "functional",
          "statement": "System SHALL operate in direct mode when AILOOP_SERVER is absent, displaying questions in local terminal within 1 second and capturing user responses without attempting WebSocket connections",
          "targets": []
        }
      ],
      "dependencies": {
        "depends_on_components": [
          "COMP-001"
        ],
        "consumes_interfaces": [
          "IF-001"
        ],
        "publishes_events": []
      },
      "open_questions": []
    },
    {
      "component_id": "COMP-003",
      "name": "Server Mode Client",
      "scope": {
        "requirements": [
          "REQ-003",
          "REQ-004",
          "REQ-005",
          "REQ-006",
          "REQ-012",
          "REQ-013",
          "REQ-014",
          "REQ-016",
          "REQ-017",
          "REQ-018",
          "REQ-020",
          "REQ-021",
          "REQ-022",
          "REQ-023",
          "REQ-024",
          "REQ-025",
          "REQ-033",
          "REQ-034",
          "REQ-035",
          "REQ-036"
        ],
        "interfaces_owned": [
          "IF-005",
          "IF-006",
          "IF-007",
          "IF-008"
        ],
        "entities_owned": []
      },
      "behavior_contract": [
        {
          "requirement_id": "REQ-003",
          "statement": "WHEN AI agent executes CLI command with AILOOP_SERVER environment variable set, system SHALL operate in server mode, connecting to server specified in AILOOP_SERVER via WebSocket and sending messages.",
          "expected_behavior": [
            "Set AILOOP_SERVER=http://localhost:8080 environment variable",
            "Execute 'ailoop ask \"test question\"' command",
            "Verify system attempts WebSocket connection to ws://localhost:8080",
            "Confirm server mode is activated (no local terminal prompt)",
            "Verify message is sent via WebSocket connection"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Set AILOOP_SERVER=http://localhost:8080 environment variable",
            "Execute 'ailoop ask \"test question\"' command",
            "Verify system attempts WebSocket connection to ws://localhost:8080",
            "Confirm server mode is activated (no local terminal prompt)",
            "Verify message is sent via WebSocket connection"
          ]
        },
        {
          "requirement_id": "REQ-004",
          "statement": "WHEN CLI command determines operation mode is server mode, system SHALL convert server URL from http/https to ws/wss protocol and establish WebSocket connection.",
          "expected_behavior": [
            "Set AILOOP_SERVER=http://localhost:8080 and execute command",
            "Verify URL is converted from http:// to ws:// protocol",
            "Set AILOOP_SERVER=https://example.com:443 and execute command",
            "Verify URL is converted from https:// to wss:// protocol",
            "Confirm WebSocket connection is established successfully"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Set AILOOP_SERVER=http://localhost:8080 and execute command",
            "Verify URL is converted from http:// to ws:// protocol",
            "Set AILOOP_SERVER=https://example.com:443 and execute command",
            "Verify URL is converted from https:// to wss:// protocol",
            "Confirm WebSocket connection is established successfully"
          ]
        },
        {
          "requirement_id": "REQ-005",
          "statement": "WHEN WebSocket client sends question, authorization, or notification message to server, system SHALL create Message object with globally unique correlation_id (UUID) to enable response matching.",
          "expected_behavior": [
            "Send question message via WebSocket client",
            "Verify Message object contains correlation_id field",
            "Verify correlation_id is UUID format (8-4-4-4-12 hexadecimal)",
            "Send authorization message and verify unique correlation_id",
            "Send notification message and verify unique correlation_id",
            "Confirm all correlation_ids are globally unique (no duplicates across 1000 messages)"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Send question message via WebSocket client",
            "Verify Message object contains correlation_id field",
            "Verify correlation_id is UUID format (8-4-4-4-12 hexadecimal)",
            "Send authorization message and verify unique correlation_id",
            "Send notification message and verify unique correlation_id",
            "Confirm all correlation_ids are globally unique (no duplicates across 1000 messages)"
          ]
        },
        {
          "requirement_id": "REQ-006",
          "statement": "WHEN WebSocket client has created Message and established connection, system SHALL serialize Message to JSON and send via WebSocket connection to server.",
          "expected_behavior": [
            "Create Message object with question content",
            "Establish WebSocket connection to server",
            "Verify Message is serialized to valid JSON format",
            "Verify JSON message is sent via WebSocket connection",
            "Confirm message arrives at server within 1 second",
            "Verify server can parse received JSON message"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Create Message object with question content",
            "Establish WebSocket connection to server",
            "Verify Message is serialized to valid JSON format",
            "Verify JSON message is sent via WebSocket connection",
            "Confirm message arrives at server within 1 second",
            "Verify server can parse received JSON message"
          ]
        },
        {
          "requirement_id": "REQ-012",
          "statement": "WHEN WebSocket client receives response Message from server, system SHALL maintain a map of pending requests keyed by correlation_id and match response correlation_id to correct pending request using lookup.",
          "expected_behavior": [
            "Send request with correlation_id='req-1'",
            "Send request with correlation_id='req-2'",
            "Receive response with correlation_id='req-1'",
            "Verify response is matched to first request (req-1)",
            "Receive response with correlation_id='req-2'",
            "Verify response is matched to second request (req-2)",
            "Confirm map lookup correctly matches correlation_ids",
            "Verify unmatched correlation_id is handled appropriately"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Send request with correlation_id='req-1'",
            "Send request with correlation_id='req-2'",
            "Receive response with correlation_id='req-1'",
            "Verify response is matched to first request (req-1)",
            "Receive response with correlation_id='req-2'",
            "Verify response is matched to second request (req-2)",
            "Confirm map lookup correctly matches correlation_ids",
            "Verify unmatched correlation_id is handled appropriately"
          ]
        },
        {
          "requirement_id": "REQ-013",
          "statement": "WHEN WebSocket client sends question or authorization message to server, system SHALL wait for response Message from server with matching correlation_id subject to timeout rules (REQ-016/REQ-017).",
          "expected_behavior": [
            "Send question message to server",
            "Verify client waits for response with matching correlation_id",
            "Set timeout_seconds=5 in config and send question",
            "Verify timeout rules (REQ-016) are applied (timeout set to 5 seconds)",
            "Set timeout_seconds=0 in config and send question",
            "Verify client waits indefinitely (no timeout after 60 seconds) per REQ-017",
            "Confirm timeout rules (REQ-016/REQ-017) are applied correctly during waiting"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Send question message to server",
            "Verify client waits for response with matching correlation_id",
            "Set timeout_seconds=5 in config and send question",
            "Verify timeout rules (REQ-016) are applied (timeout set to 5 seconds)",
            "Set timeout_seconds=0 in config and send question",
            "Verify client waits indefinitely (no timeout after 60 seconds) per REQ-017",
            "Confirm timeout rules (REQ-016/REQ-017) are applied correctly during waiting"
          ]
        },
        {
          "requirement_id": "REQ-014",
          "statement": "WHEN WebSocket client attempts to connect to server but connection fails, system SHALL display error message in format 'Failed to connect to server at {URL}: {error_type}. Ensure server is running and accessible.' and exit with error code 1, without falling back to direct mode.",
          "expected_behavior": [
            "Set AILOOP_SERVER=http://unreachable:8080",
            "Execute 'ailoop ask \"test\"' command",
            "Verify error message format: 'Failed to connect to server at http://unreachable:8080: {error_type}. Ensure server is running and accessible.'",
            "Verify error_type is specific (connection refused, network unreachable, etc.)",
            "Verify command exits with error code 1",
            "Verify system does NOT fall back to direct mode",
            "Confirm error message includes URL and actionable guidance"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Set AILOOP_SERVER=http://unreachable:8080",
            "Execute 'ailoop ask \"test\"' command",
            "Verify error message format: 'Failed to connect to server at http://unreachable:8080: {error_type}. Ensure server is running and accessible.'",
            "Verify error_type is specific (connection refused, network unreachable, etc.)",
            "Verify command exits with error code 1",
            "Verify system does NOT fall back to direct mode",
            "Confirm error message includes URL and actionable guidance"
          ]
        },
        {
          "requirement_id": "REQ-016",
          "statement": "WHEN WebSocket client waits for server response in server mode, IF configuration file timeout_seconds is greater than 0, system SHALL apply timeout_seconds from configuration file as maximum wait time for server response.",
          "expected_behavior": [
            "Set timeout_seconds=10 in configuration file",
            "Send question message in server mode",
            "Verify timeout of 10 seconds is applied",
            "Wait 11 seconds without response",
            "Verify timeout error occurs at 10 seconds (within 100ms tolerance)",
            "Set timeout_seconds=30 and verify 30 second timeout is applied",
            "Confirm timeout_seconds from config file is used correctly"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Set timeout_seconds=10 in configuration file",
            "Send question message in server mode",
            "Verify timeout of 10 seconds is applied",
            "Wait 11 seconds without response",
            "Verify timeout error occurs at 10 seconds (within 100ms tolerance)",
            "Set timeout_seconds=30 and verify 30 second timeout is applied",
            "Confirm timeout_seconds from config file is used correctly"
          ]
        },
        {
          "requirement_id": "REQ-017",
          "statement": "WHEN WebSocket client waits for server response in server mode, IF configuration file timeout_seconds is 0, system SHALL wait indefinitely for server response without timeout expiration.",
          "expected_behavior": [
            "Set timeout_seconds=0 in configuration file",
            "Send question message in server mode",
            "Wait 60 seconds without response",
            "Verify no timeout error occurs",
            "Wait 300 seconds without response",
            "Verify still no timeout error occurs",
            "Confirm system waits indefinitely when timeout_seconds=0"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Set timeout_seconds=0 in configuration file",
            "Send question message in server mode",
            "Wait 60 seconds without response",
            "Verify no timeout error occurs",
            "Wait 300 seconds without response",
            "Verify still no timeout error occurs",
            "Confirm system waits indefinitely when timeout_seconds=0"
          ]
        },
        {
          "requirement_id": "REQ-018",
          "statement": "WHEN timeout expires while waiting for server response, system SHALL display timeout error message and exit with error code 1.",
          "expected_behavior": [
            "Set timeout_seconds=5 in configuration",
            "Send question message and wait 6 seconds",
            "Verify timeout error message is displayed",
            "Verify command exits with error code 1",
            "Verify timeout occurs within 100ms of configured timeout",
            "Confirm timeout error is clear and actionable"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Set timeout_seconds=5 in configuration",
            "Send question message and wait 6 seconds",
            "Verify timeout error message is displayed",
            "Verify command exits with error code 1",
            "Verify timeout occurs within 100ms of configured timeout",
            "Confirm timeout error is clear and actionable"
          ]
        },
        {
          "requirement_id": "REQ-020",
          "statement": "WHEN AI agent executes CLI command with channel parameter, system SHALL apply same channel name validation rules regardless of operation mode.",
          "expected_behavior": [
            "Execute command with --channel invalid-channel! in direct mode",
            "Verify channel validation error occurs",
            "Execute command with --channel invalid-channel! in server mode",
            "Verify same channel validation error occurs",
            "Execute with valid channel in both modes",
            "Confirm validation rules are identical in both modes"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Execute command with --channel invalid-channel! in direct mode",
            "Verify channel validation error occurs",
            "Execute command with --channel invalid-channel! in server mode",
            "Verify same channel validation error occurs",
            "Execute with valid channel in both modes",
            "Confirm validation rules are identical in both modes"
          ]
        },
        {
          "requirement_id": "REQ-021",
          "statement": "WHEN AI agent executes CLI command with --json flag, system SHALL generate JSON output with same structure and fields regardless of operation mode.",
          "expected_behavior": [
            "Execute 'ailoop ask \"test\"' --json in direct mode",
            "Capture JSON output structure",
            "Set AILOOP_SERVER and execute 'ailoop ask \"test\"' --json in server mode",
            "Capture JSON output structure",
            "Compare JSON structures and verify they are identical",
            "Verify same fields are present in both modes",
            "Confirm JSON format is consistent"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Execute 'ailoop ask \"test\"' --json in direct mode",
            "Capture JSON output structure",
            "Set AILOOP_SERVER and execute 'ailoop ask \"test\"' --json in server mode",
            "Capture JSON output structure",
            "Compare JSON structures and verify they are identical",
            "Verify same fields are present in both modes",
            "Confirm JSON format is consistent"
          ]
        },
        {
          "requirement_id": "REQ-022",
          "statement": "WHEN AI agent executes 'ailoop ask' command in server mode, system SHALL send question to server, wait for human response subject to timeout rules, and return response to agent.",
          "expected_behavior": [
            "Set AILOOP_SERVER and execute 'ailoop ask \"What is the answer?\"'",
            "Verify question is sent to server via WebSocket",
            "Provide response in server terminal",
            "Verify response is received by client",
            "Verify response is returned to agent",
            "Confirm complete request-response cycle works",
            "Verify timeout rules are applied during wait"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Set AILOOP_SERVER and execute 'ailoop ask \"What is the answer?\"'",
            "Verify question is sent to server via WebSocket",
            "Provide response in server terminal",
            "Verify response is received by client",
            "Verify response is returned to agent",
            "Confirm complete request-response cycle works",
            "Verify timeout rules are applied during wait"
          ]
        },
        {
          "requirement_id": "REQ-023",
          "statement": "WHEN AI agent executes 'ailoop authorize' command in server mode, system SHALL send authorization request to server, wait for human decision subject to timeout rules, and return approval/denial to agent.",
          "expected_behavior": [
            "Set AILOOP_SERVER and execute 'ailoop authorize \"Deploy to prod\"'",
            "Verify authorization request is sent to server",
            "Provide 'authorized' response in server terminal",
            "Verify approval decision is received by client",
            "Verify command exits with code 0 (authorized)",
            "Provide 'denied' response in server terminal",
            "Verify denial decision is received and command exits with code 1",
            "Confirm timeout rules are applied during wait"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Set AILOOP_SERVER and execute 'ailoop authorize \"Deploy to prod\"'",
            "Verify authorization request is sent to server",
            "Provide 'authorized' response in server terminal",
            "Verify approval decision is received by client",
            "Verify command exits with code 0 (authorized)",
            "Provide 'denied' response in server terminal",
            "Verify denial decision is received and command exits with code 1",
            "Confirm timeout rules are applied during wait"
          ]
        },
        {
          "requirement_id": "REQ-024",
          "statement": "WHEN AI agent executes 'ailoop say' command in server mode, system SHALL send notification message to server and complete immediately without waiting for response.",
          "expected_behavior": [
            "Set AILOOP_SERVER and execute 'ailoop say \"Notification\"'",
            "Verify notification is sent to server via WebSocket",
            "Verify command completes immediately (within 1 second)",
            "Verify no response waiting occurs",
            "Verify notification appears in server terminal UI",
            "Confirm command exits with success code 0"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Set AILOOP_SERVER and execute 'ailoop say \"Notification\"'",
            "Verify notification is sent to server via WebSocket",
            "Verify command completes immediately (within 1 second)",
            "Verify no response waiting occurs",
            "Verify notification appears in server terminal UI",
            "Confirm command exits with success code 0"
          ]
        },
        {
          "requirement_id": "REQ-025",
          "statement": "System SHALL NOT fall back to direct mode when server connection fails in server mode.",
          "expected_behavior": [
            "Set AILOOP_SERVER=http://unreachable:8080",
            "Execute 'ailoop ask \"test\"' command",
            "Verify connection fails",
            "Verify system does NOT fall back to direct mode",
            "Verify error is reported and command fails",
            "Confirm no local terminal prompt appears"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Set AILOOP_SERVER=http://unreachable:8080",
            "Execute 'ailoop ask \"test\"' command",
            "Verify connection fails",
            "Verify system does NOT fall back to direct mode",
            "Verify error is reported and command fails",
            "Confirm no local terminal prompt appears"
          ]
        },
        {
          "requirement_id": "REQ-033",
          "statement": "System SHALL NOT allow messages to bypass channel validation in server mode.",
          "expected_behavior": [
            "Attempt to send message with invalid channel name in server mode",
            "Verify channel validation error occurs",
            "Attempt to send message with valid channel name in server mode",
            "Verify message is accepted",
            "Compare validation behavior with direct mode",
            "Confirm channel validation is identical in both modes"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Attempt to send message with invalid channel name in server mode",
            "Verify channel validation error occurs",
            "Attempt to send message with valid channel name in server mode",
            "Verify message is accepted",
            "Compare validation behavior with direct mode",
            "Confirm channel validation is identical in both modes"
          ]
        },
        {
          "requirement_id": "REQ-034",
          "statement": "System SHALL NOT process responses with correlation_id that does not match any pending request without logging or handling appropriately.",
          "expected_behavior": [
            "Send request with correlation_id='req-1'",
            "Receive response with correlation_id='req-999' (non-existent)",
            "Verify system detects unmatched correlation_id",
            "Verify system logs warning or handles appropriately",
            "Verify system does NOT crash or fail silently",
            "Confirm orphaned responses are detected and handled"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Send request with correlation_id='req-1'",
            "Receive response with correlation_id='req-999' (non-existent)",
            "Verify system detects unmatched correlation_id",
            "Verify system logs warning or handles appropriately",
            "Verify system does NOT crash or fail silently",
            "Confirm orphaned responses are detected and handled"
          ]
        },
        {
          "requirement_id": "REQ-035",
          "statement": "System SHALL NOT allow AILOOP_SERVER environment variable to point to invalid or malicious URLs without validation.",
          "expected_behavior": [
            "Set AILOOP_SERVER=invalid-url-format",
            "Execute command and verify URL validation error",
            "Set AILOOP_SERVER=http://",
            "Execute command and verify URL validation error",
            "Set AILOOP_SERVER=not-a-url",
            "Execute command and verify URL validation error",
            "Verify invalid URLs are rejected before connection attempt",
            "Confirm URL validation prevents connection to invalid destinations"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Set AILOOP_SERVER=invalid-url-format",
            "Execute command and verify URL validation error",
            "Set AILOOP_SERVER=http://",
            "Execute command and verify URL validation error",
            "Set AILOOP_SERVER=not-a-url",
            "Execute command and verify URL validation error",
            "Verify invalid URLs are rejected before connection attempt",
            "Confirm URL validation prevents connection to invalid destinations"
          ]
        },
        {
          "requirement_id": "REQ-036",
          "statement": "System SHALL NOT mix timeout handling between direct mode and server mode - each mode SHALL have independent timeout logic.",
          "expected_behavior": [
            "Set timeout_seconds=10 in config",
            "Execute ask command in direct mode and verify timeout behavior",
            "Execute ask command in server mode and verify timeout behavior",
            "Verify timeout logic is independent for each mode",
            "Change timeout in config and verify each mode uses its own timeout",
            "Confirm timeout handling does not mix between modes"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Set timeout_seconds=10 in config",
            "Execute ask command in direct mode and verify timeout behavior",
            "Execute ask command in server mode and verify timeout behavior",
            "Verify timeout logic is independent for each mode",
            "Change timeout in config and verify each mode uses its own timeout",
            "Confirm timeout handling does not mix between modes"
          ]
        }
      ],
      "interface_contracts": [
        {
          "interface_id": "IF-005",
          "kind": "command",
          "purpose": "Establish connection to server by converting URL protocol and initiating connection",
          "input_fields": [
            "server_url"
          ],
          "output_fields": [
            "connection_id",
            "websocket_url"
          ],
          "errors": [
            "INVALID_URL",
            "CONNECTION_FAILED",
            "HANDSHAKE_FAILED"
          ],
          "idempotency": {
            "required": false,
            "key": null,
            "notes": "Not idempotent - each call creates new connection"
          }
        },
        {
          "interface_id": "IF-006",
          "kind": "command",
          "purpose": "Create message with correlation_id, serialize to JSON, and send via WebSocket connection",
          "input_fields": [
            "connection_id",
            "message_type",
            "content",
            "channel",
            "priority",
            "timeout_seconds"
          ],
          "output_fields": [
            "correlation_id",
            "message_id"
          ],
          "errors": [
            "INVALID_CHANNEL",
            "CONNECTION_CLOSED",
            "SERIALIZATION_ERROR"
          ],
          "idempotency": {
            "required": false,
            "key": null,
            "notes": "Not idempotent - each call generates new correlation_id and sends new message"
          }
        },
        {
          "interface_id": "IF-007",
          "kind": "command",
          "purpose": "Wait for response message from server with matching correlation_id, subject to timeout rules",
          "input_fields": [
            "connection_id",
            "correlation_id",
            "timeout_seconds"
          ],
          "output_fields": [
            "response_message"
          ],
          "errors": [
            "TIMEOUT",
            "CONNECTION_CLOSED",
            "UNMATCHED_RESPONSE"
          ],
          "idempotency": {
            "required": false,
            "key": null,
            "notes": "Not idempotent - waits for specific response and consumes it"
          }
        },
        {
          "interface_id": "IF-008",
          "kind": "query",
          "purpose": "Retrieve list of pending requests waiting for responses",
          "input_fields": [
            "connection_id"
          ],
          "output_fields": [
            "pending_requests"
          ],
          "errors": [],
          "idempotency": {
            "required": true,
            "key": "connection_id",
            "notes": "Idempotent - same inputs return same pending requests list"
          }
        }
      ],
      "data_contract": [
        {
          "entity": "Message",
          "fields": [
            "id",
            "correlation_id",
            "message_type",
            "channel",
            "content",
            "priority",
            "timeout_seconds",
            "created_at"
          ],
          "classification": [],
          "invariants": [
            "correlation_id must be globally unique across all messages (REQ-027)",
            "channel must pass validation rules (REQ-020, REQ-033)",
            "For response messages (Answer, AuthorizationApproved, AuthorizationDenied), correlation_id must match an existing request message",
            "For request messages (Question, Authorization, Notification), correlation_id is generated at creation time",
            "timeout_seconds must be >= 0 (0 means indefinite wait per REQ-017)"
          ],
          "lifecycle": {
            "states": [
              {
                "state": "created",
                "description": "Message created with correlation_id"
              },
              {
                "state": "sent",
                "description": "Message sent to server (server mode) or displayed to user (direct mode)"
              },
              {
                "state": "queued",
                "description": "Message enqueued in channel queue (server mode only)"
              },
              {
                "state": "displayed",
                "description": "Message displayed to human user in terminal UI (server mode only)"
              },
              {
                "state": "responded",
                "description": "Response message created with matching correlation_id (for request messages)"
              },
              {
                "state": "completed",
                "description": "Message processing completed"
              }
            ],
            "transitions": [
              {
                "from": "created",
                "to": "sent",
                "trigger": "Message sent via WebSocket (server mode) or displayed in terminal (direct mode)"
              },
              {
                "from": "sent",
                "to": "queued",
                "trigger": "Message received by server and enqueued in channel queue (server mode only)"
              },
              {
                "from": "queued",
                "to": "displayed",
                "trigger": "Message displayed in server terminal UI (server mode only)"
              },
              {
                "from": "displayed",
                "to": "responded",
                "trigger": "Human user provides response, response message created with matching correlation_id"
              },
              {
                "from": "responded",
                "to": "completed",
                "trigger": "Response received by client and processing completed"
              }
            ]
          }
        },
        {
          "entity": "Connection",
          "fields": [
            "connection_id",
            "server_url",
            "state",
            "established_at",
            "closed_at"
          ],
          "classification": [],
          "invariants": [
            "connection_id must be unique",
            "When state is 'connected', established_at must be set",
            "When state is 'closed', closed_at must be set and closed_at >= established_at",
            "server_url must be valid WebSocket URL format (ws:// or wss://)"
          ],
          "lifecycle": {
            "states": [
              {
                "state": "establishing",
                "description": "Connection attempt in progress"
              },
              {
                "state": "connected",
                "description": "Connection established and active"
              },
              {
                "state": "closed",
                "description": "Connection closed (by client or server)"
              }
            ],
            "transitions": [
              {
                "from": "establishing",
                "to": "connected",
                "trigger": "WebSocket handshake successful"
              },
              {
                "from": "establishing",
                "to": "closed",
                "trigger": "Connection attempt failed"
              },
              {
                "from": "connected",
                "to": "closed",
                "trigger": "Connection closed by client or server"
              }
            ]
          }
        },
        {
          "entity": "PendingRequest",
          "fields": [
            "correlation_id",
            "connection_id",
            "message_type",
            "sent_at",
            "timeout_seconds"
          ],
          "classification": [],
          "invariants": [
            "correlation_id must be unique across all pending requests",
            "correlation_id must match the message's correlation_id",
            "timeout_seconds must be >= 0 (0 means indefinite wait per REQ-017)",
            "Pending request must be removed when response is received or timeout expires"
          ],
          "lifecycle": {
            "states": [
              {
                "state": "pending",
                "description": "Request sent, waiting for response"
              },
              {
                "state": "matched",
                "description": "Response received and matched"
              },
              {
                "state": "timeout",
                "description": "Timeout expired before response received"
              },
              {
                "state": "cancelled",
                "description": "Request cancelled (connection closed)"
              }
            ],
            "transitions": [
              {
                "from": "pending",
                "to": "matched",
                "trigger": "Response received with matching correlation_id"
              },
              {
                "from": "pending",
                "to": "timeout",
                "trigger": "Timeout expired (if timeout_seconds > 0)"
              },
              {
                "from": "pending",
                "to": "cancelled",
                "trigger": "Connection closed"
              }
            ]
          }
        }
      ],
      "quality_obligations": [
        {
          "quality_contract_id": "QC-003",
          "category": "functional",
          "statement": "System SHALL activate server mode when AILOOP_SERVER is set, attempt WebSocket connection to converted URL, and send messages via connection without displaying local terminal prompts",
          "targets": []
        },
        {
          "quality_contract_id": "QC-004",
          "category": "functional",
          "statement": "System SHALL convert server URL from http/https to ws/wss protocol and establish WebSocket connection successfully",
          "targets": []
        },
        {
          "quality_contract_id": "QC-005",
          "category": "functional",
          "statement": "System SHALL create Message objects with globally unique correlation_id in UUID format (8-4-4-4-12 hexadecimal) for all message types",
          "targets": []
        },
        {
          "quality_contract_id": "QC-006",
          "category": "functional",
          "statement": "System SHALL serialize Message objects to valid JSON format and send via WebSocket connection, with messages arriving at server within 1 second",
          "targets": []
        },
        {
          "quality_contract_id": "QC-012",
          "category": "functional",
          "statement": "System SHALL maintain map of pending requests keyed by correlation_id and match response correlation_id to correct pending request using lookup",
          "targets": []
        },
        {
          "quality_contract_id": "QC-013",
          "category": "functional",
          "statement": "System SHALL wait for response Message from server with matching correlation_id, applying timeout rules: timeout_seconds > 0 applies finite timeout, timeout_seconds = 0 waits indefinitely",
          "targets": []
        },
        {
          "quality_contract_id": "QC-014",
          "category": "error_handling",
          "statement": "System SHALL display error message in format 'Failed to connect to server at {URL}: {error_type}. Ensure server is running and accessible.' and exit with error code 1, without falling back to direct mode",
          "targets": []
        },
        {
          "quality_contract_id": "QC-016",
          "category": "functional",
          "statement": "System SHALL apply timeout_seconds from configuration file as maximum wait time for server response when timeout_seconds > 0",
          "targets": []
        },
        {
          "quality_contract_id": "QC-017",
          "category": "functional",
          "statement": "System SHALL wait indefinitely for server response when configuration timeout_seconds is 0, without timeout expiration",
          "targets": []
        },
        {
          "quality_contract_id": "QC-018",
          "category": "error_handling",
          "statement": "System SHALL display timeout error message and exit with error code 1 when timeout expires while waiting for server response",
          "targets": []
        },
        {
          "quality_contract_id": "QC-022",
          "category": "functional",
          "statement": "System SHALL send question to server, wait for human response subject to timeout rules, and return response to agent",
          "targets": []
        },
        {
          "quality_contract_id": "QC-023",
          "category": "functional",
          "statement": "System SHALL send authorization request to server, wait for human decision subject to timeout rules, and return approval/denial to agent with appropriate exit codes",
          "targets": []
        },
        {
          "quality_contract_id": "QC-024",
          "category": "functional",
          "statement": "System SHALL send notification message to server and complete immediately without waiting for response",
          "targets": []
        },
        {
          "quality_contract_id": "QC-035",
          "category": "validation",
          "statement": "System SHALL NOT allow AILOOP_SERVER environment variable to point to invalid or malicious URLs without validation",
          "targets": []
        }
      ],
      "dependencies": {
        "depends_on_components": [
          "COMP-001",
          "COMP-004"
        ],
        "consumes_interfaces": [
          "IF-001",
          "IF-009",
          "IF-010",
          "IF-011",
          "IF-012"
        ],
        "publishes_events": []
      },
      "open_questions": []
    },
    {
      "component_id": "COMP-004",
      "name": "Server Mode Server",
      "scope": {
        "requirements": [
          "REQ-007",
          "REQ-008",
          "REQ-009",
          "REQ-010",
          "REQ-011",
          "REQ-026",
          "REQ-029",
          "REQ-030",
          "REQ-031"
        ],
        "interfaces_owned": [
          "IF-009",
          "IF-010",
          "IF-011",
          "IF-012"
        ],
        "entities_owned": []
      },
      "behavior_contract": [
        {
          "requirement_id": "REQ-007",
          "statement": "WHEN server receives Message from WebSocket client, system SHALL record mapping between incoming message and originating WebSocket connection for response routing.",
          "expected_behavior": [
            "Send message from WebSocket client to server",
            "Verify server records mapping between message and connection",
            "Send second message from different connection",
            "Verify server maintains separate mappings for each connection",
            "Confirm mapping persists until response is sent or connection closes"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Send message from WebSocket client to server",
            "Verify server records mapping between message and connection",
            "Send second message from different connection",
            "Verify server maintains separate mappings for each connection",
            "Confirm mapping persists until response is sent or connection closes"
          ]
        },
        {
          "requirement_id": "REQ-008",
          "statement": "WHEN server receives Message from WebSocket client, system SHALL add message to queue for the channel specified in message, maintaining channel isolation.",
          "expected_behavior": [
            "Send message with channel='test-channel' to server",
            "Verify message is added to queue for 'test-channel'",
            "Send message with channel='other-channel' to server",
            "Verify message is added to queue for 'other-channel'",
            "Verify messages in different channels are isolated (cannot access cross-channel)",
            "Confirm channel isolation is maintained"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Send message with channel='test-channel' to server",
            "Verify message is added to queue for 'test-channel'",
            "Send message with channel='other-channel' to server",
            "Verify message is added to queue for 'other-channel'",
            "Verify messages in different channels are isolated (cannot access cross-channel)",
            "Confirm channel isolation is maintained"
          ]
        },
        {
          "requirement_id": "REQ-009",
          "statement": "WHEN message is enqueued in server channel queue, system SHALL display message content (question, authorization request, or notification) in server terminal UI for human interaction.",
          "expected_behavior": [
            "Enqueue question message in server channel queue",
            "Verify question text appears in server terminal UI within 500ms",
            "Enqueue authorization message and verify it appears in terminal UI",
            "Enqueue notification message and verify it appears in terminal UI",
            "Confirm message content matches exactly what was sent",
            "Verify messages appear in order of enqueueing"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Enqueue question message in server channel queue",
            "Verify question text appears in server terminal UI within 500ms",
            "Enqueue authorization message and verify it appears in terminal UI",
            "Enqueue notification message and verify it appears in terminal UI",
            "Confirm message content matches exactly what was sent",
            "Verify messages appear in order of enqueueing"
          ]
        },
        {
          "requirement_id": "REQ-010",
          "statement": "WHEN human user provides response to question or authorization request in server terminal, system SHALL create response Message with correlation_id set to the id of the original request message.",
          "expected_behavior": [
            "Send question message with id='msg-123' to server",
            "Human provides response in server terminal",
            "Verify response Message has correlation_id='msg-123'",
            "Send authorization message with id='msg-456'",
            "Human provides authorization decision",
            "Verify response Message has correlation_id='msg-456'",
            "Confirm correlation_id matches original request id exactly"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Send question message with id='msg-123' to server",
            "Human provides response in server terminal",
            "Verify response Message has correlation_id='msg-123'",
            "Send authorization message with id='msg-456'",
            "Human provides authorization decision",
            "Verify response Message has correlation_id='msg-456'",
            "Confirm correlation_id matches original request id exactly"
          ]
        },
        {
          "requirement_id": "REQ-011",
          "statement": "WHEN server creates response Message with correlation_id matching request, system SHALL use connection tracking to identify originating connection and send response via that connection.",
          "expected_behavior": [
            "Send message from WebSocket connection A",
            "Create response with matching correlation_id",
            "Verify server uses connection tracking to identify connection A",
            "Verify response is sent via connection A (not connection B)",
            "Send message from different connection B",
            "Verify response for B is sent via connection B",
            "Confirm responses are routed to correct originating connections"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Send message from WebSocket connection A",
            "Create response with matching correlation_id",
            "Verify server uses connection tracking to identify connection A",
            "Verify response is sent via connection A (not connection B)",
            "Send message from different connection B",
            "Verify response for B is sent via connection B",
            "Confirm responses are routed to correct originating connections"
          ]
        },
        {
          "requirement_id": "REQ-026",
          "statement": "System SHALL NOT route response messages to incorrect WebSocket connections.",
          "expected_behavior": [
            "Send request from connection A with correlation_id='req-a'",
            "Send request from connection B with correlation_id='req-b'",
            "Send response for req-a",
            "Verify response is routed to connection A (not B)",
            "Send response for req-b",
            "Verify response is routed to connection B (not A)",
            "Confirm responses never go to wrong connections"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Send request from connection A with correlation_id='req-a'",
            "Send request from connection B with correlation_id='req-b'",
            "Send response for req-a",
            "Verify response is routed to connection A (not B)",
            "Send response for req-b",
            "Verify response is routed to connection B (not A)",
            "Confirm responses never go to wrong connections"
          ]
        },
        {
          "requirement_id": "REQ-029",
          "statement": "System SHALL NOT process messages from channels other than the channel specified in the message.",
          "expected_behavior": [
            "Send message with channel='channel-a' to server",
            "Verify message is processed in channel-a queue only",
            "Send message with channel='channel-b' to server",
            "Verify message is processed in channel-b queue only",
            "Verify channel-a messages are not accessible from channel-b",
            "Verify channel-b messages are not accessible from channel-a",
            "Confirm channel isolation is maintained"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Send message with channel='channel-a' to server",
            "Verify message is processed in channel-a queue only",
            "Send message with channel='channel-b' to server",
            "Verify message is processed in channel-b queue only",
            "Verify channel-a messages are not accessible from channel-b",
            "Verify channel-b messages are not accessible from channel-a",
            "Confirm channel isolation is maintained"
          ]
        },
        {
          "requirement_id": "REQ-030",
          "statement": "System SHALL NOT send response messages if the originating WebSocket connection has been closed.",
          "expected_behavior": [
            "Send request from WebSocket connection",
            "Close WebSocket connection before response is ready",
            "Verify server detects connection is closed",
            "Verify server does NOT attempt to send response to closed connection",
            "Verify no error occurs from sending to closed connection",
            "Confirm closed connections are handled gracefully"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Send request from WebSocket connection",
            "Close WebSocket connection before response is ready",
            "Verify server detects connection is closed",
            "Verify server does NOT attempt to send response to closed connection",
            "Verify no error occurs from sending to closed connection",
            "Confirm closed connections are handled gracefully"
          ]
        },
        {
          "requirement_id": "REQ-031",
          "statement": "System SHALL NOT allow WebSocket connections without proper message format validation.",
          "expected_behavior": [
            "Send malformed JSON message via WebSocket",
            "Verify server rejects message with validation error",
            "Send message with missing required fields",
            "Verify server rejects message",
            "Send message with invalid field types",
            "Verify server rejects message",
            "Confirm only valid messages are processed"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Send malformed JSON message via WebSocket",
            "Verify server rejects message with validation error",
            "Send message with missing required fields",
            "Verify server rejects message",
            "Send message with invalid field types",
            "Verify server rejects message",
            "Confirm only valid messages are processed"
          ]
        }
      ],
      "interface_contracts": [
        {
          "interface_id": "IF-009",
          "kind": "event",
          "purpose": "Event emitted when new WebSocket connection is established",
          "input_fields": [
            "connection_id",
            "established_at"
          ],
          "output_fields": [],
          "errors": [],
          "idempotency": {
            "required": false,
            "key": null,
            "notes": "Event - not idempotent"
          }
        },
        {
          "interface_id": "IF-010",
          "kind": "event",
          "purpose": "Event emitted when message is received from WebSocket client",
          "input_fields": [
            "connection_id",
            "message"
          ],
          "output_fields": [],
          "errors": [],
          "idempotency": {
            "required": false,
            "key": null,
            "notes": "Event - not idempotent"
          }
        },
        {
          "interface_id": "IF-011",
          "kind": "command",
          "purpose": "Create response message with matching correlation_id and route it back to originating connection",
          "input_fields": [
            "correlation_id",
            "response_type",
            "content"
          ],
          "output_fields": [
            "sent"
          ],
          "errors": [
            "CONNECTION_CLOSED",
            "UNKNOWN_CORRELATION_ID"
          ],
          "idempotency": {
            "required": false,
            "key": null,
            "notes": "Not idempotent - sends response to connection"
          }
        },
        {
          "interface_id": "IF-012",
          "kind": "event",
          "purpose": "Event emitted when WebSocket connection is closed",
          "input_fields": [
            "connection_id",
            "closed_at"
          ],
          "output_fields": [],
          "errors": [],
          "idempotency": {
            "required": false,
            "key": null,
            "notes": "Event - not idempotent"
          }
        }
      ],
      "data_contract": [
        {
          "entity": "Message",
          "fields": [
            "id",
            "correlation_id",
            "message_type",
            "channel",
            "content",
            "priority",
            "timeout_seconds",
            "created_at"
          ],
          "classification": [],
          "invariants": [
            "correlation_id must be globally unique across all messages (REQ-027)",
            "channel must pass validation rules (REQ-020, REQ-033)",
            "For response messages (Answer, AuthorizationApproved, AuthorizationDenied), correlation_id must match an existing request message",
            "For request messages (Question, Authorization, Notification), correlation_id is generated at creation time",
            "timeout_seconds must be >= 0 (0 means indefinite wait per REQ-017)"
          ],
          "lifecycle": {
            "states": [
              {
                "state": "created",
                "description": "Message created with correlation_id"
              },
              {
                "state": "sent",
                "description": "Message sent to server (server mode) or displayed to user (direct mode)"
              },
              {
                "state": "queued",
                "description": "Message enqueued in channel queue (server mode only)"
              },
              {
                "state": "displayed",
                "description": "Message displayed to human user in terminal UI (server mode only)"
              },
              {
                "state": "responded",
                "description": "Response message created with matching correlation_id (for request messages)"
              },
              {
                "state": "completed",
                "description": "Message processing completed"
              }
            ],
            "transitions": [
              {
                "from": "created",
                "to": "sent",
                "trigger": "Message sent via WebSocket (server mode) or displayed in terminal (direct mode)"
              },
              {
                "from": "sent",
                "to": "queued",
                "trigger": "Message received by server and enqueued in channel queue (server mode only)"
              },
              {
                "from": "queued",
                "to": "displayed",
                "trigger": "Message displayed in server terminal UI (server mode only)"
              },
              {
                "from": "displayed",
                "to": "responded",
                "trigger": "Human user provides response, response message created with matching correlation_id"
              },
              {
                "from": "responded",
                "to": "completed",
                "trigger": "Response received by client and processing completed"
              }
            ]
          }
        },
        {
          "entity": "Connection",
          "fields": [
            "connection_id",
            "server_url",
            "state",
            "established_at",
            "closed_at"
          ],
          "classification": [],
          "invariants": [
            "connection_id must be unique",
            "When state is 'connected', established_at must be set",
            "When state is 'closed', closed_at must be set and closed_at >= established_at",
            "server_url must be valid WebSocket URL format (ws:// or wss://)"
          ],
          "lifecycle": {
            "states": [
              {
                "state": "establishing",
                "description": "Connection attempt in progress"
              },
              {
                "state": "connected",
                "description": "Connection established and active"
              },
              {
                "state": "closed",
                "description": "Connection closed (by client or server)"
              }
            ],
            "transitions": [
              {
                "from": "establishing",
                "to": "connected",
                "trigger": "WebSocket handshake successful"
              },
              {
                "from": "establishing",
                "to": "closed",
                "trigger": "Connection attempt failed"
              },
              {
                "from": "connected",
                "to": "closed",
                "trigger": "Connection closed by client or server"
              }
            ]
          }
        },
        {
          "entity": "ConnectionMapping",
          "fields": [
            "mapping_id",
            "connection_id",
            "message_id",
            "correlation_id",
            "created_at"
          ],
          "classification": [],
          "invariants": [
            "mapping_id must be unique",
            "connection_id must reference an existing Connection",
            "message_id must reference an existing Message",
            "correlation_id must match the message's correlation_id",
            "Mapping must be removed when connection closes or response is sent (REQ-028, REQ-030)"
          ],
          "lifecycle": {
            "states": [
              {
                "state": "active",
                "description": "Mapping is active and can be used for response routing"
              },
              {
                "state": "removed",
                "description": "Mapping removed (connection closed or response sent)"
              }
            ],
            "transitions": [
              {
                "from": "active",
                "to": "removed",
                "trigger": "Connection closed or response sent"
              }
            ]
          }
        },
        {
          "entity": "ChannelQueue",
          "fields": [
            "channel_name",
            "messages"
          ],
          "classification": [],
          "invariants": [
            "channel_name must reference an existing Channel",
            "Messages must be ordered by enqueue time (FIFO)",
            "Messages in queue must belong to the same channel (REQ-008, REQ-029)",
            "Queue maintains channel isolation (REQ-029)"
          ],
          "lifecycle": {
            "states": [
              {
                "state": "active",
                "description": "Queue is active and can receive messages"
              }
            ],
            "transitions": []
          }
        }
      ],
      "quality_obligations": [
        {
          "quality_contract_id": "QC-009",
          "category": "functional",
          "statement": "System SHALL display queued messages in server terminal UI within 500ms of enqueueing, with message content matching exactly what was sent",
          "targets": []
        },
        {
          "quality_contract_id": "QC-010",
          "category": "functional",
          "statement": "System SHALL create response Message with correlation_id set to the id of the original request message",
          "targets": []
        },
        {
          "quality_contract_id": "QC-011",
          "category": "functional",
          "statement": "System SHALL route response messages back to originating WebSocket connections using connection tracking, ensuring responses are sent via correct connections",
          "targets": []
        },
        {
          "quality_contract_id": "QC-030",
          "category": "error_handling",
          "statement": "System SHALL NOT send response messages if the originating WebSocket connection has been closed",
          "targets": []
        },
        {
          "quality_contract_id": "QC-031",
          "category": "validation",
          "statement": "System SHALL NOT allow WebSocket connections without proper message format validation",
          "targets": []
        }
      ],
      "dependencies": {
        "depends_on_components": [
          "COMP-003"
        ],
        "consumes_interfaces": [
          "IF-005",
          "IF-006",
          "IF-007",
          "IF-008"
        ],
        "publishes_events": [
          "IF-009",
          "IF-010",
          "IF-012"
        ]
      },
      "open_questions": []
    },
    {
      "component_id": "COMP-005",
      "name": "Message Correlation Component",
      "scope": {
        "requirements": [
          "REQ-005",
          "REQ-010",
          "REQ-012",
          "REQ-027",
          "REQ-034"
        ],
        "interfaces_owned": [
          "IF-013",
          "IF-014"
        ],
        "entities_owned": []
      },
      "behavior_contract": [
        {
          "requirement_id": "REQ-005",
          "statement": "WHEN WebSocket client sends question, authorization, or notification message to server, system SHALL create Message object with globally unique correlation_id (UUID) to enable response matching.",
          "expected_behavior": [
            "Send question message via WebSocket client",
            "Verify Message object contains correlation_id field",
            "Verify correlation_id is UUID format (8-4-4-4-12 hexadecimal)",
            "Send authorization message and verify unique correlation_id",
            "Send notification message and verify unique correlation_id",
            "Confirm all correlation_ids are globally unique (no duplicates across 1000 messages)"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Send question message via WebSocket client",
            "Verify Message object contains correlation_id field",
            "Verify correlation_id is UUID format (8-4-4-4-12 hexadecimal)",
            "Send authorization message and verify unique correlation_id",
            "Send notification message and verify unique correlation_id",
            "Confirm all correlation_ids are globally unique (no duplicates across 1000 messages)"
          ]
        },
        {
          "requirement_id": "REQ-010",
          "statement": "WHEN human user provides response to question or authorization request in server terminal, system SHALL create response Message with correlation_id set to the id of the original request message.",
          "expected_behavior": [
            "Send question message with id='msg-123' to server",
            "Human provides response in server terminal",
            "Verify response Message has correlation_id='msg-123'",
            "Send authorization message with id='msg-456'",
            "Human provides authorization decision",
            "Verify response Message has correlation_id='msg-456'",
            "Confirm correlation_id matches original request id exactly"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Send question message with id='msg-123' to server",
            "Human provides response in server terminal",
            "Verify response Message has correlation_id='msg-123'",
            "Send authorization message with id='msg-456'",
            "Human provides authorization decision",
            "Verify response Message has correlation_id='msg-456'",
            "Confirm correlation_id matches original request id exactly"
          ]
        },
        {
          "requirement_id": "REQ-012",
          "statement": "WHEN WebSocket client receives response Message from server, system SHALL maintain a map of pending requests keyed by correlation_id and match response correlation_id to correct pending request using lookup.",
          "expected_behavior": [
            "Send request with correlation_id='req-1'",
            "Send request with correlation_id='req-2'",
            "Receive response with correlation_id='req-1'",
            "Verify response is matched to first request (req-1)",
            "Receive response with correlation_id='req-2'",
            "Verify response is matched to second request (req-2)",
            "Confirm map lookup correctly matches correlation_ids",
            "Verify unmatched correlation_id is handled appropriately"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Send request with correlation_id='req-1'",
            "Send request with correlation_id='req-2'",
            "Receive response with correlation_id='req-1'",
            "Verify response is matched to first request (req-1)",
            "Receive response with correlation_id='req-2'",
            "Verify response is matched to second request (req-2)",
            "Confirm map lookup correctly matches correlation_ids",
            "Verify unmatched correlation_id is handled appropriately"
          ]
        },
        {
          "requirement_id": "REQ-027",
          "statement": "System SHALL NOT allow duplicate correlation_id values across different messages.",
          "expected_behavior": [
            "Generate 1000 messages and collect all correlation_ids",
            "Verify all correlation_ids are unique (no duplicates)",
            "Check correlation_id format is valid UUID",
            "Verify correlation_id uniqueness across different connections",
            "Verify correlation_id uniqueness across different channels",
            "Confirm no duplicate correlation_ids are generated"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Generate 1000 messages and collect all correlation_ids",
            "Verify all correlation_ids are unique (no duplicates)",
            "Check correlation_id format is valid UUID",
            "Verify correlation_id uniqueness across different connections",
            "Verify correlation_id uniqueness across different channels",
            "Confirm no duplicate correlation_ids are generated"
          ]
        },
        {
          "requirement_id": "REQ-034",
          "statement": "System SHALL NOT process responses with correlation_id that does not match any pending request without logging or handling appropriately.",
          "expected_behavior": [
            "Send request with correlation_id='req-1'",
            "Receive response with correlation_id='req-999' (non-existent)",
            "Verify system detects unmatched correlation_id",
            "Verify system logs warning or handles appropriately",
            "Verify system does NOT crash or fail silently",
            "Confirm orphaned responses are detected and handled"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Send request with correlation_id='req-1'",
            "Receive response with correlation_id='req-999' (non-existent)",
            "Verify system detects unmatched correlation_id",
            "Verify system logs warning or handles appropriately",
            "Verify system does NOT crash or fail silently",
            "Confirm orphaned responses are detected and handled"
          ]
        }
      ],
      "interface_contracts": [
        {
          "interface_id": "IF-013",
          "kind": "command",
          "purpose": "Generate globally unique correlation identifier (UUID) for request message",
          "input_fields": [],
          "output_fields": [
            "correlation_id"
          ],
          "errors": [],
          "idempotency": {
            "required": false,
            "key": null,
            "notes": "Not idempotent - each call generates new unique correlation_id"
          }
        },
        {
          "interface_id": "IF-014",
          "kind": "query",
          "purpose": "Match response message to pending request using correlation_id",
          "input_fields": [
            "correlation_id"
          ],
          "output_fields": [
            "matched",
            "request_info"
          ],
          "errors": [
            "UNMATCHED_RESPONSE"
          ],
          "idempotency": {
            "required": true,
            "key": "correlation_id",
            "notes": "Idempotent - same correlation_id returns same match result"
          }
        }
      ],
      "data_contract": [
        {
          "entity": "Message",
          "fields": [
            "id",
            "correlation_id",
            "message_type",
            "channel",
            "content",
            "priority",
            "timeout_seconds",
            "created_at"
          ],
          "classification": [],
          "invariants": [
            "correlation_id must be globally unique across all messages (REQ-027)",
            "channel must pass validation rules (REQ-020, REQ-033)",
            "For response messages (Answer, AuthorizationApproved, AuthorizationDenied), correlation_id must match an existing request message",
            "For request messages (Question, Authorization, Notification), correlation_id is generated at creation time",
            "timeout_seconds must be >= 0 (0 means indefinite wait per REQ-017)"
          ],
          "lifecycle": {
            "states": [
              {
                "state": "created",
                "description": "Message created with correlation_id"
              },
              {
                "state": "sent",
                "description": "Message sent to server (server mode) or displayed to user (direct mode)"
              },
              {
                "state": "queued",
                "description": "Message enqueued in channel queue (server mode only)"
              },
              {
                "state": "displayed",
                "description": "Message displayed to human user in terminal UI (server mode only)"
              },
              {
                "state": "responded",
                "description": "Response message created with matching correlation_id (for request messages)"
              },
              {
                "state": "completed",
                "description": "Message processing completed"
              }
            ],
            "transitions": [
              {
                "from": "created",
                "to": "sent",
                "trigger": "Message sent via WebSocket (server mode) or displayed in terminal (direct mode)"
              },
              {
                "from": "sent",
                "to": "queued",
                "trigger": "Message received by server and enqueued in channel queue (server mode only)"
              },
              {
                "from": "queued",
                "to": "displayed",
                "trigger": "Message displayed in server terminal UI (server mode only)"
              },
              {
                "from": "displayed",
                "to": "responded",
                "trigger": "Human user provides response, response message created with matching correlation_id"
              },
              {
                "from": "responded",
                "to": "completed",
                "trigger": "Response received by client and processing completed"
              }
            ]
          }
        },
        {
          "entity": "PendingRequest",
          "fields": [
            "correlation_id",
            "connection_id",
            "message_type",
            "sent_at",
            "timeout_seconds"
          ],
          "classification": [],
          "invariants": [
            "correlation_id must be unique across all pending requests",
            "correlation_id must match the message's correlation_id",
            "timeout_seconds must be >= 0 (0 means indefinite wait per REQ-017)",
            "Pending request must be removed when response is received or timeout expires"
          ],
          "lifecycle": {
            "states": [
              {
                "state": "pending",
                "description": "Request sent, waiting for response"
              },
              {
                "state": "matched",
                "description": "Response received and matched"
              },
              {
                "state": "timeout",
                "description": "Timeout expired before response received"
              },
              {
                "state": "cancelled",
                "description": "Request cancelled (connection closed)"
              }
            ],
            "transitions": [
              {
                "from": "pending",
                "to": "matched",
                "trigger": "Response received with matching correlation_id"
              },
              {
                "from": "pending",
                "to": "timeout",
                "trigger": "Timeout expired (if timeout_seconds > 0)"
              },
              {
                "from": "pending",
                "to": "cancelled",
                "trigger": "Connection closed"
              }
            ]
          }
        }
      ],
      "quality_obligations": [
        {
          "quality_contract_id": "QC-027",
          "category": "functional",
          "statement": "System SHALL NOT allow duplicate correlation_id values across different messages",
          "targets": []
        },
        {
          "quality_contract_id": "QC-034",
          "category": "error_handling",
          "statement": "System SHALL NOT process responses with correlation_id that does not match any pending request without logging or handling appropriately",
          "targets": []
        }
      ],
      "dependencies": {
        "depends_on_components": [
          "COMP-003",
          "COMP-004"
        ],
        "consumes_interfaces": [
          "IF-005",
          "IF-006",
          "IF-007",
          "IF-008",
          "IF-009",
          "IF-010",
          "IF-011",
          "IF-012"
        ],
        "publishes_events": []
      },
      "open_questions": []
    },
    {
      "component_id": "COMP-006",
      "name": "Connection Tracking Component",
      "scope": {
        "requirements": [
          "REQ-007",
          "REQ-011",
          "REQ-026",
          "REQ-028",
          "REQ-030"
        ],
        "interfaces_owned": [
          "IF-015",
          "IF-016",
          "IF-017"
        ],
        "entities_owned": []
      },
      "behavior_contract": [
        {
          "requirement_id": "REQ-007",
          "statement": "WHEN server receives Message from WebSocket client, system SHALL record mapping between incoming message and originating WebSocket connection for response routing.",
          "expected_behavior": [
            "Send message from WebSocket client to server",
            "Verify server records mapping between message and connection",
            "Send second message from different connection",
            "Verify server maintains separate mappings for each connection",
            "Confirm mapping persists until response is sent or connection closes"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Send message from WebSocket client to server",
            "Verify server records mapping between message and connection",
            "Send second message from different connection",
            "Verify server maintains separate mappings for each connection",
            "Confirm mapping persists until response is sent or connection closes"
          ]
        },
        {
          "requirement_id": "REQ-011",
          "statement": "WHEN server creates response Message with correlation_id matching request, system SHALL use connection tracking to identify originating connection and send response via that connection.",
          "expected_behavior": [
            "Send message from WebSocket connection A",
            "Create response with matching correlation_id",
            "Verify server uses connection tracking to identify connection A",
            "Verify response is sent via connection A (not connection B)",
            "Send message from different connection B",
            "Verify response for B is sent via connection B",
            "Confirm responses are routed to correct originating connections"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Send message from WebSocket connection A",
            "Create response with matching correlation_id",
            "Verify server uses connection tracking to identify connection A",
            "Verify response is sent via connection A (not connection B)",
            "Send message from different connection B",
            "Verify response for B is sent via connection B",
            "Confirm responses are routed to correct originating connections"
          ]
        },
        {
          "requirement_id": "REQ-026",
          "statement": "System SHALL NOT route response messages to incorrect WebSocket connections.",
          "expected_behavior": [
            "Send request from connection A with correlation_id='req-a'",
            "Send request from connection B with correlation_id='req-b'",
            "Send response for req-a",
            "Verify response is routed to connection A (not B)",
            "Send response for req-b",
            "Verify response is routed to connection B (not A)",
            "Confirm responses never go to wrong connections"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Send request from connection A with correlation_id='req-a'",
            "Send request from connection B with correlation_id='req-b'",
            "Send response for req-a",
            "Verify response is routed to connection A (not B)",
            "Send response for req-b",
            "Verify response is routed to connection B (not A)",
            "Confirm responses never go to wrong connections"
          ]
        },
        {
          "requirement_id": "REQ-028",
          "statement": "System SHALL NOT lose connection tracking information when WebSocket connection is established.",
          "expected_behavior": [
            "Establish WebSocket connection and send message",
            "Verify connection tracking information is recorded",
            "Send response and verify connection tracking is used",
            "Establish new connection and verify tracking is separate",
            "Verify connection tracking persists until connection closes",
            "Confirm no connection tracking information is lost"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Establish WebSocket connection and send message",
            "Verify connection tracking information is recorded",
            "Send response and verify connection tracking is used",
            "Establish new connection and verify tracking is separate",
            "Verify connection tracking persists until connection closes",
            "Confirm no connection tracking information is lost"
          ]
        },
        {
          "requirement_id": "REQ-030",
          "statement": "System SHALL NOT send response messages if the originating WebSocket connection has been closed.",
          "expected_behavior": [
            "Send request from WebSocket connection",
            "Close WebSocket connection before response is ready",
            "Verify server detects connection is closed",
            "Verify server does NOT attempt to send response to closed connection",
            "Verify no error occurs from sending to closed connection",
            "Confirm closed connections are handled gracefully"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Send request from WebSocket connection",
            "Close WebSocket connection before response is ready",
            "Verify server detects connection is closed",
            "Verify server does NOT attempt to send response to closed connection",
            "Verify no error occurs from sending to closed connection",
            "Confirm closed connections are handled gracefully"
          ]
        }
      ],
      "interface_contracts": [
        {
          "interface_id": "IF-015",
          "kind": "command",
          "purpose": "Record mapping between incoming message and originating WebSocket connection",
          "input_fields": [
            "connection_id",
            "message_id",
            "correlation_id"
          ],
          "output_fields": [
            "mapping_id"
          ],
          "errors": [],
          "idempotency": {
            "required": false,
            "key": null,
            "notes": "Not idempotent - each call creates new mapping"
          }
        },
        {
          "interface_id": "IF-016",
          "kind": "query",
          "purpose": "Lookup originating WebSocket connection for a message using correlation_id",
          "input_fields": [
            "correlation_id"
          ],
          "output_fields": [
            "connection_id",
            "connection_active"
          ],
          "errors": [],
          "idempotency": {
            "required": true,
            "key": "correlation_id",
            "notes": "Idempotent - same correlation_id returns same connection (unless connection closed in between)"
          }
        },
        {
          "interface_id": "IF-017",
          "kind": "command",
          "purpose": "Remove connection mapping when connection closes or response is sent",
          "input_fields": [
            "connection_id",
            "correlation_id"
          ],
          "output_fields": [
            "removed_count"
          ],
          "errors": [],
          "idempotency": {
            "required": true,
            "key": "connection_id + correlation_id",
            "notes": "Idempotent - removing same mapping multiple times has no effect"
          }
        }
      ],
      "data_contract": [
        {
          "entity": "ConnectionMapping",
          "fields": [
            "mapping_id",
            "connection_id",
            "message_id",
            "correlation_id",
            "created_at"
          ],
          "classification": [],
          "invariants": [
            "mapping_id must be unique",
            "connection_id must reference an existing Connection",
            "message_id must reference an existing Message",
            "correlation_id must match the message's correlation_id",
            "Mapping must be removed when connection closes or response is sent (REQ-028, REQ-030)"
          ],
          "lifecycle": {
            "states": [
              {
                "state": "active",
                "description": "Mapping is active and can be used for response routing"
              },
              {
                "state": "removed",
                "description": "Mapping removed (connection closed or response sent)"
              }
            ],
            "transitions": [
              {
                "from": "active",
                "to": "removed",
                "trigger": "Connection closed or response sent"
              }
            ]
          }
        }
      ],
      "quality_obligations": [
        {
          "quality_contract_id": "QC-007",
          "category": "functional",
          "statement": "System SHALL record mapping between incoming messages and originating WebSocket connections, maintaining separate mappings for each connection, with mappings persisting until response is sent or connection closes",
          "targets": []
        },
        {
          "quality_contract_id": "QC-026",
          "category": "functional",
          "statement": "System SHALL NOT route response messages to incorrect WebSocket connections",
          "targets": []
        },
        {
          "quality_contract_id": "QC-028",
          "category": "functional",
          "statement": "System SHALL NOT lose connection tracking information when WebSocket connection is established",
          "targets": []
        }
      ],
      "dependencies": {
        "depends_on_components": [
          "COMP-004"
        ],
        "consumes_interfaces": [
          "IF-009",
          "IF-010",
          "IF-011",
          "IF-012"
        ],
        "publishes_events": []
      },
      "open_questions": []
    },
    {
      "component_id": "COMP-007",
      "name": "Channel Management Component",
      "scope": {
        "requirements": [
          "REQ-008",
          "REQ-020",
          "REQ-029",
          "REQ-033"
        ],
        "interfaces_owned": [
          "IF-018",
          "IF-019",
          "IF-020"
        ],
        "entities_owned": []
      },
      "behavior_contract": [
        {
          "requirement_id": "REQ-008",
          "statement": "WHEN server receives Message from WebSocket client, system SHALL add message to queue for the channel specified in message, maintaining channel isolation.",
          "expected_behavior": [
            "Send message with channel='test-channel' to server",
            "Verify message is added to queue for 'test-channel'",
            "Send message with channel='other-channel' to server",
            "Verify message is added to queue for 'other-channel'",
            "Verify messages in different channels are isolated (cannot access cross-channel)",
            "Confirm channel isolation is maintained"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Send message with channel='test-channel' to server",
            "Verify message is added to queue for 'test-channel'",
            "Send message with channel='other-channel' to server",
            "Verify message is added to queue for 'other-channel'",
            "Verify messages in different channels are isolated (cannot access cross-channel)",
            "Confirm channel isolation is maintained"
          ]
        },
        {
          "requirement_id": "REQ-020",
          "statement": "WHEN AI agent executes CLI command with channel parameter, system SHALL apply same channel name validation rules regardless of operation mode.",
          "expected_behavior": [
            "Execute command with --channel invalid-channel! in direct mode",
            "Verify channel validation error occurs",
            "Execute command with --channel invalid-channel! in server mode",
            "Verify same channel validation error occurs",
            "Execute with valid channel in both modes",
            "Confirm validation rules are identical in both modes"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Execute command with --channel invalid-channel! in direct mode",
            "Verify channel validation error occurs",
            "Execute command with --channel invalid-channel! in server mode",
            "Verify same channel validation error occurs",
            "Execute with valid channel in both modes",
            "Confirm validation rules are identical in both modes"
          ]
        },
        {
          "requirement_id": "REQ-029",
          "statement": "System SHALL NOT process messages from channels other than the channel specified in the message.",
          "expected_behavior": [
            "Send message with channel='channel-a' to server",
            "Verify message is processed in channel-a queue only",
            "Send message with channel='channel-b' to server",
            "Verify message is processed in channel-b queue only",
            "Verify channel-a messages are not accessible from channel-b",
            "Verify channel-b messages are not accessible from channel-a",
            "Confirm channel isolation is maintained"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Send message with channel='channel-a' to server",
            "Verify message is processed in channel-a queue only",
            "Send message with channel='channel-b' to server",
            "Verify message is processed in channel-b queue only",
            "Verify channel-a messages are not accessible from channel-b",
            "Verify channel-b messages are not accessible from channel-a",
            "Confirm channel isolation is maintained"
          ]
        },
        {
          "requirement_id": "REQ-033",
          "statement": "System SHALL NOT allow messages to bypass channel validation in server mode.",
          "expected_behavior": [
            "Attempt to send message with invalid channel name in server mode",
            "Verify channel validation error occurs",
            "Attempt to send message with valid channel name in server mode",
            "Verify message is accepted",
            "Compare validation behavior with direct mode",
            "Confirm channel validation is identical in both modes"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Attempt to send message with invalid channel name in server mode",
            "Verify channel validation error occurs",
            "Attempt to send message with valid channel name in server mode",
            "Verify message is accepted",
            "Compare validation behavior with direct mode",
            "Confirm channel validation is identical in both modes"
          ]
        }
      ],
      "interface_contracts": [
        {
          "interface_id": "IF-018",
          "kind": "query",
          "purpose": "Validate channel name according to validation rules",
          "input_fields": [
            "channel_name"
          ],
          "output_fields": [
            "valid",
            "error_message"
          ],
          "errors": [
            "INVALID_CHANNEL"
          ],
          "idempotency": {
            "required": true,
            "key": "channel_name",
            "notes": "Idempotent - same channel name always returns same validation result"
          }
        },
        {
          "interface_id": "IF-019",
          "kind": "command",
          "purpose": "Add message to channel-specific queue, maintaining channel isolation",
          "input_fields": [
            "channel",
            "message"
          ],
          "output_fields": [
            "enqueued_at",
            "queue_position"
          ],
          "errors": [
            "INVALID_CHANNEL"
          ],
          "idempotency": {
            "required": false,
            "key": null,
            "notes": "Not idempotent - each call adds message to queue"
          }
        },
        {
          "interface_id": "IF-020",
          "kind": "query",
          "purpose": "Retrieve messages from channel-specific queue",
          "input_fields": [
            "channel"
          ],
          "output_fields": [
            "messages"
          ],
          "errors": [
            "INVALID_CHANNEL"
          ],
          "idempotency": {
            "required": true,
            "key": "channel",
            "notes": "Idempotent - same channel returns same queue contents (unless messages are dequeued)"
          }
        }
      ],
      "data_contract": [
        {
          "entity": "Channel",
          "fields": [
            "name",
            "created_at"
          ],
          "classification": [],
          "invariants": [
            "name must be unique",
            "name must pass channel validation rules (REQ-020, REQ-033)",
            "Messages in different channels must remain isolated (REQ-008, REQ-029)"
          ],
          "lifecycle": {
            "states": [
              {
                "state": "active",
                "description": "Channel is active and can receive messages"
              }
            ],
            "transitions": []
          }
        },
        {
          "entity": "ChannelQueue",
          "fields": [
            "channel_name",
            "messages"
          ],
          "classification": [],
          "invariants": [
            "channel_name must reference an existing Channel",
            "Messages must be ordered by enqueue time (FIFO)",
            "Messages in queue must belong to the same channel (REQ-008, REQ-029)",
            "Queue maintains channel isolation (REQ-029)"
          ],
          "lifecycle": {
            "states": [
              {
                "state": "active",
                "description": "Queue is active and can receive messages"
              }
            ],
            "transitions": []
          }
        }
      ],
      "quality_obligations": [
        {
          "quality_contract_id": "QC-008",
          "category": "functional",
          "statement": "System SHALL add messages to channel-specific queues, maintaining complete channel isolation where messages in different channels cannot access each other",
          "targets": []
        },
        {
          "quality_contract_id": "QC-020",
          "category": "validation",
          "statement": "System SHALL apply same channel name validation rules regardless of operation mode (direct or server)",
          "targets": []
        },
        {
          "quality_contract_id": "QC-029",
          "category": "functional",
          "statement": "System SHALL NOT process messages from channels other than the channel specified in the message",
          "targets": []
        },
        {
          "quality_contract_id": "QC-033",
          "category": "validation",
          "statement": "System SHALL NOT allow messages to bypass channel validation in server mode",
          "targets": []
        }
      ],
      "dependencies": {
        "depends_on_components": [
          "COMP-002",
          "COMP-003",
          "COMP-004"
        ],
        "consumes_interfaces": [
          "IF-002",
          "IF-003",
          "IF-004",
          "IF-005",
          "IF-006",
          "IF-007",
          "IF-008",
          "IF-009",
          "IF-010",
          "IF-011",
          "IF-012"
        ],
        "publishes_events": []
      },
      "open_questions": []
    },
    {
      "component_id": "COMP-008",
      "name": "Configuration Component",
      "scope": {
        "requirements": [
          "REQ-016",
          "REQ-017",
          "REQ-018",
          "REQ-036"
        ],
        "interfaces_owned": [
          "IF-021",
          "IF-022"
        ],
        "entities_owned": []
      },
      "behavior_contract": [
        {
          "requirement_id": "REQ-016",
          "statement": "WHEN WebSocket client waits for server response in server mode, IF configuration file timeout_seconds is greater than 0, system SHALL apply timeout_seconds from configuration file as maximum wait time for server response.",
          "expected_behavior": [
            "Set timeout_seconds=10 in configuration file",
            "Send question message in server mode",
            "Verify timeout of 10 seconds is applied",
            "Wait 11 seconds without response",
            "Verify timeout error occurs at 10 seconds (within 100ms tolerance)",
            "Set timeout_seconds=30 and verify 30 second timeout is applied",
            "Confirm timeout_seconds from config file is used correctly"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Set timeout_seconds=10 in configuration file",
            "Send question message in server mode",
            "Verify timeout of 10 seconds is applied",
            "Wait 11 seconds without response",
            "Verify timeout error occurs at 10 seconds (within 100ms tolerance)",
            "Set timeout_seconds=30 and verify 30 second timeout is applied",
            "Confirm timeout_seconds from config file is used correctly"
          ]
        },
        {
          "requirement_id": "REQ-017",
          "statement": "WHEN WebSocket client waits for server response in server mode, IF configuration file timeout_seconds is 0, system SHALL wait indefinitely for server response without timeout expiration.",
          "expected_behavior": [
            "Set timeout_seconds=0 in configuration file",
            "Send question message in server mode",
            "Wait 60 seconds without response",
            "Verify no timeout error occurs",
            "Wait 300 seconds without response",
            "Verify still no timeout error occurs",
            "Confirm system waits indefinitely when timeout_seconds=0"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Set timeout_seconds=0 in configuration file",
            "Send question message in server mode",
            "Wait 60 seconds without response",
            "Verify no timeout error occurs",
            "Wait 300 seconds without response",
            "Verify still no timeout error occurs",
            "Confirm system waits indefinitely when timeout_seconds=0"
          ]
        },
        {
          "requirement_id": "REQ-018",
          "statement": "WHEN timeout expires while waiting for server response, system SHALL display timeout error message and exit with error code 1.",
          "expected_behavior": [
            "Set timeout_seconds=5 in configuration",
            "Send question message and wait 6 seconds",
            "Verify timeout error message is displayed",
            "Verify command exits with error code 1",
            "Verify timeout occurs within 100ms of configured timeout",
            "Confirm timeout error is clear and actionable"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Set timeout_seconds=5 in configuration",
            "Send question message and wait 6 seconds",
            "Verify timeout error message is displayed",
            "Verify command exits with error code 1",
            "Verify timeout occurs within 100ms of configured timeout",
            "Confirm timeout error is clear and actionable"
          ]
        },
        {
          "requirement_id": "REQ-036",
          "statement": "System SHALL NOT mix timeout handling between direct mode and server mode - each mode SHALL have independent timeout logic.",
          "expected_behavior": [
            "Set timeout_seconds=10 in config",
            "Execute ask command in direct mode and verify timeout behavior",
            "Execute ask command in server mode and verify timeout behavior",
            "Verify timeout logic is independent for each mode",
            "Change timeout in config and verify each mode uses its own timeout",
            "Confirm timeout handling does not mix between modes"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Set timeout_seconds=10 in config",
            "Execute ask command in direct mode and verify timeout behavior",
            "Execute ask command in server mode and verify timeout behavior",
            "Verify timeout logic is independent for each mode",
            "Change timeout in config and verify each mode uses its own timeout",
            "Confirm timeout handling does not mix between modes"
          ]
        }
      ],
      "interface_contracts": [
        {
          "interface_id": "IF-021",
          "kind": "query",
          "purpose": "Retrieve timeout configuration from configuration file",
          "input_fields": [
            "operation_mode"
          ],
          "output_fields": [
            "timeout_seconds"
          ],
          "errors": [],
          "idempotency": {
            "required": true,
            "key": "operation_mode",
            "notes": "Idempotent - same operation mode returns same timeout configuration"
          }
        },
        {
          "interface_id": "IF-022",
          "kind": "query",
          "purpose": "Retrieve output format preference (JSON or plain text)",
          "input_fields": [],
          "output_fields": [
            "output_format"
          ],
          "errors": [],
          "idempotency": {
            "required": true,
            "key": null,
            "notes": "Idempotent - returns same output format preference"
          }
        }
      ],
      "data_contract": [
        {
          "entity": "Configuration",
          "fields": [
            "timeout_seconds_direct",
            "timeout_seconds_server",
            "output_format"
          ],
          "classification": [],
          "invariants": [
            "timeout_seconds_direct must be >= 0 (0 means indefinite wait per REQ-017)",
            "timeout_seconds_server must be >= 0 (0 means indefinite wait per REQ-017)",
            "Timeout logic must be independent for direct mode and server mode (REQ-036)"
          ],
          "lifecycle": {
            "states": [
              {
                "state": "active",
                "description": "Configuration is active and being used"
              }
            ],
            "transitions": []
          }
        }
      ],
      "quality_obligations": [
        {
          "quality_contract_id": "QC-036",
          "category": "functional",
          "statement": "System SHALL NOT mix timeout handling between direct mode and server mode - each mode SHALL have independent timeout logic",
          "targets": []
        }
      ],
      "dependencies": {
        "depends_on_components": [
          "COMP-002",
          "COMP-003"
        ],
        "consumes_interfaces": [
          "IF-002",
          "IF-003",
          "IF-004",
          "IF-005",
          "IF-006",
          "IF-007",
          "IF-008"
        ],
        "publishes_events": []
      },
      "open_questions": []
    },
    {
      "component_id": "COMP-009",
      "name": "Error Handling Component",
      "scope": {
        "requirements": [
          "REQ-014",
          "REQ-018",
          "REQ-025",
          "REQ-032"
        ],
        "interfaces_owned": [
          "IF-023",
          "IF-024"
        ],
        "entities_owned": []
      },
      "behavior_contract": [
        {
          "requirement_id": "REQ-014",
          "statement": "WHEN WebSocket client attempts to connect to server but connection fails, system SHALL display error message in format 'Failed to connect to server at {URL}: {error_type}. Ensure server is running and accessible.' and exit with error code 1, without falling back to direct mode.",
          "expected_behavior": [
            "Set AILOOP_SERVER=http://unreachable:8080",
            "Execute 'ailoop ask \"test\"' command",
            "Verify error message format: 'Failed to connect to server at http://unreachable:8080: {error_type}. Ensure server is running and accessible.'",
            "Verify error_type is specific (connection refused, network unreachable, etc.)",
            "Verify command exits with error code 1",
            "Verify system does NOT fall back to direct mode",
            "Confirm error message includes URL and actionable guidance"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Set AILOOP_SERVER=http://unreachable:8080",
            "Execute 'ailoop ask \"test\"' command",
            "Verify error message format: 'Failed to connect to server at http://unreachable:8080: {error_type}. Ensure server is running and accessible.'",
            "Verify error_type is specific (connection refused, network unreachable, etc.)",
            "Verify command exits with error code 1",
            "Verify system does NOT fall back to direct mode",
            "Confirm error message includes URL and actionable guidance"
          ]
        },
        {
          "requirement_id": "REQ-018",
          "statement": "WHEN timeout expires while waiting for server response, system SHALL display timeout error message and exit with error code 1.",
          "expected_behavior": [
            "Set timeout_seconds=5 in configuration",
            "Send question message and wait 6 seconds",
            "Verify timeout error message is displayed",
            "Verify command exits with error code 1",
            "Verify timeout occurs within 100ms of configured timeout",
            "Confirm timeout error is clear and actionable"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Set timeout_seconds=5 in configuration",
            "Send question message and wait 6 seconds",
            "Verify timeout error message is displayed",
            "Verify command exits with error code 1",
            "Verify timeout occurs within 100ms of configured timeout",
            "Confirm timeout error is clear and actionable"
          ]
        },
        {
          "requirement_id": "REQ-025",
          "statement": "System SHALL NOT fall back to direct mode when server connection fails in server mode.",
          "expected_behavior": [
            "Set AILOOP_SERVER=http://unreachable:8080",
            "Execute 'ailoop ask \"test\"' command",
            "Verify connection fails",
            "Verify system does NOT fall back to direct mode",
            "Verify error is reported and command fails",
            "Confirm no local terminal prompt appears"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Set AILOOP_SERVER=http://unreachable:8080",
            "Execute 'ailoop ask \"test\"' command",
            "Verify connection fails",
            "Verify system does NOT fall back to direct mode",
            "Verify error is reported and command fails",
            "Confirm no local terminal prompt appears"
          ]
        },
        {
          "requirement_id": "REQ-032",
          "statement": "System SHALL NOT expose sensitive connection details (internal IPs, connection IDs, internal state) in error messages to clients.",
          "expected_behavior": [
            "Trigger connection error and capture error message",
            "Verify error message does NOT contain internal IP addresses",
            "Verify error message does NOT contain connection IDs",
            "Verify error message does NOT contain internal state information",
            "Verify error message contains only user-facing information (URL, error type, guidance)",
            "Confirm sensitive details are not exposed"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Trigger connection error and capture error message",
            "Verify error message does NOT contain internal IP addresses",
            "Verify error message does NOT contain connection IDs",
            "Verify error message does NOT contain internal state information",
            "Verify error message contains only user-facing information (URL, error type, guidance)",
            "Confirm sensitive details are not exposed"
          ]
        }
      ],
      "interface_contracts": [
        {
          "interface_id": "IF-023",
          "kind": "command",
          "purpose": "Format connection error message with URL and error type, ensuring no sensitive information is exposed",
          "input_fields": [
            "server_url",
            "error_type",
            "raw_error"
          ],
          "output_fields": [
            "error_message",
            "exit_code"
          ],
          "errors": [],
          "idempotency": {
            "required": true,
            "key": "server_url + error_type",
            "notes": "Idempotent - same inputs produce same formatted error message"
          }
        },
        {
          "interface_id": "IF-024",
          "kind": "command",
          "purpose": "Format timeout error message when waiting for server response",
          "input_fields": [
            "timeout_seconds"
          ],
          "output_fields": [
            "error_message",
            "exit_code"
          ],
          "errors": [],
          "idempotency": {
            "required": true,
            "key": "timeout_seconds",
            "notes": "Idempotent - same timeout value produces same formatted error message"
          }
        }
      ],
      "data_contract": [],
      "quality_obligations": [
        {
          "quality_contract_id": "QC-025",
          "category": "error_handling",
          "statement": "System SHALL NOT fall back to direct mode when server connection fails in server mode",
          "targets": []
        },
        {
          "quality_contract_id": "QC-032",
          "category": "security",
          "statement": "System SHALL NOT expose sensitive connection details (internal IPs, connection IDs, internal state) in error messages to clients",
          "targets": []
        }
      ],
      "dependencies": {
        "depends_on_components": [
          "COMP-003"
        ],
        "consumes_interfaces": [
          "IF-005",
          "IF-006",
          "IF-007",
          "IF-008"
        ],
        "publishes_events": []
      },
      "open_questions": []
    },
    {
      "component_id": "COMP-010",
      "name": "Output Formatting Component",
      "scope": {
        "requirements": [
          "REQ-021"
        ],
        "interfaces_owned": [
          "IF-025"
        ],
        "entities_owned": []
      },
      "behavior_contract": [
        {
          "requirement_id": "REQ-021",
          "statement": "WHEN AI agent executes CLI command with --json flag, system SHALL generate JSON output with same structure and fields regardless of operation mode.",
          "expected_behavior": [
            "Execute 'ailoop ask \"test\"' --json in direct mode",
            "Capture JSON output structure",
            "Set AILOOP_SERVER and execute 'ailoop ask \"test\"' --json in server mode",
            "Capture JSON output structure",
            "Compare JSON structures and verify they are identical",
            "Verify same fields are present in both modes",
            "Confirm JSON format is consistent"
          ],
          "error_behavior": [],
          "security_notes": [],
          "invariants": [],
          "acceptance_criteria": [
            "Execute 'ailoop ask \"test\"' --json in direct mode",
            "Capture JSON output structure",
            "Set AILOOP_SERVER and execute 'ailoop ask \"test\"' --json in server mode",
            "Capture JSON output structure",
            "Compare JSON structures and verify they are identical",
            "Verify same fields are present in both modes",
            "Confirm JSON format is consistent"
          ]
        }
      ],
      "interface_contracts": [
        {
          "interface_id": "IF-025",
          "kind": "command",
          "purpose": "Format response data as JSON or plain text, ensuring consistent format across direct mode and server mode",
          "input_fields": [
            "response_data",
            "output_format"
          ],
          "output_fields": [
            "formatted_output"
          ],
          "errors": [],
          "idempotency": {
            "required": true,
            "key": "response_data + output_format",
            "notes": "Idempotent - same inputs produce same formatted output"
          }
        }
      ],
      "data_contract": [],
      "quality_obligations": [
        {
          "quality_contract_id": "QC-021",
          "category": "functional",
          "statement": "System SHALL generate JSON output with same structure and fields regardless of operation mode (direct or server)",
          "targets": []
        }
      ],
      "dependencies": {
        "depends_on_components": [
          "COMP-002",
          "COMP-003"
        ],
        "consumes_interfaces": [
          "IF-002",
          "IF-003",
          "IF-004",
          "IF-005",
          "IF-006",
          "IF-007",
          "IF-008"
        ],
        "publishes_events": []
      },
      "open_questions": []
    }
  ],
  "build_notes": [
    "Component contracts derived from architecture, interfaces, data model, and quality contracts",
    "Each contract is complete enough to implement and test independently",
    "Dependencies indicate component build order"
  ]
}